# This file was generated. Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"account\""
type Account {
    accountId: uuid!
    accountName: String!
    "An aggregate relationship"
    allDetailViewsAggregate(
        "distinct select on columns"
        distinctOn: [AllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AllDetailViewOrderBy!],
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): AllDetailViewAggregate!
    "An array relationship"
    all_detail_views(
        "distinct select on columns"
        distinctOn: [AllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AllDetailViewOrderBy!],
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): [AllDetailView!]!
    "An array relationship"
    credit_card_summaries(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    displayOrder: Int!
    "An object relationship"
    group: Group!
    groupId: uuid!
    validFlag: Boolean
}

"aggregated selection of \"account\""
type AccountAggregate {
    aggregate: AccountAggregateFields
    nodes: [Account!]!
}

"aggregate fields of \"account\""
type AccountAggregateFields {
    avg: AccountAvgFields
    count(columns: [AccountSelectColumn!], distinct: Boolean): Int!
    max: AccountMaxFields
    min: AccountMinFields
    stddev: AccountStddevFields
    stddevPop: AccountStddevPopFields
    stddevSamp: AccountStddevSampFields
    sum: AccountSumFields
    varPop: AccountVarPopFields
    varSamp: AccountVarSampFields
    variance: AccountVarianceFields
}

"aggregate avg on columns"
type AccountAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type AccountMaxFields {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
}

"aggregate min on columns"
type AccountMinFields {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
}

"response of any mutation on the table \"account\""
type AccountMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Account!]!
}

"aggregate stddev on columns"
type AccountStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type AccountStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type AccountStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type AccountSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type AccountVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type AccountVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type AccountVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"affiliation\""
type Affiliation {
    affiliationId: uuid!
    "An object relationship"
    group: Group!
    groupId: uuid!
    groupRoleId: uuid!
    "An object relationship"
    group_role: GroupRole!
    "An object relationship"
    user: User!
    userId: uuid!
}

"columns and relationships of \"all_detail_view\""
type AllDetailView {
    accountId: uuid
    categoryId: uuid
    date: date
    genreId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"aggregated selection of \"all_detail_view\""
type AllDetailViewAggregate {
    aggregate: AllDetailViewAggregateFields
    nodes: [AllDetailView!]!
}

"aggregate fields of \"all_detail_view\""
type AllDetailViewAggregateFields {
    avg: AllDetailViewAvgFields
    count(columns: [AllDetailViewSelectColumn!], distinct: Boolean): Int!
    max: AllDetailViewMaxFields
    min: AllDetailViewMinFields
    stddev: AllDetailViewStddevFields
    stddevPop: AllDetailViewStddevPopFields
    stddevSamp: AllDetailViewStddevSampFields
    sum: AllDetailViewSumFields
    varPop: AllDetailViewVarPopFields
    varSamp: AllDetailViewVarSampFields
    variance: AllDetailViewVarianceFields
}

"aggregate avg on columns"
type AllDetailViewAvgFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate max on columns"
type AllDetailViewMaxFields {
    accountId: uuid
    categoryId: uuid
    date: date
    genreId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"aggregate min on columns"
type AllDetailViewMinFields {
    accountId: uuid
    categoryId: uuid
    date: date
    genreId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"aggregate stddev on columns"
type AllDetailViewStddevFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate stddevPop on columns"
type AllDetailViewStddevPopFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate stddevSamp on columns"
type AllDetailViewStddevSampFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate sum on columns"
type AllDetailViewSumFields {
    originalAmount: numeric
    signedAmount: numeric
}

"aggregate varPop on columns"
type AllDetailViewVarPopFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate varSamp on columns"
type AllDetailViewVarSampFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate variance on columns"
type AllDetailViewVarianceFields {
    originalAmount: Float
    signedAmount: Float
}

"columns and relationships of \"application\""
type Application {
    application: String!
    applicationId: uuid!
    "An array relationship"
    groupApplications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "An array relationship"
    group_applications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    topUrl: String!
    validFlag: Boolean
}

"columns and relationships of \"category\""
type Category {
    categoryId: uuid!
    categoryName: String!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "An object relationship"
    depositCategory: DepositCategory
    displayOrder: Int!
    "An object relationship"
    genre: Genre!
    genreId: uuid!
    "An object relationship"
    group: Group!
    groupId: uuid!
    "An array relationship"
    summaryCategories(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "An array relationship"
    transferIncomeCategory(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "An array relationship"
    transferOutcomeCategory(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    validFlag: Boolean
}

"response of any mutation on the table \"category\""
type CategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Category!]!
}

"columns and relationships of \"credit_card_detail\""
type CreditCardDetail {
    amount: numeric!
    "An object relationship"
    category: Category!
    categoryId: uuid!
    "An object relationship"
    credit_card_summary: CreditCardSummary!
    date: date!
    "An object relationship"
    genre: Genre!
    genreId: uuid!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    iocomeType: iocome_type!
    memo: String
    summaryId: uuid!
    "An object relationship"
    user: User!
    userId: uuid!
}

"response of any mutation on the table \"credit_card_detail\""
type CreditCardDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [CreditCardDetail!]!
}

"columns and relationships of \"credit_card_summary\""
type CreditCardSummary {
    "An object relationship"
    account: Account!
    accountId: uuid!
    count: Int!
    creditCard: String!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An array relationship"
    credit_card_details(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    "An object relationship"
    importFileHistory: ImportFileHistory
    "An object relationship"
    import_file_history: ImportFileHistory!
    totalAmount: numeric!
    withdrawalDate: date!
}

"response of any mutation on the table \"credit_card_summary\""
type CreditCardSummaryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [CreditCardSummary!]!
}

"columns and relationships of \"credit_card_summary_total_by_account_view\""
type CreditCardSummaryTotalByAccountView {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"columns and relationships of \"daily_detail\""
type DailyDetail {
    "An object relationship"
    account: Account!
    accountId: uuid!
    amount: numeric!
    "An object relationship"
    category: Category!
    categoryId: uuid!
    date: date!
    "An object relationship"
    genre: Genre!
    genreId: uuid!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    iocomeType: iocome_type!
    memo: String
    "An object relationship"
    user: User!
    userId: uuid!
}

"response of any mutation on the table \"daily_detail\""
type DailyDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [DailyDetail!]!
}

"columns and relationships of \"daily_total_view\""
type DailyTotalView {
    date: date
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"預金カテゴリ"
type DepositCategory {
    "An object relationship"
    category: Category!
    "カテゴリID"
    categoryId: uuid!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
}

"response of any mutation on the table \"deposit_category\""
type DepositCategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [DepositCategory!]!
}

"columns and relationships of \"genre\""
type Genre {
    "An array relationship"
    categories(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    displayOrder: Int!
    genreId: uuid!
    genreName: String!
    genreType: genre_type!
    "An object relationship"
    group: Group!
    groupId: uuid!
    iocomeType: iocome_type!
    validFlag: Boolean
}

"response of any mutation on the table \"genre\""
type GenreMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Genre!]!
}

"columns and relationships of \"group\""
type Group {
    "An array relationship"
    accounts(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "An aggregate relationship"
    accountsAggregate(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): AccountAggregate!
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An array relationship"
    categories(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An array relationship"
    credit_card_summaries(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "An array relationship"
    depositCategories(
        "distinct select on columns"
        distinctOn: [DepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DepositCategoryOrderBy!],
        "filter the rows returned"
        where: DepositCategoryBoolExp
    ): [DepositCategory!]!
    "An array relationship"
    exchangeItems(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "An array relationship"
    genres(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    groupId: uuid!
    groupName: String!
    "An array relationship"
    group_applications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "An array relationship"
    helpItems(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "An array relationship"
    helpPointEarnedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "An aggregate relationship"
    helpPointEarnedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "An array relationship"
    helpPointEarnedDetails(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "An array relationship"
    helpPointExchangedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "An aggregate relationship"
    helpPointExchangedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "An array relationship"
    helperKids(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "An array relationship"
    import_file_histories(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "An array relationship"
    summary_category_by_groups(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "An object relationship"
    transferCategory: TransferCategory
}

"columns and relationships of \"group_application\""
type GroupApplication {
    "An object relationship"
    application: Application!
    applicationId: uuid!
    "An object relationship"
    group: Group!
    groupApplicationId: uuid!
    groupId: uuid!
}

"columns and relationships of \"group_role\""
type GroupRole {
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    groupRoleId: uuid!
    role: String!
}

"交換品マスタ"
type HelperKidsExchangeItem {
    "ID"
    exchangeItemId: uuid!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "An array relationship"
    helpPointExchangedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "An aggregate relationship"
    helpPointExchangedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "メモ"
    memo: String
    "品名"
    name: String!
    "交換ポイント"
    point: Int!
}

"お手伝い項目マスタ"
type HelperKidsHelpItem {
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "ID"
    helpItemId: uuid!
    "An array relationship"
    helpPointEarnedDetails(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "メモ"
    memo: String
    "項目名"
    name: String!
    "お手伝いポイント"
    point: Int!
}

"お手伝いポイント獲得実績"
type HelperKidsHelpPointEarnedAchievement {
    "獲得日時"
    earnedDatetime: timestamp!
    "獲得ポイント"
    earnedPoint: Int!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "ID"
    helpPointEarnedAchievementId: uuid!
    "An array relationship"
    helpPointEarnedDetails(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    "お手伝いキッズID"
    helperKidId: uuid!
}

"aggregated selection of \"helper_kids.help_point_earned_achievement\""
type HelperKidsHelpPointEarnedAchievementAggregate {
    aggregate: HelperKidsHelpPointEarnedAchievementAggregateFields
    nodes: [HelperKidsHelpPointEarnedAchievement!]!
}

"aggregate fields of \"helper_kids.help_point_earned_achievement\""
type HelperKidsHelpPointEarnedAchievementAggregateFields {
    avg: HelperKidsHelpPointEarnedAchievementAvgFields
    count(columns: [HelperKidsHelpPointEarnedAchievementSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelpPointEarnedAchievementMaxFields
    min: HelperKidsHelpPointEarnedAchievementMinFields
    stddev: HelperKidsHelpPointEarnedAchievementStddevFields
    stddevPop: HelperKidsHelpPointEarnedAchievementStddevPopFields
    stddevSamp: HelperKidsHelpPointEarnedAchievementStddevSampFields
    sum: HelperKidsHelpPointEarnedAchievementSumFields
    varPop: HelperKidsHelpPointEarnedAchievementVarPopFields
    varSamp: HelperKidsHelpPointEarnedAchievementVarSampFields
    variance: HelperKidsHelpPointEarnedAchievementVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelpPointEarnedAchievementAvgFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate max on columns"
type HelperKidsHelpPointEarnedAchievementMaxFields {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"aggregate min on columns"
type HelperKidsHelpPointEarnedAchievementMinFields {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"response of any mutation on the table \"helper_kids.help_point_earned_achievement\""
type HelperKidsHelpPointEarnedAchievementMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpPointEarnedAchievement!]!
}

"aggregate stddev on columns"
type HelperKidsHelpPointEarnedAchievementStddevFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelpPointEarnedAchievementStddevPopFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelpPointEarnedAchievementStddevSampFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate sum on columns"
type HelperKidsHelpPointEarnedAchievementSumFields {
    "獲得ポイント"
    earnedPoint: Int
}

"aggregate varPop on columns"
type HelperKidsHelpPointEarnedAchievementVarPopFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate varSamp on columns"
type HelperKidsHelpPointEarnedAchievementVarSampFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate variance on columns"
type HelperKidsHelpPointEarnedAchievementVarianceFields {
    "獲得ポイント"
    earnedPoint: Float
}

"お手伝いポイント獲得明細"
type HelperKidsHelpPointEarnedDetail {
    "獲得実績ID"
    earnedAchievementId: uuid!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "An object relationship"
    helpItem: HelperKidsHelpItem!
    "お手伝い項目件数"
    helpItemCount: Int!
    "お手伝い項目ID"
    helpItemId: uuid!
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int!
    "An object relationship"
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievement!
    "ID"
    helpPointEarnedDetailId: uuid!
}

"response of any mutation on the table \"helper_kids.help_point_earned_detail\""
type HelperKidsHelpPointEarnedDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpPointEarnedDetail!]!
}

"お手伝いポイント交換実績"
type HelperKidsHelpPointExchangedAchievement {
    "交換件数"
    exchangeCount: Int!
    "An object relationship"
    exchangeItem: HelperKidsExchangeItem!
    "交換品ID"
    exchangeItemId: uuid!
    "交換合計ポイント"
    exchangeTotalPoint: Int!
    "交換日時"
    exchangedDatetime: timestamp!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "ID"
    helpPointExchangedAchievementId: uuid!
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    "お手伝いキッズID"
    helperKidId: uuid!
}

"aggregated selection of \"helper_kids.help_point_exchanged_achievement\""
type HelperKidsHelpPointExchangedAchievementAggregate {
    aggregate: HelperKidsHelpPointExchangedAchievementAggregateFields
    nodes: [HelperKidsHelpPointExchangedAchievement!]!
}

"aggregate fields of \"helper_kids.help_point_exchanged_achievement\""
type HelperKidsHelpPointExchangedAchievementAggregateFields {
    avg: HelperKidsHelpPointExchangedAchievementAvgFields
    count(columns: [HelperKidsHelpPointExchangedAchievementSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelpPointExchangedAchievementMaxFields
    min: HelperKidsHelpPointExchangedAchievementMinFields
    stddev: HelperKidsHelpPointExchangedAchievementStddevFields
    stddevPop: HelperKidsHelpPointExchangedAchievementStddevPopFields
    stddevSamp: HelperKidsHelpPointExchangedAchievementStddevSampFields
    sum: HelperKidsHelpPointExchangedAchievementSumFields
    varPop: HelperKidsHelpPointExchangedAchievementVarPopFields
    varSamp: HelperKidsHelpPointExchangedAchievementVarSampFields
    variance: HelperKidsHelpPointExchangedAchievementVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelpPointExchangedAchievementAvgFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate max on columns"
type HelperKidsHelpPointExchangedAchievementMaxFields {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"aggregate min on columns"
type HelperKidsHelpPointExchangedAchievementMinFields {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"response of any mutation on the table \"helper_kids.help_point_exchanged_achievement\""
type HelperKidsHelpPointExchangedAchievementMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpPointExchangedAchievement!]!
}

"aggregate stddev on columns"
type HelperKidsHelpPointExchangedAchievementStddevFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelpPointExchangedAchievementStddevPopFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelpPointExchangedAchievementStddevSampFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate sum on columns"
type HelperKidsHelpPointExchangedAchievementSumFields {
    "交換件数"
    exchangeCount: Int
    "交換合計ポイント"
    exchangeTotalPoint: Int
}

"aggregate varPop on columns"
type HelperKidsHelpPointExchangedAchievementVarPopFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate varSamp on columns"
type HelperKidsHelpPointExchangedAchievementVarSampFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate variance on columns"
type HelperKidsHelpPointExchangedAchievementVarianceFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"お手伝いキッズマスタ"
type HelperKidsHelperKid {
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "An array relationship"
    helpPointEarnedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "An aggregate relationship"
    helpPointEarnedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "An array relationship"
    helpPointExchangedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "An aggregate relationship"
    helpPointExchangedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "ID"
    helperKidId: uuid!
    "An array relationship"
    helperKidParents(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "An object relationship"
    helperKidPoint: HelperKidsHelperKidPoint
    "氏名"
    name: String!
    "名前 接尾辞"
    nameSuffix: String!
}

"columns and relationships of \"helper_kids.helper_kid_parent\""
type HelperKidsHelperKidParent {
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    helperKidId: uuid!
    helperKidParentId: uuid!
    parentUserId: uuid!
    "An object relationship"
    user: User!
}

"お手伝いキッズポイント"
type HelperKidsHelperKidPoint {
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    "お手伝いキッズID"
    helperKidId: uuid!
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp!
    "ポイント"
    point: Int!
}

"columns and relationships of \"import_file_history\""
type ImportFileHistory {
    "An object relationship"
    credit_card_summary: CreditCardSummary
    fileName: String!
    fileType: String!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    importDatetime: timestamp!
    importUserId: uuid!
    "An object relationship"
    user: User!
}

"response of any mutation on the table \"import_file_history\""
type ImportFileHistoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [ImportFileHistory!]!
}

"columns and relationships of \"summary_category_by_group\""
type SummaryCategoryByGroup {
    "An object relationship"
    category: Category!
    categoryId: uuid!
    displayOrder: Int!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
}

"response of any mutation on the table \"summary_category_by_group\""
type SummaryCategoryByGroupMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [SummaryCategoryByGroup!]!
}

"columns and relationships of \"total_by_category_view\""
type TotalByCategoryView {
    categoryId: uuid
    categoryName: String
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"columns and relationships of \"total_by_genre_view\""
type TotalByGenreView {
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"振替カテゴリ"
type TransferCategory {
    "An object relationship"
    category: Category!
    "An object relationship"
    categoryByOutcomeCategoryId: Category!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "収入カテゴリID"
    incomeCategoryId: uuid!
    "支出カテゴリID"
    outcomeCategoryId: uuid!
}

"response of any mutation on the table \"transfer_category\""
type TransferCategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [TransferCategory!]!
}

"ユーザ"
type User {
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An array relationship"
    credit_card_details(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    displayOrder: Int
    email: String
    "An array relationship"
    helperKidParents(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "An array relationship"
    import_file_histories(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    userId: uuid!
    userName: String
}

"response of any mutation on the table \"user\""
type UserMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [User!]!
}

"mutation root"
type mutation_root {
    "delete data from the table: \"daily_detail\""
    deleteDailyDetail(
        "filter the rows which have to be deleted"
        where: DailyDetailBoolExp!
    ): DailyDetailMutationResponse
    "delete single row from the table: \"daily_detail\""
    deleteDailyDetailByPk(id: uuid!): DailyDetail
    "delete data from the table: \"summary_category_by_group\""
    deleteSummaryCategoryByGroup(
        "filter the rows which have to be deleted"
        where: SummaryCategoryByGroupBoolExp!
    ): SummaryCategoryByGroupMutationResponse
    "delete single row from the table: \"summary_category_by_group\""
    deleteSummaryCategoryByGroupByPk(id: uuid!): SummaryCategoryByGroup
    "insert data into the table: \"account\""
    insertAccount(
        "the rows to be inserted"
        objects: [AccountInsertInput!]!,
        "upsert condition"
        onConflict: AccountOnConflict
    ): AccountMutationResponse
    "insert a single row into the table: \"account\""
    insertAccountOne(
        "the row to be inserted"
        object: AccountInsertInput!,
        "upsert condition"
        onConflict: AccountOnConflict
    ): Account
    "insert data into the table: \"category\""
    insertCategory(
        "the rows to be inserted"
        objects: [CategoryInsertInput!]!,
        "upsert condition"
        onConflict: CategoryOnConflict
    ): CategoryMutationResponse
    "insert a single row into the table: \"category\""
    insertCategoryOne(
        "the row to be inserted"
        object: CategoryInsertInput!,
        "upsert condition"
        onConflict: CategoryOnConflict
    ): Category
    "insert data into the table: \"credit_card_detail\""
    insertCreditCardDetail(
        "the rows to be inserted"
        objects: [CreditCardDetailInsertInput!]!,
        "upsert condition"
        onConflict: CreditCardDetailOnConflict
    ): CreditCardDetailMutationResponse
    "insert a single row into the table: \"credit_card_detail\""
    insertCreditCardDetailOne(
        "the row to be inserted"
        object: CreditCardDetailInsertInput!,
        "upsert condition"
        onConflict: CreditCardDetailOnConflict
    ): CreditCardDetail
    "insert data into the table: \"credit_card_summary\""
    insertCreditCardSummary(
        "the rows to be inserted"
        objects: [CreditCardSummaryInsertInput!]!,
        "upsert condition"
        onConflict: CreditCardSummaryOnConflict
    ): CreditCardSummaryMutationResponse
    "insert a single row into the table: \"credit_card_summary\""
    insertCreditCardSummaryOne(
        "the row to be inserted"
        object: CreditCardSummaryInsertInput!,
        "upsert condition"
        onConflict: CreditCardSummaryOnConflict
    ): CreditCardSummary
    "insert data into the table: \"daily_detail\""
    insertDailyDetail(
        "the rows to be inserted"
        objects: [DailyDetailInsertInput!]!,
        "upsert condition"
        onConflict: DailyDetailOnConflict
    ): DailyDetailMutationResponse
    "insert a single row into the table: \"daily_detail\""
    insertDailyDetailOne(
        "the row to be inserted"
        object: DailyDetailInsertInput!,
        "upsert condition"
        onConflict: DailyDetailOnConflict
    ): DailyDetail
    "insert data into the table: \"deposit_category\""
    insertDepositCategory(
        "the rows to be inserted"
        objects: [DepositCategoryInsertInput!]!,
        "upsert condition"
        onConflict: DepositCategoryOnConflict
    ): DepositCategoryMutationResponse
    "insert a single row into the table: \"deposit_category\""
    insertDepositCategoryOne(
        "the row to be inserted"
        object: DepositCategoryInsertInput!,
        "upsert condition"
        onConflict: DepositCategoryOnConflict
    ): DepositCategory
    "insert data into the table: \"genre\""
    insertGenre(
        "the rows to be inserted"
        objects: [GenreInsertInput!]!,
        "upsert condition"
        onConflict: GenreOnConflict
    ): GenreMutationResponse
    "insert a single row into the table: \"genre\""
    insertGenreOne(
        "the row to be inserted"
        object: GenreInsertInput!,
        "upsert condition"
        onConflict: GenreOnConflict
    ): Genre
    "insert data into the table: \"helper_kids.help_point_earned_achievement\""
    insertHelperKidsHelpPointEarnedAchievement(
        "the rows to be inserted"
        objects: [HelperKidsHelpPointEarnedAchievementInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
    ): HelperKidsHelpPointEarnedAchievementMutationResponse
    "insert a single row into the table: \"helper_kids.help_point_earned_achievement\""
    insertHelperKidsHelpPointEarnedAchievementOne(
        "the row to be inserted"
        object: HelperKidsHelpPointEarnedAchievementInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
    ): HelperKidsHelpPointEarnedAchievement
    "insert data into the table: \"helper_kids.help_point_earned_detail\""
    insertHelperKidsHelpPointEarnedDetail(
        "the rows to be inserted"
        objects: [HelperKidsHelpPointEarnedDetailInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedDetailOnConflict
    ): HelperKidsHelpPointEarnedDetailMutationResponse
    "insert a single row into the table: \"helper_kids.help_point_earned_detail\""
    insertHelperKidsHelpPointEarnedDetailOne(
        "the row to be inserted"
        object: HelperKidsHelpPointEarnedDetailInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedDetailOnConflict
    ): HelperKidsHelpPointEarnedDetail
    "insert data into the table: \"helper_kids.help_point_exchanged_achievement\""
    insertHelperKidsHelpPointExchangedAchievement(
        "the rows to be inserted"
        objects: [HelperKidsHelpPointExchangedAchievementInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpPointExchangedAchievementOnConflict
    ): HelperKidsHelpPointExchangedAchievementMutationResponse
    "insert a single row into the table: \"helper_kids.help_point_exchanged_achievement\""
    insertHelperKidsHelpPointExchangedAchievementOne(
        "the row to be inserted"
        object: HelperKidsHelpPointExchangedAchievementInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpPointExchangedAchievementOnConflict
    ): HelperKidsHelpPointExchangedAchievement
    "insert data into the table: \"import_file_history\""
    insertImportFileHistory(
        "the rows to be inserted"
        objects: [ImportFileHistoryInsertInput!]!,
        "upsert condition"
        onConflict: ImportFileHistoryOnConflict
    ): ImportFileHistoryMutationResponse
    "insert a single row into the table: \"import_file_history\""
    insertImportFileHistoryOne(
        "the row to be inserted"
        object: ImportFileHistoryInsertInput!,
        "upsert condition"
        onConflict: ImportFileHistoryOnConflict
    ): ImportFileHistory
    "insert data into the table: \"summary_category_by_group\""
    insertSummaryCategoryByGroup(
        "the rows to be inserted"
        objects: [SummaryCategoryByGroupInsertInput!]!,
        "upsert condition"
        onConflict: SummaryCategoryByGroupOnConflict
    ): SummaryCategoryByGroupMutationResponse
    "insert a single row into the table: \"summary_category_by_group\""
    insertSummaryCategoryByGroupOne(
        "the row to be inserted"
        object: SummaryCategoryByGroupInsertInput!,
        "upsert condition"
        onConflict: SummaryCategoryByGroupOnConflict
    ): SummaryCategoryByGroup
    "insert data into the table: \"transfer_category\""
    insertTransferCategory(
        "the rows to be inserted"
        objects: [TransferCategoryInsertInput!]!,
        "upsert condition"
        onConflict: TransferCategoryOnConflict
    ): TransferCategoryMutationResponse
    "insert a single row into the table: \"transfer_category\""
    insertTransferCategoryOne(
        "the row to be inserted"
        object: TransferCategoryInsertInput!,
        "upsert condition"
        onConflict: TransferCategoryOnConflict
    ): TransferCategory
    "insert data into the table: \"user\""
    insertUser(
        "the rows to be inserted"
        objects: [UserInsertInput!]!,
        "upsert condition"
        onConflict: UserOnConflict
    ): UserMutationResponse
    "insert a single row into the table: \"user\""
    insertUserOne(
        "the row to be inserted"
        object: UserInsertInput!,
        "upsert condition"
        onConflict: UserOnConflict
    ): User
    "update data of the table: \"category\""
    updateCategory(
        "increments the numeric columns with given value of the filtered values"
        _inc: CategoryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CategorySetInput,
        "filter the rows which have to be updated"
        where: CategoryBoolExp!
    ): CategoryMutationResponse
    "update single row of the table: \"category\""
    updateCategoryByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: CategoryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CategorySetInput,
        pkColumns: CategoryPkColumnsInput!
    ): Category
    "update multiples rows of table: \"category\""
    updateCategoryMany(
        "updates to execute, in order"
        updates: [CategoryUpdates!]!
    ): [CategoryMutationResponse]
    "update data of the table: \"credit_card_detail\""
    updateCreditCardDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: CreditCardDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CreditCardDetailSetInput,
        "filter the rows which have to be updated"
        where: CreditCardDetailBoolExp!
    ): CreditCardDetailMutationResponse
    "update single row of the table: \"credit_card_detail\""
    updateCreditCardDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: CreditCardDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CreditCardDetailSetInput,
        pkColumns: CreditCardDetailPkColumnsInput!
    ): CreditCardDetail
    "update multiples rows of table: \"credit_card_detail\""
    updateCreditCardDetailMany(
        "updates to execute, in order"
        updates: [CreditCardDetailUpdates!]!
    ): [CreditCardDetailMutationResponse]
    "update data of the table: \"daily_detail\""
    updateDailyDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: DailyDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: DailyDetailSetInput,
        "filter the rows which have to be updated"
        where: DailyDetailBoolExp!
    ): DailyDetailMutationResponse
    "update single row of the table: \"daily_detail\""
    updateDailyDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: DailyDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: DailyDetailSetInput,
        pkColumns: DailyDetailPkColumnsInput!
    ): DailyDetail
    "update multiples rows of table: \"daily_detail\""
    updateDailyDetailMany(
        "updates to execute, in order"
        updates: [DailyDetailUpdates!]!
    ): [DailyDetailMutationResponse]
    "update data of the table: \"genre\""
    updateGenre(
        "increments the numeric columns with given value of the filtered values"
        _inc: GenreIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: GenreSetInput,
        "filter the rows which have to be updated"
        where: GenreBoolExp!
    ): GenreMutationResponse
    "update single row of the table: \"genre\""
    updateGenreByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: GenreIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: GenreSetInput,
        pkColumns: GenrePkColumnsInput!
    ): Genre
    "update multiples rows of table: \"genre\""
    updateGenreMany(
        "updates to execute, in order"
        updates: [GenreUpdates!]!
    ): [GenreMutationResponse]
}

type query_root {
    "fetch data from the table: \"account\""
    account(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "fetch aggregated fields from the table: \"account\""
    accountAggregate(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): AccountAggregate!
    "fetch data from the table: \"account\" using primary key columns"
    accountByPk(accountId: uuid!): Account
    "fetch data from the table: \"affiliation\""
    affiliation(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch data from the table: \"affiliation\" using primary key columns"
    affiliationByPk(affiliationId: uuid!): Affiliation
    "fetch data from the table: \"all_detail_view\""
    allDetailView(
        "distinct select on columns"
        distinctOn: [AllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AllDetailViewOrderBy!],
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): [AllDetailView!]!
    "fetch aggregated fields from the table: \"all_detail_view\""
    allDetailViewAggregate(
        "distinct select on columns"
        distinctOn: [AllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AllDetailViewOrderBy!],
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): AllDetailViewAggregate!
    "fetch data from the table: \"application\""
    application(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch data from the table: \"application\" using primary key columns"
    applicationByPk(applicationId: uuid!): Application
    "fetch data from the table: \"category\""
    category(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "fetch data from the table: \"category\" using primary key columns"
    categoryByPk(categoryId: uuid!): Category
    "execute function \"category_total_by_month\" which returns \"total_by_category_view\""
    categoryTotalByMonth(
        "input parameters for function \"categoryTotalByMonth\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch data from the table: \"credit_card_detail\""
    creditCardDetail(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "fetch data from the table: \"credit_card_detail\" using primary key columns"
    creditCardDetailByPk(id: uuid!): CreditCardDetail
    "fetch data from the table: \"credit_card_summary\""
    creditCardSummary(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "fetch data from the table: \"credit_card_summary\" using primary key columns"
    creditCardSummaryByPk(id: uuid!): CreditCardSummary
    "fetch data from the table: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountView(
        "distinct select on columns"
        distinctOn: [CreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): [CreditCardSummaryTotalByAccountView!]!
    "fetch data from the table: \"daily_detail\""
    dailyDetail(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "execute function \"daily_detail_by_date\" which returns \"daily_detail\""
    dailyDetailByDate(
        "input parameters for function \"dailyDetailByDate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "fetch data from the table: \"daily_detail\" using primary key columns"
    dailyDetailByPk(id: uuid!): DailyDetail
    "fetch data from the table: \"daily_total_view\""
    dailyTotalView(
        "distinct select on columns"
        distinctOn: [DailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyTotalViewOrderBy!],
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): [DailyTotalView!]!
    "fetch data from the table: \"deposit_category\""
    depositCategory(
        "distinct select on columns"
        distinctOn: [DepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DepositCategoryOrderBy!],
        "filter the rows returned"
        where: DepositCategoryBoolExp
    ): [DepositCategory!]!
    "fetch data from the table: \"deposit_category\" using primary key columns"
    depositCategoryByPk(
        "カテゴリID"
        categoryId: uuid!
    ): DepositCategory
    "fetch data from the table: \"genre\""
    genre(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "fetch data from the table: \"genre\" using primary key columns"
    genreByPk(genreId: uuid!): Genre
    "execute function \"genre_total_by_month\" which returns \"total_by_genre_view\""
    genreTotalByMonth(
        "input parameters for function \"genreTotalByMonth\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch data from the table: \"group\""
    group(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch data from the table: \"group_application\""
    groupApplication(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch data from the table: \"group_application\" using primary key columns"
    groupApplicationByPk(groupApplicationId: uuid!): GroupApplication
    "fetch data from the table: \"group\" using primary key columns"
    groupByPk(groupId: uuid!): Group
    "fetch data from the table: \"group_role\""
    groupRole(
        "distinct select on columns"
        distinctOn: [GroupRoleSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupRoleOrderBy!],
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): [GroupRole!]!
    "fetch data from the table: \"group_role\" using primary key columns"
    groupRoleByPk(groupRoleId: uuid!): GroupRole
    "fetch data from the table: \"helper_kids.exchange_item\""
    helperKidsExchangeItem(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "fetch data from the table: \"helper_kids.exchange_item\" using primary key columns"
    helperKidsExchangeItemByPk(
        "ID"
        exchangeItemId: uuid!
    ): HelperKidsExchangeItem
    "fetch data from the table: \"helper_kids.help_item\""
    helperKidsHelpItem(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "fetch data from the table: \"helper_kids.help_item\" using primary key columns"
    helperKidsHelpItemByPk(
        "ID"
        helpItemId: uuid!
    ): HelperKidsHelpItem
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\" using primary key columns"
    helperKidsHelpPointEarnedAchievementByPk(
        "ID"
        helpPointEarnedAchievementId: uuid!
    ): HelperKidsHelpPointEarnedAchievement
    "fetch data from the table: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetail(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "fetch data from the table: \"helper_kids.help_point_earned_detail\" using primary key columns"
    helperKidsHelpPointEarnedDetailByPk(
        "ID"
        helpPointEarnedDetailId: uuid!
    ): HelperKidsHelpPointEarnedDetail
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\" using primary key columns"
    helperKidsHelpPointExchangedAchievementByPk(
        "ID"
        helpPointExchangedAchievementId: uuid!
    ): HelperKidsHelpPointExchangedAchievement
    "fetch data from the table: \"helper_kids.helper_kid\""
    helperKidsHelperKid(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "fetch data from the table: \"helper_kids.helper_kid\" using primary key columns"
    helperKidsHelperKidByPk(
        "ID"
        helperKidId: uuid!
    ): HelperKidsHelperKid
    "fetch data from the table: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParent(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "fetch data from the table: \"helper_kids.helper_kid_parent\" using primary key columns"
    helperKidsHelperKidParentByPk(helperKidParentId: uuid!): HelperKidsHelperKidParent
    "fetch data from the table: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPoint(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidPointSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidPointOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): [HelperKidsHelperKidPoint!]!
    "fetch data from the table: \"helper_kids.helper_kid_point\" using primary key columns"
    helperKidsHelperKidPointByPk(
        "お手伝いキッズID"
        helperKidId: uuid!
    ): HelperKidsHelperKidPoint
    "fetch data from the table: \"import_file_history\""
    importFileHistory(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "fetch data from the table: \"import_file_history\" using primary key columns"
    importFileHistoryByPk(id: uuid!): ImportFileHistory
    "fetch data from the table: \"summary_category_by_group\""
    summaryCategoryByGroup(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "fetch data from the table: \"summary_category_by_group\" using primary key columns"
    summaryCategoryByGroupByPk(id: uuid!): SummaryCategoryByGroup
    "fetch data from the table: \"total_by_category_view\""
    totalByCategoryView(
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch data from the table: \"total_by_genre_view\""
    totalByGenreView(
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch data from the table: \"transfer_category\""
    transferCategory(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "fetch data from the table: \"transfer_category\" using primary key columns"
    transferCategoryByPk(
        "グループID"
        groupId: uuid!
    ): TransferCategory
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
    "fetch data from the table: \"user\" using primary key columns"
    userByPk(userId: uuid!): User
}

type subscription_root {
    "fetch data from the table: \"account\""
    account(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "fetch aggregated fields from the table: \"account\""
    accountAggregate(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): AccountAggregate!
    "fetch data from the table: \"account\" using primary key columns"
    accountByPk(accountId: uuid!): Account
    "fetch data from the table in a streaming manner: \"account\""
    accountStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [AccountStreamCursorInput]!,
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "fetch data from the table: \"affiliation\""
    affiliation(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch data from the table: \"affiliation\" using primary key columns"
    affiliationByPk(affiliationId: uuid!): Affiliation
    "fetch data from the table in a streaming manner: \"affiliation\""
    affiliationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [AffiliationStreamCursorInput]!,
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch data from the table: \"all_detail_view\""
    allDetailView(
        "distinct select on columns"
        distinctOn: [AllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AllDetailViewOrderBy!],
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): [AllDetailView!]!
    "fetch aggregated fields from the table: \"all_detail_view\""
    allDetailViewAggregate(
        "distinct select on columns"
        distinctOn: [AllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AllDetailViewOrderBy!],
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): AllDetailViewAggregate!
    "fetch data from the table in a streaming manner: \"all_detail_view\""
    allDetailViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [AllDetailViewStreamCursorInput]!,
        "filter the rows returned"
        where: AllDetailViewBoolExp
    ): [AllDetailView!]!
    "fetch data from the table: \"application\""
    application(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch data from the table: \"application\" using primary key columns"
    applicationByPk(applicationId: uuid!): Application
    "fetch data from the table in a streaming manner: \"application\""
    applicationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [ApplicationStreamCursorInput]!,
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch data from the table: \"category\""
    category(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "fetch data from the table: \"category\" using primary key columns"
    categoryByPk(categoryId: uuid!): Category
    "fetch data from the table in a streaming manner: \"category\""
    categoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CategoryStreamCursorInput]!,
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "execute function \"category_total_by_month\" which returns \"total_by_category_view\""
    categoryTotalByMonth(
        "input parameters for function \"categoryTotalByMonth\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch data from the table: \"credit_card_detail\""
    creditCardDetail(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "fetch data from the table: \"credit_card_detail\" using primary key columns"
    creditCardDetailByPk(id: uuid!): CreditCardDetail
    "fetch data from the table in a streaming manner: \"credit_card_detail\""
    creditCardDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CreditCardDetailStreamCursorInput]!,
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "fetch data from the table: \"credit_card_summary\""
    creditCardSummary(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "fetch data from the table: \"credit_card_summary\" using primary key columns"
    creditCardSummaryByPk(id: uuid!): CreditCardSummary
    "fetch data from the table in a streaming manner: \"credit_card_summary\""
    creditCardSummaryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CreditCardSummaryStreamCursorInput]!,
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "fetch data from the table: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountView(
        "distinct select on columns"
        distinctOn: [CreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): [CreditCardSummaryTotalByAccountView!]!
    "fetch data from the table in a streaming manner: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CreditCardSummaryTotalByAccountViewStreamCursorInput]!,
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): [CreditCardSummaryTotalByAccountView!]!
    "fetch data from the table: \"daily_detail\""
    dailyDetail(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "execute function \"daily_detail_by_date\" which returns \"daily_detail\""
    dailyDetailByDate(
        "input parameters for function \"dailyDetailByDate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "fetch data from the table: \"daily_detail\" using primary key columns"
    dailyDetailByPk(id: uuid!): DailyDetail
    "fetch data from the table in a streaming manner: \"daily_detail\""
    dailyDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [DailyDetailStreamCursorInput]!,
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "fetch data from the table: \"daily_total_view\""
    dailyTotalView(
        "distinct select on columns"
        distinctOn: [DailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyTotalViewOrderBy!],
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): [DailyTotalView!]!
    "fetch data from the table in a streaming manner: \"daily_total_view\""
    dailyTotalViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [DailyTotalViewStreamCursorInput]!,
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): [DailyTotalView!]!
    "fetch data from the table: \"deposit_category\""
    depositCategory(
        "distinct select on columns"
        distinctOn: [DepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DepositCategoryOrderBy!],
        "filter the rows returned"
        where: DepositCategoryBoolExp
    ): [DepositCategory!]!
    "fetch data from the table: \"deposit_category\" using primary key columns"
    depositCategoryByPk(
        "カテゴリID"
        categoryId: uuid!
    ): DepositCategory
    "fetch data from the table in a streaming manner: \"deposit_category\""
    depositCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [DepositCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: DepositCategoryBoolExp
    ): [DepositCategory!]!
    "fetch data from the table: \"genre\""
    genre(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "fetch data from the table: \"genre\" using primary key columns"
    genreByPk(genreId: uuid!): Genre
    "fetch data from the table in a streaming manner: \"genre\""
    genreStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GenreStreamCursorInput]!,
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "execute function \"genre_total_by_month\" which returns \"total_by_genre_view\""
    genreTotalByMonth(
        "input parameters for function \"genreTotalByMonth\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch data from the table: \"group\""
    group(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch data from the table: \"group_application\""
    groupApplication(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch data from the table: \"group_application\" using primary key columns"
    groupApplicationByPk(groupApplicationId: uuid!): GroupApplication
    "fetch data from the table in a streaming manner: \"group_application\""
    groupApplicationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupApplicationStreamCursorInput]!,
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch data from the table: \"group\" using primary key columns"
    groupByPk(groupId: uuid!): Group
    "fetch data from the table: \"group_role\""
    groupRole(
        "distinct select on columns"
        distinctOn: [GroupRoleSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupRoleOrderBy!],
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): [GroupRole!]!
    "fetch data from the table: \"group_role\" using primary key columns"
    groupRoleByPk(groupRoleId: uuid!): GroupRole
    "fetch data from the table in a streaming manner: \"group_role\""
    groupRoleStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupRoleStreamCursorInput]!,
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): [GroupRole!]!
    "fetch data from the table in a streaming manner: \"group\""
    groupStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupStreamCursorInput]!,
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch data from the table: \"helper_kids.exchange_item\""
    helperKidsExchangeItem(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "fetch data from the table: \"helper_kids.exchange_item\" using primary key columns"
    helperKidsExchangeItemByPk(
        "ID"
        exchangeItemId: uuid!
    ): HelperKidsExchangeItem
    "fetch data from the table in a streaming manner: \"helper_kids.exchange_item\""
    helperKidsExchangeItemStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsExchangeItemStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "fetch data from the table: \"helper_kids.help_item\""
    helperKidsHelpItem(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "fetch data from the table: \"helper_kids.help_item\" using primary key columns"
    helperKidsHelpItemByPk(
        "ID"
        helpItemId: uuid!
    ): HelperKidsHelpItem
    "fetch data from the table in a streaming manner: \"helper_kids.help_item\""
    helperKidsHelpItemStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpItemStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\" using primary key columns"
    helperKidsHelpPointEarnedAchievementByPk(
        "ID"
        helpPointEarnedAchievementId: uuid!
    ): HelperKidsHelpPointEarnedAchievement
    "fetch data from the table in a streaming manner: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievementStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpPointEarnedAchievementStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "fetch data from the table: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetail(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "fetch data from the table: \"helper_kids.help_point_earned_detail\" using primary key columns"
    helperKidsHelpPointEarnedDetailByPk(
        "ID"
        helpPointEarnedDetailId: uuid!
    ): HelperKidsHelpPointEarnedDetail
    "fetch data from the table in a streaming manner: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpPointEarnedDetailStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\" using primary key columns"
    helperKidsHelpPointExchangedAchievementByPk(
        "ID"
        helpPointExchangedAchievementId: uuid!
    ): HelperKidsHelpPointExchangedAchievement
    "fetch data from the table in a streaming manner: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievementStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpPointExchangedAchievementStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "fetch data from the table: \"helper_kids.helper_kid\""
    helperKidsHelperKid(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "fetch data from the table: \"helper_kids.helper_kid\" using primary key columns"
    helperKidsHelperKidByPk(
        "ID"
        helperKidId: uuid!
    ): HelperKidsHelperKid
    "fetch data from the table: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParent(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "fetch data from the table: \"helper_kids.helper_kid_parent\" using primary key columns"
    helperKidsHelperKidParentByPk(helperKidParentId: uuid!): HelperKidsHelperKidParent
    "fetch data from the table in a streaming manner: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParentStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelperKidParentStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "fetch data from the table: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPoint(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidPointSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidPointOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): [HelperKidsHelperKidPoint!]!
    "fetch data from the table: \"helper_kids.helper_kid_point\" using primary key columns"
    helperKidsHelperKidPointByPk(
        "お手伝いキッズID"
        helperKidId: uuid!
    ): HelperKidsHelperKidPoint
    "fetch data from the table in a streaming manner: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPointStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelperKidPointStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): [HelperKidsHelperKidPoint!]!
    "fetch data from the table in a streaming manner: \"helper_kids.helper_kid\""
    helperKidsHelperKidStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelperKidStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "fetch data from the table: \"import_file_history\""
    importFileHistory(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "fetch data from the table: \"import_file_history\" using primary key columns"
    importFileHistoryByPk(id: uuid!): ImportFileHistory
    "fetch data from the table in a streaming manner: \"import_file_history\""
    importFileHistoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [ImportFileHistoryStreamCursorInput]!,
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "fetch data from the table: \"summary_category_by_group\""
    summaryCategoryByGroup(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "fetch data from the table: \"summary_category_by_group\" using primary key columns"
    summaryCategoryByGroupByPk(id: uuid!): SummaryCategoryByGroup
    "fetch data from the table in a streaming manner: \"summary_category_by_group\""
    summaryCategoryByGroupStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [SummaryCategoryByGroupStreamCursorInput]!,
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "fetch data from the table: \"total_by_category_view\""
    totalByCategoryView(
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch data from the table in a streaming manner: \"total_by_category_view\""
    totalByCategoryViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TotalByCategoryViewStreamCursorInput]!,
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch data from the table: \"total_by_genre_view\""
    totalByGenreView(
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch data from the table in a streaming manner: \"total_by_genre_view\""
    totalByGenreViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TotalByGenreViewStreamCursorInput]!,
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch data from the table: \"transfer_category\""
    transferCategory(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "fetch data from the table: \"transfer_category\" using primary key columns"
    transferCategoryByPk(
        "グループID"
        groupId: uuid!
    ): TransferCategory
    "fetch data from the table in a streaming manner: \"transfer_category\""
    transferCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TransferCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
    "fetch data from the table: \"user\" using primary key columns"
    userByPk(userId: uuid!): User
    "fetch data from the table in a streaming manner: \"user\""
    userStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [UserStreamCursorInput]!,
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
}

"unique or primary key constraints on table \"account\""
enum AccountConstraint {
    "unique or primary key constraint on columns \"account_id\""
    account_pkey
}

"select columns of table \"account\""
enum AccountSelectColumn {
    "column name"
    accountId
    "column name"
    accountName
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    validFlag
}

"select \"accountAggregateBoolExpBool_andArgumentsColumns\" columns of table \"account\""
enum AccountSelectColumnAccountAggregateBoolExpBool_andArgumentsColumns {
    "column name"
    validFlag
}

"select \"accountAggregateBoolExpBool_orArgumentsColumns\" columns of table \"account\""
enum AccountSelectColumnAccountAggregateBoolExpBool_orArgumentsColumns {
    "column name"
    validFlag
}

"placeholder for update columns of table \"account\" (current role has no relevant permissions)"
enum AccountUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"select columns of table \"affiliation\""
enum AffiliationSelectColumn {
    "column name"
    affiliationId
    "column name"
    groupId
    "column name"
    groupRoleId
    "column name"
    userId
}

"select columns of table \"all_detail_view\""
enum AllDetailViewSelectColumn {
    "column name"
    accountId
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    originalAmount
    "column name"
    signedAmount
    "column name"
    type
}

"select columns of table \"application\""
enum ApplicationSelectColumn {
    "column name"
    application
    "column name"
    applicationId
    "column name"
    topUrl
    "column name"
    validFlag
}

"unique or primary key constraints on table \"category\""
enum CategoryConstraint {
    "unique or primary key constraint on columns \"category_id\""
    category_pkey
}

"select columns of table \"category\""
enum CategorySelectColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    validFlag
}

"update columns of table \"category\""
enum CategoryUpdateColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    validFlag
}

"unique or primary key constraints on table \"credit_card_detail\""
enum CreditCardDetailConstraint {
    "unique or primary key constraint on columns \"id\""
    credit_card_detail_pkey
}

"select columns of table \"credit_card_detail\""
enum CreditCardDetailSelectColumn {
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    summaryId
    "column name"
    userId
}

"update columns of table \"credit_card_detail\""
enum CreditCardDetailUpdateColumn {
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    summaryId
    "column name"
    userId
}

"unique or primary key constraints on table \"credit_card_summary\""
enum CreditCardSummaryConstraint {
    "unique or primary key constraint on columns \"id\""
    credit_card_summary_pkey
}

"select columns of table \"credit_card_summary\""
enum CreditCardSummarySelectColumn {
    "column name"
    accountId
    "column name"
    count
    "column name"
    creditCard
    "column name"
    groupId
    "column name"
    id
    "column name"
    totalAmount
    "column name"
    withdrawalDate
}

"select columns of table \"credit_card_summary_total_by_account_view\""
enum CreditCardSummaryTotalByAccountViewSelectColumn {
    "column name"
    accountId
    "column name"
    accountName
    "column name"
    date
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"placeholder for update columns of table \"credit_card_summary\" (current role has no relevant permissions)"
enum CreditCardSummaryUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"ordering argument of a cursor"
enum CursorOrdering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"unique or primary key constraints on table \"daily_detail\""
enum DailyDetailConstraint {
    "unique or primary key constraint on columns \"id\""
    daily_detail_pkey
}

"select columns of table \"daily_detail\""
enum DailyDetailSelectColumn {
    "column name"
    accountId
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    userId
}

"update columns of table \"daily_detail\""
enum DailyDetailUpdateColumn {
    "column name"
    accountId
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    userId
}

"select columns of table \"daily_total_view\""
enum DailyTotalViewSelectColumn {
    "column name"
    date
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"unique or primary key constraints on table \"deposit_category\""
enum DepositCategoryConstraint {
    "unique or primary key constraint on columns \"category_id\""
    deposit_category_pkey
}

"select columns of table \"deposit_category\""
enum DepositCategorySelectColumn {
    "column name"
    categoryId
    "column name"
    groupId
}

"placeholder for update columns of table \"deposit_category\" (current role has no relevant permissions)"
enum DepositCategoryUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"unique or primary key constraints on table \"genre\""
enum GenreConstraint {
    "unique or primary key constraint on columns \"genre_id\""
    genre_pkey
}

"select columns of table \"genre\""
enum GenreSelectColumn {
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    genreType
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    validFlag
}

"update columns of table \"genre\""
enum GenreUpdateColumn {
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    genreType
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    validFlag
}

"select columns of table \"group_application\""
enum GroupApplicationSelectColumn {
    "column name"
    applicationId
    "column name"
    groupApplicationId
    "column name"
    groupId
}

"select columns of table \"group_role\""
enum GroupRoleSelectColumn {
    "column name"
    groupRoleId
    "column name"
    role
}

"select columns of table \"group\""
enum GroupSelectColumn {
    "column name"
    groupId
    "column name"
    groupName
}

"select columns of table \"helper_kids.exchange_item\""
enum HelperKidsExchangeItemSelectColumn {
    "column name"
    exchangeItemId
    "column name"
    groupId
    "column name"
    memo
    "column name"
    name
    "column name"
    point
}

"select columns of table \"helper_kids.help_item\""
enum HelperKidsHelpItemSelectColumn {
    "column name"
    groupId
    "column name"
    helpItemId
    "column name"
    memo
    "column name"
    name
    "column name"
    point
}

"unique or primary key constraints on table \"helper_kids.help_point_earned_achievement\""
enum HelperKidsHelpPointEarnedAchievementConstraint {
    "unique or primary key constraint on columns \"help_point_earned_achievement_id\""
    help_point_earned_achievement_pkey
}

"select columns of table \"helper_kids.help_point_earned_achievement\""
enum HelperKidsHelpPointEarnedAchievementSelectColumn {
    "column name"
    earnedDatetime
    "column name"
    earnedPoint
    "column name"
    groupId
    "column name"
    helpPointEarnedAchievementId
    "column name"
    helperKidId
}

"placeholder for update columns of table \"helper_kids.help_point_earned_achievement\" (current role has no relevant permissions)"
enum HelperKidsHelpPointEarnedAchievementUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"unique or primary key constraints on table \"helper_kids.help_point_earned_detail\""
enum HelperKidsHelpPointEarnedDetailConstraint {
    "unique or primary key constraint on columns \"help_point_earned_detail_id\""
    help_point_earned_detail_pkey
}

"select columns of table \"helper_kids.help_point_earned_detail\""
enum HelperKidsHelpPointEarnedDetailSelectColumn {
    "column name"
    earnedAchievementId
    "column name"
    groupId
    "column name"
    helpItemCount
    "column name"
    helpItemId
    "column name"
    helpItemTotalPoint
    "column name"
    helpPointEarnedDetailId
}

"placeholder for update columns of table \"helper_kids.help_point_earned_detail\" (current role has no relevant permissions)"
enum HelperKidsHelpPointEarnedDetailUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"unique or primary key constraints on table \"helper_kids.help_point_exchanged_achievement\""
enum HelperKidsHelpPointExchangedAchievementConstraint {
    "unique or primary key constraint on columns \"help_point_exchanged_achievement_id\""
    help_point_exchanged_achievement_pkey
}

"select columns of table \"helper_kids.help_point_exchanged_achievement\""
enum HelperKidsHelpPointExchangedAchievementSelectColumn {
    "column name"
    exchangeCount
    "column name"
    exchangeItemId
    "column name"
    exchangeTotalPoint
    "column name"
    exchangedDatetime
    "column name"
    groupId
    "column name"
    helpPointExchangedAchievementId
    "column name"
    helperKidId
}

"placeholder for update columns of table \"helper_kids.help_point_exchanged_achievement\" (current role has no relevant permissions)"
enum HelperKidsHelpPointExchangedAchievementUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"select columns of table \"helper_kids.helper_kid_parent\""
enum HelperKidsHelperKidParentSelectColumn {
    "column name"
    helperKidId
    "column name"
    helperKidParentId
    "column name"
    parentUserId
}

"select columns of table \"helper_kids.helper_kid_point\""
enum HelperKidsHelperKidPointSelectColumn {
    "column name"
    helperKidId
    "column name"
    lastHelpDatetime
    "column name"
    point
}

"select columns of table \"helper_kids.helper_kid\""
enum HelperKidsHelperKidSelectColumn {
    "column name"
    groupId
    "column name"
    helperKidId
    "column name"
    name
    "column name"
    nameSuffix
}

"unique or primary key constraints on table \"import_file_history\""
enum ImportFileHistoryConstraint {
    "unique or primary key constraint on columns \"id\""
    import_file_history_pkey
}

"select columns of table \"import_file_history\""
enum ImportFileHistorySelectColumn {
    "column name"
    fileName
    "column name"
    fileType
    "column name"
    groupId
    "column name"
    id
    "column name"
    importDatetime
    "column name"
    importUserId
}

"placeholder for update columns of table \"import_file_history\" (current role has no relevant permissions)"
enum ImportFileHistoryUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"column ordering options"
enum OrderBy {
    "in ascending order, nulls last"
    ASC
    "in ascending order, nulls first"
    ASC_NULLS_FIRST
    "in ascending order, nulls last"
    ASC_NULLS_LAST
    "in descending order, nulls first"
    DESC
    "in descending order, nulls first"
    DESC_NULLS_FIRST
    "in descending order, nulls last"
    DESC_NULLS_LAST
}

"unique or primary key constraints on table \"summary_category_by_group\""
enum SummaryCategoryByGroupConstraint {
    "unique or primary key constraint on columns \"id\""
    summary_category_by_group_pkey
}

"select columns of table \"summary_category_by_group\""
enum SummaryCategoryByGroupSelectColumn {
    "column name"
    categoryId
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    id
}

"placeholder for update columns of table \"summary_category_by_group\" (current role has no relevant permissions)"
enum SummaryCategoryByGroupUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"select columns of table \"total_by_category_view\""
enum TotalByCategoryViewSelectColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    date
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"select columns of table \"total_by_genre_view\""
enum TotalByGenreViewSelectColumn {
    "column name"
    date
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"unique or primary key constraints on table \"transfer_category\""
enum TransferCategoryConstraint {
    "unique or primary key constraint on columns \"group_id\""
    transfer_category_pkey
}

"select columns of table \"transfer_category\""
enum TransferCategorySelectColumn {
    "column name"
    groupId
    "column name"
    incomeCategoryId
    "column name"
    outcomeCategoryId
}

"placeholder for update columns of table \"transfer_category\" (current role has no relevant permissions)"
enum TransferCategoryUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"unique or primary key constraints on table \"user\""
enum UserConstraint {
    "unique or primary key constraint on columns \"email\""
    user_email_key
    "unique or primary key constraint on columns \"user_id\""
    user_pkey
}

"select columns of table \"user\""
enum UserSelectColumn {
    "column name"
    displayOrder
    "column name"
    email
    "column name"
    userId
    "column name"
    userName
}

"placeholder for update columns of table \"user\" (current role has no relevant permissions)"
enum UserUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

scalar date

scalar genre_type

scalar iocome_type

scalar numeric

scalar timestamp

scalar uuid

input AccountAggregateBoolExp {
    bool_and: accountAggregateBoolExpBool_and
    bool_or: accountAggregateBoolExpBool_or
    count: accountAggregateBoolExpCount
}

"order by aggregate values of table \"account\""
input AccountAggregateOrderBy {
    avg: AccountAvgOrderBy
    count: OrderBy
    max: AccountMaxOrderBy
    min: AccountMinOrderBy
    stddev: AccountStddevOrderBy
    stddevPop: AccountStddevPopOrderBy
    stddevSamp: AccountStddevSampOrderBy
    sum: AccountSumOrderBy
    varPop: AccountVarPopOrderBy
    varSamp: AccountVarSampOrderBy
    variance: AccountVarianceOrderBy
}

"order by avg() on columns of table \"account\""
input AccountAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"account\". All fields are combined with a logical 'AND'."
input AccountBoolExp {
    _and: [AccountBoolExp!]
    _not: AccountBoolExp
    _or: [AccountBoolExp!]
    accountId: UuidComparisonExp
    accountName: StringComparisonExp
    all_detail_views: AllDetailViewBoolExp
    all_detail_viewsAggregate: AllDetailViewAggregateBoolExp
    credit_card_summaries: CreditCardSummaryBoolExp
    daily_details: DailyDetailBoolExp
    displayOrder: IntComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for inserting data into table \"account\""
input AccountInsertInput {
    accountId: uuid
    accountName: String
    credit_card_summaries: CreditCardSummaryArrRelInsertInput
    daily_details: DailyDetailArrRelInsertInput
    displayOrder: Int
    groupId: uuid
    validFlag: Boolean
}

"order by max() on columns of table \"account\""
input AccountMaxOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"account\""
input AccountMinOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
}

"input type for inserting object relation for remote table \"account\""
input AccountObjRelInsertInput {
    data: AccountInsertInput!
    "upsert condition"
    onConflict: AccountOnConflict
}

"on_conflict condition type for table \"account\""
input AccountOnConflict {
    constraint: AccountConstraint!
    updateColumns: [AccountUpdateColumn!]! = []
    where: AccountBoolExp
}

"Ordering options when selecting data from \"account\"."
input AccountOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    all_detail_viewsAggregate: AllDetailViewAggregateOrderBy
    credit_card_summariesAggregate: CreditCardSummaryAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    displayOrder: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    validFlag: OrderBy
}

"order by stddev() on columns of table \"account\""
input AccountStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"account\""
input AccountStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"account\""
input AccountStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"account\""
input AccountStreamCursorInput {
    "Stream column input with initial value"
    initialValue: AccountStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input AccountStreamCursorValueInput {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
    validFlag: Boolean
}

"order by sum() on columns of table \"account\""
input AccountSumOrderBy {
    displayOrder: OrderBy
}

"order by varPop() on columns of table \"account\""
input AccountVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"account\""
input AccountVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"account\""
input AccountVarianceOrderBy {
    displayOrder: OrderBy
}

"order by aggregate values of table \"affiliation\""
input AffiliationAggregateOrderBy {
    count: OrderBy
    max: AffiliationMaxOrderBy
    min: AffiliationMinOrderBy
}

"Boolean expression to filter rows from the table \"affiliation\". All fields are combined with a logical 'AND'."
input AffiliationBoolExp {
    _and: [AffiliationBoolExp!]
    _not: AffiliationBoolExp
    _or: [AffiliationBoolExp!]
    affiliationId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    groupRoleId: UuidComparisonExp
    group_role: GroupRoleBoolExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"order by max() on columns of table \"affiliation\""
input AffiliationMaxOrderBy {
    affiliationId: OrderBy
    groupId: OrderBy
    groupRoleId: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"affiliation\""
input AffiliationMinOrderBy {
    affiliationId: OrderBy
    groupId: OrderBy
    groupRoleId: OrderBy
    userId: OrderBy
}

"Ordering options when selecting data from \"affiliation\"."
input AffiliationOrderBy {
    affiliationId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    groupRoleId: OrderBy
    group_role: GroupRoleOrderBy
    user: UserOrderBy
    userId: OrderBy
}

"Streaming cursor of the table \"affiliation\""
input AffiliationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: AffiliationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input AffiliationStreamCursorValueInput {
    affiliationId: uuid
    groupId: uuid
    groupRoleId: uuid
    userId: uuid
}

input AllDetailViewAggregateBoolExp {
    count: allDetailViewAggregateBoolExpCount
}

"order by aggregate values of table \"all_detail_view\""
input AllDetailViewAggregateOrderBy {
    avg: AllDetailViewAvgOrderBy
    count: OrderBy
    max: AllDetailViewMaxOrderBy
    min: AllDetailViewMinOrderBy
    stddev: AllDetailViewStddevOrderBy
    stddevPop: AllDetailViewStddevPopOrderBy
    stddevSamp: AllDetailViewStddevSampOrderBy
    sum: AllDetailViewSumOrderBy
    varPop: AllDetailViewVarPopOrderBy
    varSamp: AllDetailViewVarSampOrderBy
    variance: AllDetailViewVarianceOrderBy
}

"order by avg() on columns of table \"all_detail_view\""
input AllDetailViewAvgOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"Boolean expression to filter rows from the table \"all_detail_view\". All fields are combined with a logical 'AND'."
input AllDetailViewBoolExp {
    _and: [AllDetailViewBoolExp!]
    _not: AllDetailViewBoolExp
    _or: [AllDetailViewBoolExp!]
    accountId: UuidComparisonExp
    categoryId: UuidComparisonExp
    date: DateComparisonExp
    genreId: UuidComparisonExp
    id: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    memo: StringComparisonExp
    originalAmount: NumericComparisonExp
    signedAmount: NumericComparisonExp
    type: StringComparisonExp
}

"order by max() on columns of table \"all_detail_view\""
input AllDetailViewMaxOrderBy {
    accountId: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    originalAmount: OrderBy
    signedAmount: OrderBy
    type: OrderBy
}

"order by min() on columns of table \"all_detail_view\""
input AllDetailViewMinOrderBy {
    accountId: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    originalAmount: OrderBy
    signedAmount: OrderBy
    type: OrderBy
}

"Ordering options when selecting data from \"all_detail_view\"."
input AllDetailViewOrderBy {
    accountId: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    originalAmount: OrderBy
    signedAmount: OrderBy
    type: OrderBy
}

"order by stddev() on columns of table \"all_detail_view\""
input AllDetailViewStddevOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by stddevPop() on columns of table \"all_detail_view\""
input AllDetailViewStddevPopOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by stddevSamp() on columns of table \"all_detail_view\""
input AllDetailViewStddevSampOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"Streaming cursor of the table \"all_detail_view\""
input AllDetailViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: AllDetailViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input AllDetailViewStreamCursorValueInput {
    accountId: uuid
    categoryId: uuid
    date: date
    genreId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"order by sum() on columns of table \"all_detail_view\""
input AllDetailViewSumOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by varPop() on columns of table \"all_detail_view\""
input AllDetailViewVarPopOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by varSamp() on columns of table \"all_detail_view\""
input AllDetailViewVarSampOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by variance() on columns of table \"all_detail_view\""
input AllDetailViewVarianceOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"Boolean expression to filter rows from the table \"application\". All fields are combined with a logical 'AND'."
input ApplicationBoolExp {
    _and: [ApplicationBoolExp!]
    _not: ApplicationBoolExp
    _or: [ApplicationBoolExp!]
    application: StringComparisonExp
    applicationId: UuidComparisonExp
    groupApplications: GroupApplicationBoolExp
    group_applications: GroupApplicationBoolExp
    topUrl: StringComparisonExp
    validFlag: BooleanComparisonExp
}

"Ordering options when selecting data from \"application\"."
input ApplicationOrderBy {
    application: OrderBy
    applicationId: OrderBy
    groupApplicationsAggregate: GroupApplicationAggregateOrderBy
    group_applicationsAggregate: GroupApplicationAggregateOrderBy
    topUrl: OrderBy
    validFlag: OrderBy
}

"Streaming cursor of the table \"application\""
input ApplicationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: ApplicationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input ApplicationStreamCursorValueInput {
    application: String
    applicationId: uuid
    topUrl: String
    validFlag: Boolean
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input BooleanComparisonExp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _isNull: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"order by aggregate values of table \"category\""
input CategoryAggregateOrderBy {
    avg: CategoryAvgOrderBy
    count: OrderBy
    max: CategoryMaxOrderBy
    min: CategoryMinOrderBy
    stddev: CategoryStddevOrderBy
    stddevPop: CategoryStddevPopOrderBy
    stddevSamp: CategoryStddevSampOrderBy
    sum: CategorySumOrderBy
    varPop: CategoryVarPopOrderBy
    varSamp: CategoryVarSampOrderBy
    variance: CategoryVarianceOrderBy
}

"input type for inserting array relation for remote table \"category\""
input CategoryArrRelInsertInput {
    data: [CategoryInsertInput!]!
    "upsert condition"
    onConflict: CategoryOnConflict
}

"order by avg() on columns of table \"category\""
input CategoryAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"category\". All fields are combined with a logical 'AND'."
input CategoryBoolExp {
    _and: [CategoryBoolExp!]
    _not: CategoryBoolExp
    _or: [CategoryBoolExp!]
    categoryId: UuidComparisonExp
    categoryName: StringComparisonExp
    creditCardDetails: CreditCardDetailBoolExp
    dailyDetails: DailyDetailBoolExp
    depositCategory: DepositCategoryBoolExp
    displayOrder: IntComparisonExp
    genre: GenreBoolExp
    genreId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    summaryCategories: SummaryCategoryByGroupBoolExp
    transferIncomeCategory: TransferCategoryBoolExp
    transferOutcomeCategory: TransferCategoryBoolExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"category\""
input CategoryIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"category\""
input CategoryInsertInput {
    categoryId: uuid
    categoryName: String
    creditCardDetails: CreditCardDetailArrRelInsertInput
    dailyDetails: DailyDetailArrRelInsertInput
    depositCategory: DepositCategoryObjRelInsertInput
    displayOrder: Int
    genre: GenreObjRelInsertInput
    genreId: uuid
    groupId: uuid
    summaryCategories: SummaryCategoryByGroupArrRelInsertInput
    transferIncomeCategory: TransferCategoryArrRelInsertInput
    transferOutcomeCategory: TransferCategoryArrRelInsertInput
    validFlag: Boolean
}

"order by max() on columns of table \"category\""
input CategoryMaxOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    displayOrder: OrderBy
    genreId: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"category\""
input CategoryMinOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    displayOrder: OrderBy
    genreId: OrderBy
    groupId: OrderBy
}

"input type for inserting object relation for remote table \"category\""
input CategoryObjRelInsertInput {
    data: CategoryInsertInput!
    "upsert condition"
    onConflict: CategoryOnConflict
}

"on_conflict condition type for table \"category\""
input CategoryOnConflict {
    constraint: CategoryConstraint!
    updateColumns: [CategoryUpdateColumn!]! = []
    where: CategoryBoolExp
}

"Ordering options when selecting data from \"category\"."
input CategoryOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    creditCardDetailsAggregate: CreditCardDetailAggregateOrderBy
    dailyDetailsAggregate: DailyDetailAggregateOrderBy
    depositCategory: DepositCategoryOrderBy
    displayOrder: OrderBy
    genre: GenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    summaryCategoriesAggregate: SummaryCategoryByGroupAggregateOrderBy
    transferIncomeCategoryAggregate: TransferCategoryAggregateOrderBy
    transferOutcomeCategoryAggregate: TransferCategoryAggregateOrderBy
    validFlag: OrderBy
}

"primary key columns input for table: category"
input CategoryPkColumnsInput {
    categoryId: uuid!
}

"input type for updating data in table \"category\""
input CategorySetInput {
    categoryId: uuid
    categoryName: String
    displayOrder: Int
    genreId: uuid
    groupId: uuid
    validFlag: Boolean
}

"order by stddev() on columns of table \"category\""
input CategoryStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"category\""
input CategoryStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"category\""
input CategoryStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"category\""
input CategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CategoryStreamCursorValueInput {
    categoryId: uuid
    categoryName: String
    displayOrder: Int
    genreId: uuid
    groupId: uuid
    validFlag: Boolean
}

"order by sum() on columns of table \"category\""
input CategorySumOrderBy {
    displayOrder: OrderBy
}

input CategoryUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: CategoryIncInput
    "sets the columns of the filtered rows to the given values"
    _set: CategorySetInput
    "filter the rows which have to be updated"
    where: CategoryBoolExp!
}

"order by varPop() on columns of table \"category\""
input CategoryVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"category\""
input CategoryVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"category\""
input CategoryVarianceOrderBy {
    displayOrder: OrderBy
}

"order by aggregate values of table \"credit_card_detail\""
input CreditCardDetailAggregateOrderBy {
    avg: CreditCardDetailAvgOrderBy
    count: OrderBy
    max: CreditCardDetailMaxOrderBy
    min: CreditCardDetailMinOrderBy
    stddev: CreditCardDetailStddevOrderBy
    stddevPop: CreditCardDetailStddevPopOrderBy
    stddevSamp: CreditCardDetailStddevSampOrderBy
    sum: CreditCardDetailSumOrderBy
    varPop: CreditCardDetailVarPopOrderBy
    varSamp: CreditCardDetailVarSampOrderBy
    variance: CreditCardDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"credit_card_detail\""
input CreditCardDetailArrRelInsertInput {
    data: [CreditCardDetailInsertInput!]!
    "upsert condition"
    onConflict: CreditCardDetailOnConflict
}

"order by avg() on columns of table \"credit_card_detail\""
input CreditCardDetailAvgOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"credit_card_detail\". All fields are combined with a logical 'AND'."
input CreditCardDetailBoolExp {
    _and: [CreditCardDetailBoolExp!]
    _not: CreditCardDetailBoolExp
    _or: [CreditCardDetailBoolExp!]
    amount: NumericComparisonExp
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    credit_card_summary: CreditCardSummaryBoolExp
    date: DateComparisonExp
    genre: GenreBoolExp
    genreId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    memo: StringComparisonExp
    summaryId: UuidComparisonExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"credit_card_detail\""
input CreditCardDetailIncInput {
    amount: numeric
}

"input type for inserting data into table \"credit_card_detail\""
input CreditCardDetailInsertInput {
    amount: numeric
    category: CategoryObjRelInsertInput
    categoryId: uuid
    credit_card_summary: CreditCardSummaryObjRelInsertInput
    date: date
    genre: GenreObjRelInsertInput
    genreId: uuid
    groupId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    summaryId: uuid
    user: UserObjRelInsertInput
    userId: uuid
}

"order by max() on columns of table \"credit_card_detail\""
input CreditCardDetailMaxOrderBy {
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"credit_card_detail\""
input CreditCardDetailMinOrderBy {
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"credit_card_detail\""
input CreditCardDetailOnConflict {
    constraint: CreditCardDetailConstraint!
    updateColumns: [CreditCardDetailUpdateColumn!]! = []
    where: CreditCardDetailBoolExp
}

"Ordering options when selecting data from \"credit_card_detail\"."
input CreditCardDetailOrderBy {
    amount: OrderBy
    category: CategoryOrderBy
    categoryId: OrderBy
    credit_card_summary: CreditCardSummaryOrderBy
    date: OrderBy
    genre: GenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: credit_card_detail"
input CreditCardDetailPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"credit_card_detail\""
input CreditCardDetailSetInput {
    amount: numeric
    categoryId: uuid
    date: date
    genreId: uuid
    groupId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    summaryId: uuid
    userId: uuid
}

"order by stddev() on columns of table \"credit_card_detail\""
input CreditCardDetailStddevOrderBy {
    amount: OrderBy
}

"order by stddevPop() on columns of table \"credit_card_detail\""
input CreditCardDetailStddevPopOrderBy {
    amount: OrderBy
}

"order by stddevSamp() on columns of table \"credit_card_detail\""
input CreditCardDetailStddevSampOrderBy {
    amount: OrderBy
}

"Streaming cursor of the table \"credit_card_detail\""
input CreditCardDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CreditCardDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CreditCardDetailStreamCursorValueInput {
    amount: numeric
    categoryId: uuid
    date: date
    genreId: uuid
    groupId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    summaryId: uuid
    userId: uuid
}

"order by sum() on columns of table \"credit_card_detail\""
input CreditCardDetailSumOrderBy {
    amount: OrderBy
}

input CreditCardDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: CreditCardDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: CreditCardDetailSetInput
    "filter the rows which have to be updated"
    where: CreditCardDetailBoolExp!
}

"order by varPop() on columns of table \"credit_card_detail\""
input CreditCardDetailVarPopOrderBy {
    amount: OrderBy
}

"order by varSamp() on columns of table \"credit_card_detail\""
input CreditCardDetailVarSampOrderBy {
    amount: OrderBy
}

"order by variance() on columns of table \"credit_card_detail\""
input CreditCardDetailVarianceOrderBy {
    amount: OrderBy
}

"order by aggregate values of table \"credit_card_summary\""
input CreditCardSummaryAggregateOrderBy {
    avg: CreditCardSummaryAvgOrderBy
    count: OrderBy
    max: CreditCardSummaryMaxOrderBy
    min: CreditCardSummaryMinOrderBy
    stddev: CreditCardSummaryStddevOrderBy
    stddevPop: CreditCardSummaryStddevPopOrderBy
    stddevSamp: CreditCardSummaryStddevSampOrderBy
    sum: CreditCardSummarySumOrderBy
    varPop: CreditCardSummaryVarPopOrderBy
    varSamp: CreditCardSummaryVarSampOrderBy
    variance: CreditCardSummaryVarianceOrderBy
}

"input type for inserting array relation for remote table \"credit_card_summary\""
input CreditCardSummaryArrRelInsertInput {
    data: [CreditCardSummaryInsertInput!]!
    "upsert condition"
    onConflict: CreditCardSummaryOnConflict
}

"order by avg() on columns of table \"credit_card_summary\""
input CreditCardSummaryAvgOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Boolean expression to filter rows from the table \"credit_card_summary\". All fields are combined with a logical 'AND'."
input CreditCardSummaryBoolExp {
    _and: [CreditCardSummaryBoolExp!]
    _not: CreditCardSummaryBoolExp
    _or: [CreditCardSummaryBoolExp!]
    account: AccountBoolExp
    accountId: UuidComparisonExp
    count: IntComparisonExp
    creditCard: StringComparisonExp
    creditCardDetails: CreditCardDetailBoolExp
    credit_card_details: CreditCardDetailBoolExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    importFileHistory: ImportFileHistoryBoolExp
    import_file_history: ImportFileHistoryBoolExp
    totalAmount: NumericComparisonExp
    withdrawalDate: DateComparisonExp
}

"input type for inserting data into table \"credit_card_summary\""
input CreditCardSummaryInsertInput {
    account: AccountObjRelInsertInput
    accountId: uuid
    count: Int
    creditCard: String
    creditCardDetails: CreditCardDetailArrRelInsertInput
    credit_card_details: CreditCardDetailArrRelInsertInput
    groupId: uuid
    id: uuid
    importFileHistory: ImportFileHistoryObjRelInsertInput
    import_file_history: ImportFileHistoryObjRelInsertInput
    totalAmount: numeric
    withdrawalDate: date
}

"order by max() on columns of table \"credit_card_summary\""
input CreditCardSummaryMaxOrderBy {
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"order by min() on columns of table \"credit_card_summary\""
input CreditCardSummaryMinOrderBy {
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"input type for inserting object relation for remote table \"credit_card_summary\""
input CreditCardSummaryObjRelInsertInput {
    data: CreditCardSummaryInsertInput!
    "upsert condition"
    onConflict: CreditCardSummaryOnConflict
}

"on_conflict condition type for table \"credit_card_summary\""
input CreditCardSummaryOnConflict {
    constraint: CreditCardSummaryConstraint!
    updateColumns: [CreditCardSummaryUpdateColumn!]! = []
    where: CreditCardSummaryBoolExp
}

"Ordering options when selecting data from \"credit_card_summary\"."
input CreditCardSummaryOrderBy {
    account: AccountOrderBy
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    creditCardDetailsAggregate: CreditCardDetailAggregateOrderBy
    credit_card_detailsAggregate: CreditCardDetailAggregateOrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    importFileHistory: ImportFileHistoryOrderBy
    import_file_history: ImportFileHistoryOrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"order by stddev() on columns of table \"credit_card_summary\""
input CreditCardSummaryStddevOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by stddevPop() on columns of table \"credit_card_summary\""
input CreditCardSummaryStddevPopOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by stddevSamp() on columns of table \"credit_card_summary\""
input CreditCardSummaryStddevSampOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Streaming cursor of the table \"credit_card_summary\""
input CreditCardSummaryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CreditCardSummaryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CreditCardSummaryStreamCursorValueInput {
    accountId: uuid
    count: Int
    creditCard: String
    groupId: uuid
    id: uuid
    totalAmount: numeric
    withdrawalDate: date
}

"order by sum() on columns of table \"credit_card_summary\""
input CreditCardSummarySumOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Boolean expression to filter rows from the table \"credit_card_summary_total_by_account_view\". All fields are combined with a logical 'AND'."
input CreditCardSummaryTotalByAccountViewBoolExp {
    _and: [CreditCardSummaryTotalByAccountViewBoolExp!]
    _not: CreditCardSummaryTotalByAccountViewBoolExp
    _or: [CreditCardSummaryTotalByAccountViewBoolExp!]
    accountId: UuidComparisonExp
    accountName: StringComparisonExp
    date: DateComparisonExp
    displayOrder: IntComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"credit_card_summary_total_by_account_view\"."
input CreditCardSummaryTotalByAccountViewOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    date: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"credit_card_summary_total_by_account_view\""
input CreditCardSummaryTotalByAccountViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CreditCardSummaryTotalByAccountViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CreditCardSummaryTotalByAccountViewStreamCursorValueInput {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"order by varPop() on columns of table \"credit_card_summary\""
input CreditCardSummaryVarPopOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by varSamp() on columns of table \"credit_card_summary\""
input CreditCardSummaryVarSampOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by variance() on columns of table \"credit_card_summary\""
input CreditCardSummaryVarianceOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by aggregate values of table \"daily_detail\""
input DailyDetailAggregateOrderBy {
    avg: DailyDetailAvgOrderBy
    count: OrderBy
    max: DailyDetailMaxOrderBy
    min: DailyDetailMinOrderBy
    stddev: DailyDetailStddevOrderBy
    stddevPop: DailyDetailStddevPopOrderBy
    stddevSamp: DailyDetailStddevSampOrderBy
    sum: DailyDetailSumOrderBy
    varPop: DailyDetailVarPopOrderBy
    varSamp: DailyDetailVarSampOrderBy
    variance: DailyDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"daily_detail\""
input DailyDetailArrRelInsertInput {
    data: [DailyDetailInsertInput!]!
    "upsert condition"
    onConflict: DailyDetailOnConflict
}

"order by avg() on columns of table \"daily_detail\""
input DailyDetailAvgOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"daily_detail\". All fields are combined with a logical 'AND'."
input DailyDetailBoolExp {
    _and: [DailyDetailBoolExp!]
    _not: DailyDetailBoolExp
    _or: [DailyDetailBoolExp!]
    account: AccountBoolExp
    accountId: UuidComparisonExp
    amount: NumericComparisonExp
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    date: DateComparisonExp
    genre: GenreBoolExp
    genreId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    memo: StringComparisonExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"daily_detail\""
input DailyDetailIncInput {
    amount: numeric
}

"input type for inserting data into table \"daily_detail\""
input DailyDetailInsertInput {
    account: AccountObjRelInsertInput
    accountId: uuid
    amount: numeric
    category: CategoryObjRelInsertInput
    categoryId: uuid
    date: date
    genre: GenreObjRelInsertInput
    genreId: uuid
    groupId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    user: UserObjRelInsertInput
    userId: uuid
}

"order by max() on columns of table \"daily_detail\""
input DailyDetailMaxOrderBy {
    accountId: OrderBy
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"daily_detail\""
input DailyDetailMinOrderBy {
    accountId: OrderBy
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"daily_detail\""
input DailyDetailOnConflict {
    constraint: DailyDetailConstraint!
    updateColumns: [DailyDetailUpdateColumn!]! = []
    where: DailyDetailBoolExp
}

"Ordering options when selecting data from \"daily_detail\"."
input DailyDetailOrderBy {
    account: AccountOrderBy
    accountId: OrderBy
    amount: OrderBy
    category: CategoryOrderBy
    categoryId: OrderBy
    date: OrderBy
    genre: GenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: daily_detail"
input DailyDetailPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"daily_detail\""
input DailyDetailSetInput {
    accountId: uuid
    amount: numeric
    categoryId: uuid
    date: date
    genreId: uuid
    groupId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    userId: uuid
}

"order by stddev() on columns of table \"daily_detail\""
input DailyDetailStddevOrderBy {
    amount: OrderBy
}

"order by stddevPop() on columns of table \"daily_detail\""
input DailyDetailStddevPopOrderBy {
    amount: OrderBy
}

"order by stddevSamp() on columns of table \"daily_detail\""
input DailyDetailStddevSampOrderBy {
    amount: OrderBy
}

"Streaming cursor of the table \"daily_detail\""
input DailyDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: DailyDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input DailyDetailStreamCursorValueInput {
    accountId: uuid
    amount: numeric
    categoryId: uuid
    date: date
    genreId: uuid
    groupId: uuid
    id: uuid
    iocomeType: iocome_type
    memo: String
    userId: uuid
}

"order by sum() on columns of table \"daily_detail\""
input DailyDetailSumOrderBy {
    amount: OrderBy
}

input DailyDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: DailyDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: DailyDetailSetInput
    "filter the rows which have to be updated"
    where: DailyDetailBoolExp!
}

"order by varPop() on columns of table \"daily_detail\""
input DailyDetailVarPopOrderBy {
    amount: OrderBy
}

"order by varSamp() on columns of table \"daily_detail\""
input DailyDetailVarSampOrderBy {
    amount: OrderBy
}

"order by variance() on columns of table \"daily_detail\""
input DailyDetailVarianceOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"daily_total_view\". All fields are combined with a logical 'AND'."
input DailyTotalViewBoolExp {
    _and: [DailyTotalViewBoolExp!]
    _not: DailyTotalViewBoolExp
    _or: [DailyTotalViewBoolExp!]
    date: DateComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"daily_total_view\"."
input DailyTotalViewOrderBy {
    date: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"daily_total_view\""
input DailyTotalViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: DailyTotalViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input DailyTotalViewStreamCursorValueInput {
    date: date
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input DateComparisonExp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _isNull: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

"order by aggregate values of table \"deposit_category\""
input DepositCategoryAggregateOrderBy {
    count: OrderBy
    max: DepositCategoryMaxOrderBy
    min: DepositCategoryMinOrderBy
}

"Boolean expression to filter rows from the table \"deposit_category\". All fields are combined with a logical 'AND'."
input DepositCategoryBoolExp {
    _and: [DepositCategoryBoolExp!]
    _not: DepositCategoryBoolExp
    _or: [DepositCategoryBoolExp!]
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
}

"input type for inserting data into table \"deposit_category\""
input DepositCategoryInsertInput {
    category: CategoryObjRelInsertInput
    "カテゴリID"
    categoryId: uuid
    "グループID"
    groupId: uuid
}

"order by max() on columns of table \"deposit_category\""
input DepositCategoryMaxOrderBy {
    "カテゴリID"
    categoryId: OrderBy
    "グループID"
    groupId: OrderBy
}

"order by min() on columns of table \"deposit_category\""
input DepositCategoryMinOrderBy {
    "カテゴリID"
    categoryId: OrderBy
    "グループID"
    groupId: OrderBy
}

"input type for inserting object relation for remote table \"deposit_category\""
input DepositCategoryObjRelInsertInput {
    data: DepositCategoryInsertInput!
    "upsert condition"
    onConflict: DepositCategoryOnConflict
}

"on_conflict condition type for table \"deposit_category\""
input DepositCategoryOnConflict {
    constraint: DepositCategoryConstraint!
    updateColumns: [DepositCategoryUpdateColumn!]! = []
    where: DepositCategoryBoolExp
}

"Ordering options when selecting data from \"deposit_category\"."
input DepositCategoryOrderBy {
    category: CategoryOrderBy
    categoryId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
}

"Streaming cursor of the table \"deposit_category\""
input DepositCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: DepositCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input DepositCategoryStreamCursorValueInput {
    "カテゴリID"
    categoryId: uuid
    "グループID"
    groupId: uuid
}

"order by aggregate values of table \"genre\""
input GenreAggregateOrderBy {
    avg: GenreAvgOrderBy
    count: OrderBy
    max: GenreMaxOrderBy
    min: GenreMinOrderBy
    stddev: GenreStddevOrderBy
    stddevPop: GenreStddevPopOrderBy
    stddevSamp: GenreStddevSampOrderBy
    sum: GenreSumOrderBy
    varPop: GenreVarPopOrderBy
    varSamp: GenreVarSampOrderBy
    variance: GenreVarianceOrderBy
}

"order by avg() on columns of table \"genre\""
input GenreAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"genre\". All fields are combined with a logical 'AND'."
input GenreBoolExp {
    _and: [GenreBoolExp!]
    _not: GenreBoolExp
    _or: [GenreBoolExp!]
    categories: CategoryBoolExp
    creditCardDetails: CreditCardDetailBoolExp
    dailyDetails: DailyDetailBoolExp
    displayOrder: IntComparisonExp
    genreId: UuidComparisonExp
    genreName: StringComparisonExp
    genreType: GenreTypeComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"genre\""
input GenreIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"genre\""
input GenreInsertInput {
    categories: CategoryArrRelInsertInput
    creditCardDetails: CreditCardDetailArrRelInsertInput
    dailyDetails: DailyDetailArrRelInsertInput
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
    validFlag: Boolean
}

"order by max() on columns of table \"genre\""
input GenreMaxOrderBy {
    displayOrder: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    genreType: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
}

"order by min() on columns of table \"genre\""
input GenreMinOrderBy {
    displayOrder: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    genreType: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
}

"input type for inserting object relation for remote table \"genre\""
input GenreObjRelInsertInput {
    data: GenreInsertInput!
    "upsert condition"
    onConflict: GenreOnConflict
}

"on_conflict condition type for table \"genre\""
input GenreOnConflict {
    constraint: GenreConstraint!
    updateColumns: [GenreUpdateColumn!]! = []
    where: GenreBoolExp
}

"Ordering options when selecting data from \"genre\"."
input GenreOrderBy {
    categoriesAggregate: CategoryAggregateOrderBy
    creditCardDetailsAggregate: CreditCardDetailAggregateOrderBy
    dailyDetailsAggregate: DailyDetailAggregateOrderBy
    displayOrder: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    genreType: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    validFlag: OrderBy
}

"primary key columns input for table: genre"
input GenrePkColumnsInput {
    genreId: uuid!
}

"input type for updating data in table \"genre\""
input GenreSetInput {
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
    validFlag: Boolean
}

"order by stddev() on columns of table \"genre\""
input GenreStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"genre\""
input GenreStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"genre\""
input GenreStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"genre\""
input GenreStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GenreStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GenreStreamCursorValueInput {
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
    validFlag: Boolean
}

"order by sum() on columns of table \"genre\""
input GenreSumOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to compare columns of type \"genre_type\". All fields are combined with logical 'AND'."
input GenreTypeComparisonExp {
    _eq: genre_type
    _gt: genre_type
    _gte: genre_type
    _in: [genre_type!]
    _isNull: Boolean
    _lt: genre_type
    _lte: genre_type
    _neq: genre_type
    _nin: [genre_type!]
}

input GenreUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: GenreIncInput
    "sets the columns of the filtered rows to the given values"
    _set: GenreSetInput
    "filter the rows which have to be updated"
    where: GenreBoolExp!
}

"order by varPop() on columns of table \"genre\""
input GenreVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"genre\""
input GenreVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"genre\""
input GenreVarianceOrderBy {
    displayOrder: OrderBy
}

"order by aggregate values of table \"group_application\""
input GroupApplicationAggregateOrderBy {
    count: OrderBy
    max: GroupApplicationMaxOrderBy
    min: GroupApplicationMinOrderBy
}

"Boolean expression to filter rows from the table \"group_application\". All fields are combined with a logical 'AND'."
input GroupApplicationBoolExp {
    _and: [GroupApplicationBoolExp!]
    _not: GroupApplicationBoolExp
    _or: [GroupApplicationBoolExp!]
    application: ApplicationBoolExp
    applicationId: UuidComparisonExp
    group: GroupBoolExp
    groupApplicationId: UuidComparisonExp
    groupId: UuidComparisonExp
}

"order by max() on columns of table \"group_application\""
input GroupApplicationMaxOrderBy {
    applicationId: OrderBy
    groupApplicationId: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"group_application\""
input GroupApplicationMinOrderBy {
    applicationId: OrderBy
    groupApplicationId: OrderBy
    groupId: OrderBy
}

"Ordering options when selecting data from \"group_application\"."
input GroupApplicationOrderBy {
    application: ApplicationOrderBy
    applicationId: OrderBy
    group: GroupOrderBy
    groupApplicationId: OrderBy
    groupId: OrderBy
}

"Streaming cursor of the table \"group_application\""
input GroupApplicationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupApplicationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupApplicationStreamCursorValueInput {
    applicationId: uuid
    groupApplicationId: uuid
    groupId: uuid
}

"Boolean expression to filter rows from the table \"group\". All fields are combined with a logical 'AND'."
input GroupBoolExp {
    _and: [GroupBoolExp!]
    _not: GroupBoolExp
    _or: [GroupBoolExp!]
    accounts: AccountBoolExp
    accountsAggregate: AccountAggregateBoolExp
    affiliations: AffiliationBoolExp
    categories: CategoryBoolExp
    creditCardDetails: CreditCardDetailBoolExp
    credit_card_summaries: CreditCardSummaryBoolExp
    daily_details: DailyDetailBoolExp
    depositCategories: DepositCategoryBoolExp
    exchangeItems: HelperKidsExchangeItemBoolExp
    genres: GenreBoolExp
    groupId: UuidComparisonExp
    groupName: StringComparisonExp
    group_applications: GroupApplicationBoolExp
    helpItems: HelperKidsHelpItemBoolExp
    helpPointEarnedAchievements: HelperKidsHelpPointEarnedAchievementBoolExp
    helpPointEarnedAchievementsAggregate: HelperKidsHelpPointEarnedAchievementAggregateBoolExp
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailBoolExp
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementBoolExp
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateBoolExp
    helperKids: HelperKidsHelperKidBoolExp
    import_file_histories: ImportFileHistoryBoolExp
    summary_category_by_groups: SummaryCategoryByGroupBoolExp
    transferCategory: TransferCategoryBoolExp
}

"Ordering options when selecting data from \"group\"."
input GroupOrderBy {
    accountsAggregate: AccountAggregateOrderBy
    affiliationsAggregate: AffiliationAggregateOrderBy
    categoriesAggregate: CategoryAggregateOrderBy
    creditCardDetailsAggregate: CreditCardDetailAggregateOrderBy
    credit_card_summariesAggregate: CreditCardSummaryAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    depositCategoriesAggregate: DepositCategoryAggregateOrderBy
    exchangeItemsAggregate: HelperKidsExchangeItemAggregateOrderBy
    genresAggregate: GenreAggregateOrderBy
    groupId: OrderBy
    groupName: OrderBy
    group_applicationsAggregate: GroupApplicationAggregateOrderBy
    helpItemsAggregate: HelperKidsHelpItemAggregateOrderBy
    helpPointEarnedAchievementsAggregate: HelperKidsHelpPointEarnedAchievementAggregateOrderBy
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateOrderBy
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateOrderBy
    helperKidsAggregate: HelperKidsHelperKidAggregateOrderBy
    import_file_historiesAggregate: ImportFileHistoryAggregateOrderBy
    summary_category_by_groupsAggregate: SummaryCategoryByGroupAggregateOrderBy
    transferCategory: TransferCategoryOrderBy
}

"Boolean expression to filter rows from the table \"group_role\". All fields are combined with a logical 'AND'."
input GroupRoleBoolExp {
    _and: [GroupRoleBoolExp!]
    _not: GroupRoleBoolExp
    _or: [GroupRoleBoolExp!]
    affiliations: AffiliationBoolExp
    groupRoleId: UuidComparisonExp
    role: StringComparisonExp
}

"Ordering options when selecting data from \"group_role\"."
input GroupRoleOrderBy {
    affiliationsAggregate: AffiliationAggregateOrderBy
    groupRoleId: OrderBy
    role: OrderBy
}

"Streaming cursor of the table \"group_role\""
input GroupRoleStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupRoleStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupRoleStreamCursorValueInput {
    groupRoleId: uuid
    role: String
}

"Streaming cursor of the table \"group\""
input GroupStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupStreamCursorValueInput {
    groupId: uuid
    groupName: String
}

"order by aggregate values of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemAggregateOrderBy {
    avg: HelperKidsExchangeItemAvgOrderBy
    count: OrderBy
    max: HelperKidsExchangeItemMaxOrderBy
    min: HelperKidsExchangeItemMinOrderBy
    stddev: HelperKidsExchangeItemStddevOrderBy
    stddevPop: HelperKidsExchangeItemStddevPopOrderBy
    stddevSamp: HelperKidsExchangeItemStddevSampOrderBy
    sum: HelperKidsExchangeItemSumOrderBy
    varPop: HelperKidsExchangeItemVarPopOrderBy
    varSamp: HelperKidsExchangeItemVarSampOrderBy
    variance: HelperKidsExchangeItemVarianceOrderBy
}

"order by avg() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemAvgOrderBy {
    "交換ポイント"
    point: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.exchange_item\". All fields are combined with a logical 'AND'."
input HelperKidsExchangeItemBoolExp {
    _and: [HelperKidsExchangeItemBoolExp!]
    _not: HelperKidsExchangeItemBoolExp
    _or: [HelperKidsExchangeItemBoolExp!]
    exchangeItemId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementBoolExp
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateBoolExp
    memo: StringComparisonExp
    name: StringComparisonExp
    point: IntComparisonExp
}

"order by max() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemMaxOrderBy {
    "ID"
    exchangeItemId: OrderBy
    "グループID"
    groupId: OrderBy
    "メモ"
    memo: OrderBy
    "品名"
    name: OrderBy
    "交換ポイント"
    point: OrderBy
}

"order by min() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemMinOrderBy {
    "ID"
    exchangeItemId: OrderBy
    "グループID"
    groupId: OrderBy
    "メモ"
    memo: OrderBy
    "品名"
    name: OrderBy
    "交換ポイント"
    point: OrderBy
}

"Ordering options when selecting data from \"helper_kids.exchange_item\"."
input HelperKidsExchangeItemOrderBy {
    exchangeItemId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateOrderBy
    memo: OrderBy
    name: OrderBy
    point: OrderBy
}

"order by stddev() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemStddevOrderBy {
    "交換ポイント"
    point: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemStddevPopOrderBy {
    "交換ポイント"
    point: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemStddevSampOrderBy {
    "交換ポイント"
    point: OrderBy
}

"Streaming cursor of the table \"helper_kids_exchange_item\""
input HelperKidsExchangeItemStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsExchangeItemStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsExchangeItemStreamCursorValueInput {
    "ID"
    exchangeItemId: uuid
    "グループID"
    groupId: uuid
    "メモ"
    memo: String
    "品名"
    name: String
    "交換ポイント"
    point: Int
}

"order by sum() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemSumOrderBy {
    "交換ポイント"
    point: OrderBy
}

"order by varPop() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemVarPopOrderBy {
    "交換ポイント"
    point: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemVarSampOrderBy {
    "交換ポイント"
    point: OrderBy
}

"order by variance() on columns of table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemVarianceOrderBy {
    "交換ポイント"
    point: OrderBy
}

"order by aggregate values of table \"helper_kids.help_item\""
input HelperKidsHelpItemAggregateOrderBy {
    avg: HelperKidsHelpItemAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpItemMaxOrderBy
    min: HelperKidsHelpItemMinOrderBy
    stddev: HelperKidsHelpItemStddevOrderBy
    stddevPop: HelperKidsHelpItemStddevPopOrderBy
    stddevSamp: HelperKidsHelpItemStddevSampOrderBy
    sum: HelperKidsHelpItemSumOrderBy
    varPop: HelperKidsHelpItemVarPopOrderBy
    varSamp: HelperKidsHelpItemVarSampOrderBy
    variance: HelperKidsHelpItemVarianceOrderBy
}

"order by avg() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemAvgOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_item\". All fields are combined with a logical 'AND'."
input HelperKidsHelpItemBoolExp {
    _and: [HelperKidsHelpItemBoolExp!]
    _not: HelperKidsHelpItemBoolExp
    _or: [HelperKidsHelpItemBoolExp!]
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpItemId: UuidComparisonExp
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailBoolExp
    memo: StringComparisonExp
    name: StringComparisonExp
    point: IntComparisonExp
}

"order by max() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemMaxOrderBy {
    "グループID"
    groupId: OrderBy
    "ID"
    helpItemId: OrderBy
    "メモ"
    memo: OrderBy
    "項目名"
    name: OrderBy
    "お手伝いポイント"
    point: OrderBy
}

"order by min() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemMinOrderBy {
    "グループID"
    groupId: OrderBy
    "ID"
    helpItemId: OrderBy
    "メモ"
    memo: OrderBy
    "項目名"
    name: OrderBy
    "お手伝いポイント"
    point: OrderBy
}

"Ordering options when selecting data from \"helper_kids.help_item\"."
input HelperKidsHelpItemOrderBy {
    group: GroupOrderBy
    groupId: OrderBy
    helpItemId: OrderBy
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateOrderBy
    memo: OrderBy
    name: OrderBy
    point: OrderBy
}

"order by stddev() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemStddevOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemStddevPopOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemStddevSampOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_item\""
input HelperKidsHelpItemStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpItemStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpItemStreamCursorValueInput {
    "グループID"
    groupId: uuid
    "ID"
    helpItemId: uuid
    "メモ"
    memo: String
    "項目名"
    name: String
    "お手伝いポイント"
    point: Int
}

"order by sum() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemSumOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"order by varPop() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemVarPopOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemVarSampOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_item\""
input HelperKidsHelpItemVarianceOrderBy {
    "お手伝いポイント"
    point: OrderBy
}

input HelperKidsHelpPointEarnedAchievementAggregateBoolExp {
    count: helperKidsHelpPointEarnedAchievementAggregateBoolExpCount
}

"order by aggregate values of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementAggregateOrderBy {
    avg: HelperKidsHelpPointEarnedAchievementAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpPointEarnedAchievementMaxOrderBy
    min: HelperKidsHelpPointEarnedAchievementMinOrderBy
    stddev: HelperKidsHelpPointEarnedAchievementStddevOrderBy
    stddevPop: HelperKidsHelpPointEarnedAchievementStddevPopOrderBy
    stddevSamp: HelperKidsHelpPointEarnedAchievementStddevSampOrderBy
    sum: HelperKidsHelpPointEarnedAchievementSumOrderBy
    varPop: HelperKidsHelpPointEarnedAchievementVarPopOrderBy
    varSamp: HelperKidsHelpPointEarnedAchievementVarSampOrderBy
    variance: HelperKidsHelpPointEarnedAchievementVarianceOrderBy
}

"order by avg() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementAvgOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_point_earned_achievement\". All fields are combined with a logical 'AND'."
input HelperKidsHelpPointEarnedAchievementBoolExp {
    _and: [HelperKidsHelpPointEarnedAchievementBoolExp!]
    _not: HelperKidsHelpPointEarnedAchievementBoolExp
    _or: [HelperKidsHelpPointEarnedAchievementBoolExp!]
    earnedDatetime: TimestampComparisonExp
    earnedPoint: IntComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointEarnedAchievementId: UuidComparisonExp
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailBoolExp
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
}

"input type for inserting data into table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementInsertInput {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailArrRelInsertInput
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by max() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementMaxOrderBy {
    "獲得日時"
    earnedDatetime: OrderBy
    "獲得ポイント"
    earnedPoint: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointEarnedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"order by min() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementMinOrderBy {
    "獲得日時"
    earnedDatetime: OrderBy
    "獲得ポイント"
    earnedPoint: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointEarnedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"input type for inserting object relation for remote table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementObjRelInsertInput {
    data: HelperKidsHelpPointEarnedAchievementInsertInput!
    "upsert condition"
    onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
}

"on_conflict condition type for table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementOnConflict {
    constraint: HelperKidsHelpPointEarnedAchievementConstraint!
    updateColumns: [HelperKidsHelpPointEarnedAchievementUpdateColumn!]! = []
    where: HelperKidsHelpPointEarnedAchievementBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_point_earned_achievement\"."
input HelperKidsHelpPointEarnedAchievementOrderBy {
    earnedDatetime: OrderBy
    earnedPoint: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpPointEarnedAchievementId: OrderBy
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateOrderBy
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
}

"order by stddev() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStddevOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStddevPopOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStddevSampOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpPointEarnedAchievementStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpPointEarnedAchievementStreamCursorValueInput {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by sum() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementSumOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by varPop() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementVarPopOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementVarSampOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementVarianceOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by aggregate values of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailAggregateOrderBy {
    avg: HelperKidsHelpPointEarnedDetailAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpPointEarnedDetailMaxOrderBy
    min: HelperKidsHelpPointEarnedDetailMinOrderBy
    stddev: HelperKidsHelpPointEarnedDetailStddevOrderBy
    stddevPop: HelperKidsHelpPointEarnedDetailStddevPopOrderBy
    stddevSamp: HelperKidsHelpPointEarnedDetailStddevSampOrderBy
    sum: HelperKidsHelpPointEarnedDetailSumOrderBy
    varPop: HelperKidsHelpPointEarnedDetailVarPopOrderBy
    varSamp: HelperKidsHelpPointEarnedDetailVarSampOrderBy
    variance: HelperKidsHelpPointEarnedDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailArrRelInsertInput {
    data: [HelperKidsHelpPointEarnedDetailInsertInput!]!
    "upsert condition"
    onConflict: HelperKidsHelpPointEarnedDetailOnConflict
}

"order by avg() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailAvgOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_point_earned_detail\". All fields are combined with a logical 'AND'."
input HelperKidsHelpPointEarnedDetailBoolExp {
    _and: [HelperKidsHelpPointEarnedDetailBoolExp!]
    _not: HelperKidsHelpPointEarnedDetailBoolExp
    _or: [HelperKidsHelpPointEarnedDetailBoolExp!]
    earnedAchievementId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpItem: HelperKidsHelpItemBoolExp
    helpItemCount: IntComparisonExp
    helpItemId: UuidComparisonExp
    helpItemTotalPoint: IntComparisonExp
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievementBoolExp
    helpPointEarnedDetailId: UuidComparisonExp
}

"input type for inserting data into table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailInsertInput {
    "獲得実績ID"
    earnedAchievementId: uuid
    "グループID"
    groupId: uuid
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievementObjRelInsertInput
    "ID"
    helpPointEarnedDetailId: uuid
}

"order by max() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailMaxOrderBy {
    "獲得実績ID"
    earnedAchievementId: OrderBy
    "グループID"
    groupId: OrderBy
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目ID"
    helpItemId: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
    "ID"
    helpPointEarnedDetailId: OrderBy
}

"order by min() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailMinOrderBy {
    "獲得実績ID"
    earnedAchievementId: OrderBy
    "グループID"
    groupId: OrderBy
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目ID"
    helpItemId: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
    "ID"
    helpPointEarnedDetailId: OrderBy
}

"on_conflict condition type for table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailOnConflict {
    constraint: HelperKidsHelpPointEarnedDetailConstraint!
    updateColumns: [HelperKidsHelpPointEarnedDetailUpdateColumn!]! = []
    where: HelperKidsHelpPointEarnedDetailBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_point_earned_detail\"."
input HelperKidsHelpPointEarnedDetailOrderBy {
    earnedAchievementId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpItem: HelperKidsHelpItemOrderBy
    helpItemCount: OrderBy
    helpItemId: OrderBy
    helpItemTotalPoint: OrderBy
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievementOrderBy
    helpPointEarnedDetailId: OrderBy
}

"order by stddev() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStddevOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStddevPopOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStddevSampOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpPointEarnedDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpPointEarnedDetailStreamCursorValueInput {
    "獲得実績ID"
    earnedAchievementId: uuid
    "グループID"
    groupId: uuid
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    "ID"
    helpPointEarnedDetailId: uuid
}

"order by sum() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailSumOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by varPop() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailVarPopOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailVarSampOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailVarianceOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

input HelperKidsHelpPointExchangedAchievementAggregateBoolExp {
    count: helperKidsHelpPointExchangedAchievementAggregateBoolExpCount
}

"order by aggregate values of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementAggregateOrderBy {
    avg: HelperKidsHelpPointExchangedAchievementAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpPointExchangedAchievementMaxOrderBy
    min: HelperKidsHelpPointExchangedAchievementMinOrderBy
    stddev: HelperKidsHelpPointExchangedAchievementStddevOrderBy
    stddevPop: HelperKidsHelpPointExchangedAchievementStddevPopOrderBy
    stddevSamp: HelperKidsHelpPointExchangedAchievementStddevSampOrderBy
    sum: HelperKidsHelpPointExchangedAchievementSumOrderBy
    varPop: HelperKidsHelpPointExchangedAchievementVarPopOrderBy
    varSamp: HelperKidsHelpPointExchangedAchievementVarSampOrderBy
    variance: HelperKidsHelpPointExchangedAchievementVarianceOrderBy
}

"order by avg() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementAvgOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_point_exchanged_achievement\". All fields are combined with a logical 'AND'."
input HelperKidsHelpPointExchangedAchievementBoolExp {
    _and: [HelperKidsHelpPointExchangedAchievementBoolExp!]
    _not: HelperKidsHelpPointExchangedAchievementBoolExp
    _or: [HelperKidsHelpPointExchangedAchievementBoolExp!]
    exchangeCount: IntComparisonExp
    exchangeItem: HelperKidsExchangeItemBoolExp
    exchangeItemId: UuidComparisonExp
    exchangeTotalPoint: IntComparisonExp
    exchangedDatetime: TimestampComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointExchangedAchievementId: UuidComparisonExp
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
}

"input type for inserting data into table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementInsertInput {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by max() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementMaxOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換品ID"
    exchangeItemId: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
    "交換日時"
    exchangedDatetime: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointExchangedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"order by min() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementMinOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換品ID"
    exchangeItemId: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
    "交換日時"
    exchangedDatetime: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointExchangedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"on_conflict condition type for table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementOnConflict {
    constraint: HelperKidsHelpPointExchangedAchievementConstraint!
    updateColumns: [HelperKidsHelpPointExchangedAchievementUpdateColumn!]! = []
    where: HelperKidsHelpPointExchangedAchievementBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_point_exchanged_achievement\"."
input HelperKidsHelpPointExchangedAchievementOrderBy {
    exchangeCount: OrderBy
    exchangeItem: HelperKidsExchangeItemOrderBy
    exchangeItemId: OrderBy
    exchangeTotalPoint: OrderBy
    exchangedDatetime: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpPointExchangedAchievementId: OrderBy
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
}

"order by stddev() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStddevOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStddevPopOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStddevSampOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpPointExchangedAchievementStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpPointExchangedAchievementStreamCursorValueInput {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by sum() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementSumOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by varPop() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementVarPopOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementVarSampOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementVarianceOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by aggregate values of table \"helper_kids.helper_kid\""
input HelperKidsHelperKidAggregateOrderBy {
    count: OrderBy
    max: HelperKidsHelperKidMaxOrderBy
    min: HelperKidsHelperKidMinOrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.helper_kid\". All fields are combined with a logical 'AND'."
input HelperKidsHelperKidBoolExp {
    _and: [HelperKidsHelperKidBoolExp!]
    _not: HelperKidsHelperKidBoolExp
    _or: [HelperKidsHelperKidBoolExp!]
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointEarnedAchievements: HelperKidsHelpPointEarnedAchievementBoolExp
    helpPointEarnedAchievementsAggregate: HelperKidsHelpPointEarnedAchievementAggregateBoolExp
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementBoolExp
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateBoolExp
    helperKidId: UuidComparisonExp
    helperKidParents: HelperKidsHelperKidParentBoolExp
    helperKidPoint: HelperKidsHelperKidPointBoolExp
    name: StringComparisonExp
    nameSuffix: StringComparisonExp
}

"order by max() on columns of table \"helper_kids.helper_kid\""
input HelperKidsHelperKidMaxOrderBy {
    "グループID"
    groupId: OrderBy
    "ID"
    helperKidId: OrderBy
    "氏名"
    name: OrderBy
    "名前 接尾辞"
    nameSuffix: OrderBy
}

"order by min() on columns of table \"helper_kids.helper_kid\""
input HelperKidsHelperKidMinOrderBy {
    "グループID"
    groupId: OrderBy
    "ID"
    helperKidId: OrderBy
    "氏名"
    name: OrderBy
    "名前 接尾辞"
    nameSuffix: OrderBy
}

"Ordering options when selecting data from \"helper_kids.helper_kid\"."
input HelperKidsHelperKidOrderBy {
    group: GroupOrderBy
    groupId: OrderBy
    helpPointEarnedAchievementsAggregate: HelperKidsHelpPointEarnedAchievementAggregateOrderBy
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateOrderBy
    helperKidId: OrderBy
    helperKidParentsAggregate: HelperKidsHelperKidParentAggregateOrderBy
    helperKidPoint: HelperKidsHelperKidPointOrderBy
    name: OrderBy
    nameSuffix: OrderBy
}

"order by aggregate values of table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentAggregateOrderBy {
    count: OrderBy
    max: HelperKidsHelperKidParentMaxOrderBy
    min: HelperKidsHelperKidParentMinOrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.helper_kid_parent\". All fields are combined with a logical 'AND'."
input HelperKidsHelperKidParentBoolExp {
    _and: [HelperKidsHelperKidParentBoolExp!]
    _not: HelperKidsHelperKidParentBoolExp
    _or: [HelperKidsHelperKidParentBoolExp!]
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
    helperKidParentId: UuidComparisonExp
    parentUserId: UuidComparisonExp
    user: UserBoolExp
}

"order by max() on columns of table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentMaxOrderBy {
    helperKidId: OrderBy
    helperKidParentId: OrderBy
    parentUserId: OrderBy
}

"order by min() on columns of table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentMinOrderBy {
    helperKidId: OrderBy
    helperKidParentId: OrderBy
    parentUserId: OrderBy
}

"Ordering options when selecting data from \"helper_kids.helper_kid_parent\"."
input HelperKidsHelperKidParentOrderBy {
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
    helperKidParentId: OrderBy
    parentUserId: OrderBy
    user: UserOrderBy
}

"Streaming cursor of the table \"helper_kids_helper_kid_parent\""
input HelperKidsHelperKidParentStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelperKidParentStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelperKidParentStreamCursorValueInput {
    helperKidId: uuid
    helperKidParentId: uuid
    parentUserId: uuid
}

"Boolean expression to filter rows from the table \"helper_kids.helper_kid_point\". All fields are combined with a logical 'AND'."
input HelperKidsHelperKidPointBoolExp {
    _and: [HelperKidsHelperKidPointBoolExp!]
    _not: HelperKidsHelperKidPointBoolExp
    _or: [HelperKidsHelperKidPointBoolExp!]
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
    lastHelpDatetime: TimestampComparisonExp
    point: IntComparisonExp
}

"Ordering options when selecting data from \"helper_kids.helper_kid_point\"."
input HelperKidsHelperKidPointOrderBy {
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
    lastHelpDatetime: OrderBy
    point: OrderBy
}

"Streaming cursor of the table \"helper_kids_helper_kid_point\""
input HelperKidsHelperKidPointStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelperKidPointStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelperKidPointStreamCursorValueInput {
    "お手伝いキッズID"
    helperKidId: uuid
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp
    "ポイント"
    point: Int
}

"Streaming cursor of the table \"helper_kids_helper_kid\""
input HelperKidsHelperKidStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelperKidStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelperKidStreamCursorValueInput {
    "グループID"
    groupId: uuid
    "ID"
    helperKidId: uuid
    "氏名"
    name: String
    "名前 接尾辞"
    nameSuffix: String
}

"order by aggregate values of table \"import_file_history\""
input ImportFileHistoryAggregateOrderBy {
    count: OrderBy
    max: ImportFileHistoryMaxOrderBy
    min: ImportFileHistoryMinOrderBy
}

"input type for inserting array relation for remote table \"import_file_history\""
input ImportFileHistoryArrRelInsertInput {
    data: [ImportFileHistoryInsertInput!]!
    "upsert condition"
    onConflict: ImportFileHistoryOnConflict
}

"Boolean expression to filter rows from the table \"import_file_history\". All fields are combined with a logical 'AND'."
input ImportFileHistoryBoolExp {
    _and: [ImportFileHistoryBoolExp!]
    _not: ImportFileHistoryBoolExp
    _or: [ImportFileHistoryBoolExp!]
    credit_card_summary: CreditCardSummaryBoolExp
    fileName: StringComparisonExp
    fileType: StringComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    importDatetime: TimestampComparisonExp
    importUserId: UuidComparisonExp
    user: UserBoolExp
}

"input type for inserting data into table \"import_file_history\""
input ImportFileHistoryInsertInput {
    credit_card_summary: CreditCardSummaryObjRelInsertInput
    fileName: String
    fileType: String
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
    user: UserObjRelInsertInput
}

"order by max() on columns of table \"import_file_history\""
input ImportFileHistoryMaxOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"order by min() on columns of table \"import_file_history\""
input ImportFileHistoryMinOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"input type for inserting object relation for remote table \"import_file_history\""
input ImportFileHistoryObjRelInsertInput {
    data: ImportFileHistoryInsertInput!
    "upsert condition"
    onConflict: ImportFileHistoryOnConflict
}

"on_conflict condition type for table \"import_file_history\""
input ImportFileHistoryOnConflict {
    constraint: ImportFileHistoryConstraint!
    updateColumns: [ImportFileHistoryUpdateColumn!]! = []
    where: ImportFileHistoryBoolExp
}

"Ordering options when selecting data from \"import_file_history\"."
input ImportFileHistoryOrderBy {
    credit_card_summary: CreditCardSummaryOrderBy
    fileName: OrderBy
    fileType: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
    user: UserOrderBy
}

"Streaming cursor of the table \"import_file_history\""
input ImportFileHistoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: ImportFileHistoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input ImportFileHistoryStreamCursorValueInput {
    fileName: String
    fileType: String
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input IntComparisonExp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _isNull: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"iocome_type\". All fields are combined with logical 'AND'."
input IocomeTypeComparisonExp {
    _eq: iocome_type
    _gt: iocome_type
    _gte: iocome_type
    _in: [iocome_type!]
    _isNull: Boolean
    _lt: iocome_type
    _lte: iocome_type
    _neq: iocome_type
    _nin: [iocome_type!]
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input NumericComparisonExp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _isNull: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input StringComparisonExp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _isNull: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"order by aggregate values of table \"summary_category_by_group\""
input SummaryCategoryByGroupAggregateOrderBy {
    avg: SummaryCategoryByGroupAvgOrderBy
    count: OrderBy
    max: SummaryCategoryByGroupMaxOrderBy
    min: SummaryCategoryByGroupMinOrderBy
    stddev: SummaryCategoryByGroupStddevOrderBy
    stddevPop: SummaryCategoryByGroupStddevPopOrderBy
    stddevSamp: SummaryCategoryByGroupStddevSampOrderBy
    sum: SummaryCategoryByGroupSumOrderBy
    varPop: SummaryCategoryByGroupVarPopOrderBy
    varSamp: SummaryCategoryByGroupVarSampOrderBy
    variance: SummaryCategoryByGroupVarianceOrderBy
}

"input type for inserting array relation for remote table \"summary_category_by_group\""
input SummaryCategoryByGroupArrRelInsertInput {
    data: [SummaryCategoryByGroupInsertInput!]!
    "upsert condition"
    onConflict: SummaryCategoryByGroupOnConflict
}

"order by avg() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"summary_category_by_group\". All fields are combined with a logical 'AND'."
input SummaryCategoryByGroupBoolExp {
    _and: [SummaryCategoryByGroupBoolExp!]
    _not: SummaryCategoryByGroupBoolExp
    _or: [SummaryCategoryByGroupBoolExp!]
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    displayOrder: IntComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
}

"input type for inserting data into table \"summary_category_by_group\""
input SummaryCategoryByGroupInsertInput {
    category: CategoryObjRelInsertInput
    categoryId: uuid
    displayOrder: Int
    groupId: uuid
    id: uuid
}

"order by max() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupMaxOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"order by min() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupMinOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"on_conflict condition type for table \"summary_category_by_group\""
input SummaryCategoryByGroupOnConflict {
    constraint: SummaryCategoryByGroupConstraint!
    updateColumns: [SummaryCategoryByGroupUpdateColumn!]! = []
    where: SummaryCategoryByGroupBoolExp
}

"Ordering options when selecting data from \"summary_category_by_group\"."
input SummaryCategoryByGroupOrderBy {
    category: CategoryOrderBy
    categoryId: OrderBy
    displayOrder: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
}

"order by stddev() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"summary_category_by_group\""
input SummaryCategoryByGroupStreamCursorInput {
    "Stream column input with initial value"
    initialValue: SummaryCategoryByGroupStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input SummaryCategoryByGroupStreamCursorValueInput {
    categoryId: uuid
    displayOrder: Int
    groupId: uuid
    id: uuid
}

"order by sum() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupSumOrderBy {
    displayOrder: OrderBy
}

"order by varPop() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupVarianceOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input TimestampComparisonExp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _isNull: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to filter rows from the table \"total_by_category_view\". All fields are combined with a logical 'AND'."
input TotalByCategoryViewBoolExp {
    _and: [TotalByCategoryViewBoolExp!]
    _not: TotalByCategoryViewBoolExp
    _or: [TotalByCategoryViewBoolExp!]
    categoryId: UuidComparisonExp
    categoryName: StringComparisonExp
    date: DateComparisonExp
    genreId: UuidComparisonExp
    genreName: StringComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"total_by_category_view\"."
input TotalByCategoryViewOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    date: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"total_by_category_view\""
input TotalByCategoryViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TotalByCategoryViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TotalByCategoryViewStreamCursorValueInput {
    categoryId: uuid
    categoryName: String
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"Boolean expression to filter rows from the table \"total_by_genre_view\". All fields are combined with a logical 'AND'."
input TotalByGenreViewBoolExp {
    _and: [TotalByGenreViewBoolExp!]
    _not: TotalByGenreViewBoolExp
    _or: [TotalByGenreViewBoolExp!]
    date: DateComparisonExp
    genreId: UuidComparisonExp
    genreName: StringComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"total_by_genre_view\"."
input TotalByGenreViewOrderBy {
    date: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"total_by_genre_view\""
input TotalByGenreViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TotalByGenreViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TotalByGenreViewStreamCursorValueInput {
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"order by aggregate values of table \"transfer_category\""
input TransferCategoryAggregateOrderBy {
    count: OrderBy
    max: TransferCategoryMaxOrderBy
    min: TransferCategoryMinOrderBy
}

"input type for inserting array relation for remote table \"transfer_category\""
input TransferCategoryArrRelInsertInput {
    data: [TransferCategoryInsertInput!]!
    "upsert condition"
    onConflict: TransferCategoryOnConflict
}

"Boolean expression to filter rows from the table \"transfer_category\". All fields are combined with a logical 'AND'."
input TransferCategoryBoolExp {
    _and: [TransferCategoryBoolExp!]
    _not: TransferCategoryBoolExp
    _or: [TransferCategoryBoolExp!]
    category: CategoryBoolExp
    categoryByOutcomeCategoryId: CategoryBoolExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    incomeCategoryId: UuidComparisonExp
    outcomeCategoryId: UuidComparisonExp
}

"input type for inserting data into table \"transfer_category\""
input TransferCategoryInsertInput {
    category: CategoryObjRelInsertInput
    categoryByOutcomeCategoryId: CategoryObjRelInsertInput
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

"order by max() on columns of table \"transfer_category\""
input TransferCategoryMaxOrderBy {
    "グループID"
    groupId: OrderBy
    "収入カテゴリID"
    incomeCategoryId: OrderBy
    "支出カテゴリID"
    outcomeCategoryId: OrderBy
}

"order by min() on columns of table \"transfer_category\""
input TransferCategoryMinOrderBy {
    "グループID"
    groupId: OrderBy
    "収入カテゴリID"
    incomeCategoryId: OrderBy
    "支出カテゴリID"
    outcomeCategoryId: OrderBy
}

"on_conflict condition type for table \"transfer_category\""
input TransferCategoryOnConflict {
    constraint: TransferCategoryConstraint!
    updateColumns: [TransferCategoryUpdateColumn!]! = []
    where: TransferCategoryBoolExp
}

"Ordering options when selecting data from \"transfer_category\"."
input TransferCategoryOrderBy {
    category: CategoryOrderBy
    categoryByOutcomeCategoryId: CategoryOrderBy
    group: GroupOrderBy
    groupId: OrderBy
    incomeCategoryId: OrderBy
    outcomeCategoryId: OrderBy
}

"Streaming cursor of the table \"transfer_category\""
input TransferCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TransferCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TransferCategoryStreamCursorValueInput {
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

"Boolean expression to filter rows from the table \"user\". All fields are combined with a logical 'AND'."
input UserBoolExp {
    _and: [UserBoolExp!]
    _not: UserBoolExp
    _or: [UserBoolExp!]
    affiliations: AffiliationBoolExp
    credit_card_details: CreditCardDetailBoolExp
    daily_details: DailyDetailBoolExp
    displayOrder: IntComparisonExp
    email: StringComparisonExp
    helperKidParents: HelperKidsHelperKidParentBoolExp
    import_file_histories: ImportFileHistoryBoolExp
    userId: UuidComparisonExp
    userName: StringComparisonExp
}

"input type for inserting data into table \"user\""
input UserInsertInput {
    credit_card_details: CreditCardDetailArrRelInsertInput
    daily_details: DailyDetailArrRelInsertInput
    displayOrder: Int
    email: String
    import_file_histories: ImportFileHistoryArrRelInsertInput
    userId: uuid
    userName: String
}

"input type for inserting object relation for remote table \"user\""
input UserObjRelInsertInput {
    data: UserInsertInput!
    "upsert condition"
    onConflict: UserOnConflict
}

"on_conflict condition type for table \"user\""
input UserOnConflict {
    constraint: UserConstraint!
    updateColumns: [UserUpdateColumn!]! = []
    where: UserBoolExp
}

"Ordering options when selecting data from \"user\"."
input UserOrderBy {
    affiliationsAggregate: AffiliationAggregateOrderBy
    credit_card_detailsAggregate: CreditCardDetailAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    displayOrder: OrderBy
    email: OrderBy
    helperKidParentsAggregate: HelperKidsHelperKidParentAggregateOrderBy
    import_file_historiesAggregate: ImportFileHistoryAggregateOrderBy
    userId: OrderBy
    userName: OrderBy
}

"Streaming cursor of the table \"user\""
input UserStreamCursorInput {
    "Stream column input with initial value"
    initialValue: UserStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input UserStreamCursorValueInput {
    displayOrder: Int
    email: String
    userId: uuid
    userName: String
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input UuidComparisonExp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _isNull: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}

input accountAggregateBoolExpBool_and {
    arguments: AccountSelectColumnAccountAggregateBoolExpBool_andArgumentsColumns!
    distinct: Boolean
    filter: AccountBoolExp
    predicate: BooleanComparisonExp!
}

input accountAggregateBoolExpBool_or {
    arguments: AccountSelectColumnAccountAggregateBoolExpBool_orArgumentsColumns!
    distinct: Boolean
    filter: AccountBoolExp
    predicate: BooleanComparisonExp!
}

input accountAggregateBoolExpCount {
    arguments: [AccountSelectColumn!]
    distinct: Boolean
    filter: AccountBoolExp
    predicate: IntComparisonExp!
}

input allDetailViewAggregateBoolExpCount {
    arguments: [AllDetailViewSelectColumn!]
    distinct: Boolean
    filter: AllDetailViewBoolExp
    predicate: IntComparisonExp!
}

input categoryTotalByMonthArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input dailyDetailByDateArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input genreTotalByMonthArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input helperKidsHelpPointEarnedAchievementAggregateBoolExpCount {
    arguments: [HelperKidsHelpPointEarnedAchievementSelectColumn!]
    distinct: Boolean
    filter: HelperKidsHelpPointEarnedAchievementBoolExp
    predicate: IntComparisonExp!
}

input helperKidsHelpPointExchangedAchievementAggregateBoolExpCount {
    arguments: [HelperKidsHelpPointExchangedAchievementSelectColumn!]
    distinct: Boolean
    filter: HelperKidsHelpPointExchangedAchievementBoolExp
    predicate: IntComparisonExp!
}
