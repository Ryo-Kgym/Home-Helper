# This file was generated. Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"account\""
type Account {
    accountId: uuid!
    accountName: String!
    "An aggregate relationship"
    creditCardSummariesAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): CreditCardSummaryAggregate!
    "An array relationship"
    credit_card_summaries(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    displayOrder: Int!
    "An object relationship"
    group: Group!
    groupId: uuid!
    validFlag: Boolean
}

"aggregated selection of \"account\""
type AccountAggregate {
    aggregate: AccountAggregateFields
    nodes: [Account!]!
}

"aggregate fields of \"account\""
type AccountAggregateFields {
    avg: AccountAvgFields
    count(columns: [AccountSelectColumn!], distinct: Boolean): Int!
    max: AccountMaxFields
    min: AccountMinFields
    stddev: AccountStddevFields
    stddevPop: AccountStddevPopFields
    stddevSamp: AccountStddevSampFields
    sum: AccountSumFields
    varPop: AccountVarPopFields
    varSamp: AccountVarSampFields
    variance: AccountVarianceFields
}

"aggregate avg on columns"
type AccountAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type AccountMaxFields {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
}

"aggregate min on columns"
type AccountMinFields {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
}

"response of any mutation on the table \"account\""
type AccountMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Account!]!
}

"aggregate stddev on columns"
type AccountStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type AccountStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type AccountStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type AccountSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type AccountVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type AccountVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type AccountVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"affiliation\""
type Affiliation {
    affiliationId: uuid!
    "An object relationship"
    group: Group!
    groupId: uuid!
    groupRoleId: uuid!
    "An object relationship"
    group_role: GroupRole!
    "An object relationship"
    user: User!
    userId: uuid!
}

"aggregated selection of \"affiliation\""
type AffiliationAggregate {
    aggregate: AffiliationAggregateFields
    nodes: [Affiliation!]!
}

"aggregate fields of \"affiliation\""
type AffiliationAggregateFields {
    count(columns: [AffiliationSelectColumn!], distinct: Boolean): Int!
    max: AffiliationMaxFields
    min: AffiliationMinFields
}

"aggregate max on columns"
type AffiliationMaxFields {
    affiliationId: uuid
    groupId: uuid
    groupRoleId: uuid
    userId: uuid
}

"aggregate min on columns"
type AffiliationMinFields {
    affiliationId: uuid
    groupId: uuid
    groupRoleId: uuid
    userId: uuid
}

"response of any mutation on the table \"affiliation\""
type AffiliationMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Affiliation!]!
}

"columns and relationships of \"application\""
type Application {
    application: String!
    applicationId: uuid!
    "An aggregate relationship"
    groupApplicationsAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    "An array relationship"
    group_applications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    topUrl: String!
    validFlag: Boolean
}

"aggregated selection of \"application\""
type ApplicationAggregate {
    aggregate: ApplicationAggregateFields
    nodes: [Application!]!
}

"aggregate fields of \"application\""
type ApplicationAggregateFields {
    count(columns: [ApplicationSelectColumn!], distinct: Boolean): Int!
    max: ApplicationMaxFields
    min: ApplicationMinFields
}

"aggregate max on columns"
type ApplicationMaxFields {
    application: String
    applicationId: uuid
    topUrl: String
}

"aggregate min on columns"
type ApplicationMinFields {
    application: String
    applicationId: uuid
    topUrl: String
}

"response of any mutation on the table \"application\""
type ApplicationMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Application!]!
}

"columns and relationships of \"category\""
type Category {
    categoryId: uuid!
    categoryName: String!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): CreditCardDetailAggregate!
    "An array relationship"
    credit_card_details(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    displayOrder: Int!
    "An object relationship"
    genre: Genre!
    genreId: uuid!
    "An object relationship"
    group: Group!
    groupId: uuid!
    "An aggregate relationship"
    incomeTransferCategoryAggregate(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): TransferCategoryAggregate!
    "An array relationship"
    income_transfer_category(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "An aggregate relationship"
    outcomeTransferCategoryAggregate(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): TransferCategoryAggregate!
    "An array relationship"
    outcome_transfer_category(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "An aggregate relationship"
    summaryCategoryByGroupsAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): SummaryCategoryByGroupAggregate!
    "An aggregate relationship"
    summaryCategoryByUsersAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): SummaryCategoryByUserAggregate!
    "An array relationship"
    summary_category_by_groups(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "An array relationship"
    summary_category_by_users(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): [SummaryCategoryByUser!]!
    validFlag: Boolean
}

"aggregated selection of \"category\""
type CategoryAggregate {
    aggregate: CategoryAggregateFields
    nodes: [Category!]!
}

"aggregate fields of \"category\""
type CategoryAggregateFields {
    avg: CategoryAvgFields
    count(columns: [CategorySelectColumn!], distinct: Boolean): Int!
    max: CategoryMaxFields
    min: CategoryMinFields
    stddev: CategoryStddevFields
    stddevPop: CategoryStddevPopFields
    stddevSamp: CategoryStddevSampFields
    sum: CategorySumFields
    varPop: CategoryVarPopFields
    varSamp: CategoryVarSampFields
    variance: CategoryVarianceFields
}

"aggregate avg on columns"
type CategoryAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type CategoryMaxFields {
    categoryId: uuid
    categoryName: String
    displayOrder: Int
    genreId: uuid
    groupId: uuid
}

"aggregate min on columns"
type CategoryMinFields {
    categoryId: uuid
    categoryName: String
    displayOrder: Int
    genreId: uuid
    groupId: uuid
}

"response of any mutation on the table \"category\""
type CategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Category!]!
}

"aggregate stddev on columns"
type CategoryStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type CategoryStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type CategoryStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type CategorySumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type CategoryVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type CategoryVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type CategoryVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"credit_card_detail\""
type CreditCardDetail {
    amount: numeric!
    "An object relationship"
    category: Category!
    categoryId: uuid!
    "An object relationship"
    credit_card_summary: CreditCardSummary!
    date: date!
    groupId: uuid!
    id: uuid!
    memo: String
    summaryId: uuid!
    "An object relationship"
    user: User!
    userId: uuid!
}

"aggregated selection of \"credit_card_detail\""
type CreditCardDetailAggregate {
    aggregate: CreditCardDetailAggregateFields
    nodes: [CreditCardDetail!]!
}

"aggregate fields of \"credit_card_detail\""
type CreditCardDetailAggregateFields {
    avg: CreditCardDetailAvgFields
    count(columns: [CreditCardDetailSelectColumn!], distinct: Boolean): Int!
    max: CreditCardDetailMaxFields
    min: CreditCardDetailMinFields
    stddev: CreditCardDetailStddevFields
    stddevPop: CreditCardDetailStddevPopFields
    stddevSamp: CreditCardDetailStddevSampFields
    sum: CreditCardDetailSumFields
    varPop: CreditCardDetailVarPopFields
    varSamp: CreditCardDetailVarSampFields
    variance: CreditCardDetailVarianceFields
}

"aggregate avg on columns"
type CreditCardDetailAvgFields {
    amount: Float
}

"aggregate max on columns"
type CreditCardDetailMaxFields {
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    summaryId: uuid
    userId: uuid
}

"aggregate min on columns"
type CreditCardDetailMinFields {
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    summaryId: uuid
    userId: uuid
}

"response of any mutation on the table \"credit_card_detail\""
type CreditCardDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [CreditCardDetail!]!
}

"aggregate stddev on columns"
type CreditCardDetailStddevFields {
    amount: Float
}

"aggregate stddevPop on columns"
type CreditCardDetailStddevPopFields {
    amount: Float
}

"aggregate stddevSamp on columns"
type CreditCardDetailStddevSampFields {
    amount: Float
}

"aggregate sum on columns"
type CreditCardDetailSumFields {
    amount: numeric
}

"aggregate varPop on columns"
type CreditCardDetailVarPopFields {
    amount: Float
}

"aggregate varSamp on columns"
type CreditCardDetailVarSampFields {
    amount: Float
}

"aggregate variance on columns"
type CreditCardDetailVarianceFields {
    amount: Float
}

"columns and relationships of \"credit_card_summary\""
type CreditCardSummary {
    "An object relationship"
    account: Account!
    accountId: uuid!
    count: Int!
    creditCard: String!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): CreditCardDetailAggregate!
    "An array relationship"
    credit_card_details(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    "An object relationship"
    import_file_history: ImportFileHistory!
    totalAmount: numeric!
    withdrawalDate: date!
}

"aggregated selection of \"credit_card_summary\""
type CreditCardSummaryAggregate {
    aggregate: CreditCardSummaryAggregateFields
    nodes: [CreditCardSummary!]!
}

"aggregate fields of \"credit_card_summary\""
type CreditCardSummaryAggregateFields {
    avg: CreditCardSummaryAvgFields
    count(columns: [CreditCardSummarySelectColumn!], distinct: Boolean): Int!
    max: CreditCardSummaryMaxFields
    min: CreditCardSummaryMinFields
    stddev: CreditCardSummaryStddevFields
    stddevPop: CreditCardSummaryStddevPopFields
    stddevSamp: CreditCardSummaryStddevSampFields
    sum: CreditCardSummarySumFields
    varPop: CreditCardSummaryVarPopFields
    varSamp: CreditCardSummaryVarSampFields
    variance: CreditCardSummaryVarianceFields
}

"aggregate avg on columns"
type CreditCardSummaryAvgFields {
    count: Float
    totalAmount: Float
}

"aggregate max on columns"
type CreditCardSummaryMaxFields {
    accountId: uuid
    count: Int
    creditCard: String
    groupId: uuid
    id: uuid
    totalAmount: numeric
    withdrawalDate: date
}

"aggregate min on columns"
type CreditCardSummaryMinFields {
    accountId: uuid
    count: Int
    creditCard: String
    groupId: uuid
    id: uuid
    totalAmount: numeric
    withdrawalDate: date
}

"response of any mutation on the table \"credit_card_summary\""
type CreditCardSummaryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [CreditCardSummary!]!
}

"aggregate stddev on columns"
type CreditCardSummaryStddevFields {
    count: Float
    totalAmount: Float
}

"aggregate stddevPop on columns"
type CreditCardSummaryStddevPopFields {
    count: Float
    totalAmount: Float
}

"aggregate stddevSamp on columns"
type CreditCardSummaryStddevSampFields {
    count: Float
    totalAmount: Float
}

"aggregate sum on columns"
type CreditCardSummarySumFields {
    count: Int
    totalAmount: numeric
}

"columns and relationships of \"credit_card_summary_total_by_account_view\""
type CreditCardSummaryTotalByAccountView {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregated selection of \"credit_card_summary_total_by_account_view\""
type CreditCardSummaryTotalByAccountViewAggregate {
    aggregate: CreditCardSummaryTotalByAccountViewAggregateFields
    nodes: [CreditCardSummaryTotalByAccountView!]!
}

"aggregate fields of \"credit_card_summary_total_by_account_view\""
type CreditCardSummaryTotalByAccountViewAggregateFields {
    avg: CreditCardSummaryTotalByAccountViewAvgFields
    count(columns: [CreditCardSummaryTotalByAccountViewSelectColumn!], distinct: Boolean): Int!
    max: CreditCardSummaryTotalByAccountViewMaxFields
    min: CreditCardSummaryTotalByAccountViewMinFields
    stddev: CreditCardSummaryTotalByAccountViewStddevFields
    stddevPop: CreditCardSummaryTotalByAccountViewStddevPopFields
    stddevSamp: CreditCardSummaryTotalByAccountViewStddevSampFields
    sum: CreditCardSummaryTotalByAccountViewSumFields
    varPop: CreditCardSummaryTotalByAccountViewVarPopFields
    varSamp: CreditCardSummaryTotalByAccountViewVarSampFields
    variance: CreditCardSummaryTotalByAccountViewVarianceFields
}

"aggregate avg on columns"
type CreditCardSummaryTotalByAccountViewAvgFields {
    displayOrder: Float
    total: Float
}

"aggregate max on columns"
type CreditCardSummaryTotalByAccountViewMaxFields {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate min on columns"
type CreditCardSummaryTotalByAccountViewMinFields {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate stddev on columns"
type CreditCardSummaryTotalByAccountViewStddevFields {
    displayOrder: Float
    total: Float
}

"aggregate stddevPop on columns"
type CreditCardSummaryTotalByAccountViewStddevPopFields {
    displayOrder: Float
    total: Float
}

"aggregate stddevSamp on columns"
type CreditCardSummaryTotalByAccountViewStddevSampFields {
    displayOrder: Float
    total: Float
}

"aggregate sum on columns"
type CreditCardSummaryTotalByAccountViewSumFields {
    displayOrder: Int
    total: numeric
}

"aggregate varPop on columns"
type CreditCardSummaryTotalByAccountViewVarPopFields {
    displayOrder: Float
    total: Float
}

"aggregate varSamp on columns"
type CreditCardSummaryTotalByAccountViewVarSampFields {
    displayOrder: Float
    total: Float
}

"aggregate variance on columns"
type CreditCardSummaryTotalByAccountViewVarianceFields {
    displayOrder: Float
    total: Float
}

"aggregate varPop on columns"
type CreditCardSummaryVarPopFields {
    count: Float
    totalAmount: Float
}

"aggregate varSamp on columns"
type CreditCardSummaryVarSampFields {
    count: Float
    totalAmount: Float
}

"aggregate variance on columns"
type CreditCardSummaryVarianceFields {
    count: Float
    totalAmount: Float
}

"columns and relationships of \"daily_detail\""
type DailyDetail {
    "An object relationship"
    account: Account!
    accountId: uuid!
    amount: numeric!
    "An object relationship"
    category: Category!
    categoryId: uuid!
    date: date!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    memo: String
    "An object relationship"
    user: User!
    userId: uuid!
}

"aggregated selection of \"daily_detail\""
type DailyDetailAggregate {
    aggregate: DailyDetailAggregateFields
    nodes: [DailyDetail!]!
}

"aggregate fields of \"daily_detail\""
type DailyDetailAggregateFields {
    avg: DailyDetailAvgFields
    count(columns: [DailyDetailSelectColumn!], distinct: Boolean): Int!
    max: DailyDetailMaxFields
    min: DailyDetailMinFields
    stddev: DailyDetailStddevFields
    stddevPop: DailyDetailStddevPopFields
    stddevSamp: DailyDetailStddevSampFields
    sum: DailyDetailSumFields
    varPop: DailyDetailVarPopFields
    varSamp: DailyDetailVarSampFields
    variance: DailyDetailVarianceFields
}

"aggregate avg on columns"
type DailyDetailAvgFields {
    amount: Float
}

"aggregate max on columns"
type DailyDetailMaxFields {
    accountId: uuid
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    userId: uuid
}

"aggregate min on columns"
type DailyDetailMinFields {
    accountId: uuid
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    userId: uuid
}

"response of any mutation on the table \"daily_detail\""
type DailyDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [DailyDetail!]!
}

"aggregate stddev on columns"
type DailyDetailStddevFields {
    amount: Float
}

"aggregate stddevPop on columns"
type DailyDetailStddevPopFields {
    amount: Float
}

"aggregate stddevSamp on columns"
type DailyDetailStddevSampFields {
    amount: Float
}

"aggregate sum on columns"
type DailyDetailSumFields {
    amount: numeric
}

"aggregate varPop on columns"
type DailyDetailVarPopFields {
    amount: Float
}

"aggregate varSamp on columns"
type DailyDetailVarSampFields {
    amount: Float
}

"aggregate variance on columns"
type DailyDetailVarianceFields {
    amount: Float
}

"columns and relationships of \"daily_total_view\""
type DailyTotalView {
    date: date
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregated selection of \"daily_total_view\""
type DailyTotalViewAggregate {
    aggregate: DailyTotalViewAggregateFields
    nodes: [DailyTotalView!]!
}

"aggregate fields of \"daily_total_view\""
type DailyTotalViewAggregateFields {
    avg: DailyTotalViewAvgFields
    count(columns: [DailyTotalViewSelectColumn!], distinct: Boolean): Int!
    max: DailyTotalViewMaxFields
    min: DailyTotalViewMinFields
    stddev: DailyTotalViewStddevFields
    stddevPop: DailyTotalViewStddevPopFields
    stddevSamp: DailyTotalViewStddevSampFields
    sum: DailyTotalViewSumFields
    varPop: DailyTotalViewVarPopFields
    varSamp: DailyTotalViewVarSampFields
    variance: DailyTotalViewVarianceFields
}

"aggregate avg on columns"
type DailyTotalViewAvgFields {
    total: Float
}

"aggregate max on columns"
type DailyTotalViewMaxFields {
    date: date
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate min on columns"
type DailyTotalViewMinFields {
    date: date
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate stddev on columns"
type DailyTotalViewStddevFields {
    total: Float
}

"aggregate stddevPop on columns"
type DailyTotalViewStddevPopFields {
    total: Float
}

"aggregate stddevSamp on columns"
type DailyTotalViewStddevSampFields {
    total: Float
}

"aggregate sum on columns"
type DailyTotalViewSumFields {
    total: numeric
}

"aggregate varPop on columns"
type DailyTotalViewVarPopFields {
    total: Float
}

"aggregate varSamp on columns"
type DailyTotalViewVarSampFields {
    total: Float
}

"aggregate variance on columns"
type DailyTotalViewVarianceFields {
    total: Float
}

"columns and relationships of \"genre\""
type Genre {
    "An array relationship"
    categories(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "An aggregate relationship"
    categoriesAggregate(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): CategoryAggregate!
    displayOrder: Int!
    genreId: uuid!
    genreName: String!
    genreType: genre_type!
    "An object relationship"
    group: Group!
    groupId: uuid!
    iocomeType: iocome_type!
    validFlag: Boolean
}

"aggregated selection of \"genre\""
type GenreAggregate {
    aggregate: GenreAggregateFields
    nodes: [Genre!]!
}

"aggregate fields of \"genre\""
type GenreAggregateFields {
    avg: GenreAvgFields
    count(columns: [GenreSelectColumn!], distinct: Boolean): Int!
    max: GenreMaxFields
    min: GenreMinFields
    stddev: GenreStddevFields
    stddevPop: GenreStddevPopFields
    stddevSamp: GenreStddevSampFields
    sum: GenreSumFields
    varPop: GenreVarPopFields
    varSamp: GenreVarSampFields
    variance: GenreVarianceFields
}

"aggregate avg on columns"
type GenreAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type GenreMaxFields {
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
}

"aggregate min on columns"
type GenreMinFields {
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
}

"response of any mutation on the table \"genre\""
type GenreMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Genre!]!
}

"aggregate stddev on columns"
type GenreStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type GenreStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type GenreStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type GenreSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type GenreVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type GenreVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type GenreVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"group\""
type Group {
    "An array relationship"
    accounts(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "An aggregate relationship"
    accountsAggregate(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): AccountAggregate!
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An aggregate relationship"
    affiliationsAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "An array relationship"
    categories(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "An aggregate relationship"
    categoriesAggregate(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): CategoryAggregate!
    "An aggregate relationship"
    creditCardSummariesAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): CreditCardSummaryAggregate!
    "An array relationship"
    credit_card_summaries(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "An array relationship"
    genres(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "An aggregate relationship"
    genresAggregate(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): GenreAggregate!
    "An aggregate relationship"
    groupApplicationsAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    groupId: uuid!
    groupName: String!
    "An array relationship"
    group_applications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "An aggregate relationship"
    importFileHistoriesAggregate(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): ImportFileHistoryAggregate!
    "An array relationship"
    import_file_histories(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "An aggregate relationship"
    summaryCategoryByGroupsAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): SummaryCategoryByGroupAggregate!
    "An array relationship"
    summary_category_by_groups(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
}

"aggregated selection of \"group\""
type GroupAggregate {
    aggregate: GroupAggregateFields
    nodes: [Group!]!
}

"aggregate fields of \"group\""
type GroupAggregateFields {
    count(columns: [GroupSelectColumn!], distinct: Boolean): Int!
    max: GroupMaxFields
    min: GroupMinFields
}

"columns and relationships of \"group_application\""
type GroupApplication {
    "An object relationship"
    application: Application!
    applicationId: uuid!
    "An object relationship"
    group: Group!
    groupApplicationId: uuid!
    groupId: uuid!
}

"aggregated selection of \"group_application\""
type GroupApplicationAggregate {
    aggregate: GroupApplicationAggregateFields
    nodes: [GroupApplication!]!
}

"aggregate fields of \"group_application\""
type GroupApplicationAggregateFields {
    count(columns: [GroupApplicationSelectColumn!], distinct: Boolean): Int!
    max: GroupApplicationMaxFields
    min: GroupApplicationMinFields
}

"aggregate max on columns"
type GroupApplicationMaxFields {
    applicationId: uuid
    groupApplicationId: uuid
    groupId: uuid
}

"aggregate min on columns"
type GroupApplicationMinFields {
    applicationId: uuid
    groupApplicationId: uuid
    groupId: uuid
}

"response of any mutation on the table \"group_application\""
type GroupApplicationMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [GroupApplication!]!
}

"aggregate max on columns"
type GroupMaxFields {
    groupId: uuid
    groupName: String
}

"aggregate min on columns"
type GroupMinFields {
    groupId: uuid
    groupName: String
}

"response of any mutation on the table \"group\""
type GroupMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Group!]!
}

"columns and relationships of \"group_role\""
type GroupRole {
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An aggregate relationship"
    affiliationsAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    groupRoleId: uuid!
    role: String!
}

"aggregated selection of \"group_role\""
type GroupRoleAggregate {
    aggregate: GroupRoleAggregateFields
    nodes: [GroupRole!]!
}

"aggregate fields of \"group_role\""
type GroupRoleAggregateFields {
    count(columns: [GroupRoleSelectColumn!], distinct: Boolean): Int!
    max: GroupRoleMaxFields
    min: GroupRoleMinFields
}

"aggregate max on columns"
type GroupRoleMaxFields {
    groupRoleId: uuid
    role: String
}

"aggregate min on columns"
type GroupRoleMinFields {
    groupRoleId: uuid
    role: String
}

"response of any mutation on the table \"group_role\""
type GroupRoleMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [GroupRole!]!
}

"交換品マスタ"
type HelperKidsExchangeItem {
    "ID"
    exchangeItemId: uuid!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "An array relationship"
    helpPointExchangedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "An aggregate relationship"
    helpPointExchangedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "メモ"
    memo: String
    "品名"
    name: String!
    "交換ポイント"
    point: Int!
}

"aggregated selection of \"helper_kids.exchange_item\""
type HelperKidsExchangeItemAggregate {
    aggregate: HelperKidsExchangeItemAggregateFields
    nodes: [HelperKidsExchangeItem!]!
}

"aggregate fields of \"helper_kids.exchange_item\""
type HelperKidsExchangeItemAggregateFields {
    avg: HelperKidsExchangeItemAvgFields
    count(columns: [HelperKidsExchangeItemSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsExchangeItemMaxFields
    min: HelperKidsExchangeItemMinFields
    stddev: HelperKidsExchangeItemStddevFields
    stddevPop: HelperKidsExchangeItemStddevPopFields
    stddevSamp: HelperKidsExchangeItemStddevSampFields
    sum: HelperKidsExchangeItemSumFields
    varPop: HelperKidsExchangeItemVarPopFields
    varSamp: HelperKidsExchangeItemVarSampFields
    variance: HelperKidsExchangeItemVarianceFields
}

"aggregate avg on columns"
type HelperKidsExchangeItemAvgFields {
    "交換ポイント"
    point: Float
}

"aggregate max on columns"
type HelperKidsExchangeItemMaxFields {
    "ID"
    exchangeItemId: uuid
    "グループID"
    groupId: uuid
    "メモ"
    memo: String
    "品名"
    name: String
    "交換ポイント"
    point: Int
}

"aggregate min on columns"
type HelperKidsExchangeItemMinFields {
    "ID"
    exchangeItemId: uuid
    "グループID"
    groupId: uuid
    "メモ"
    memo: String
    "品名"
    name: String
    "交換ポイント"
    point: Int
}

"response of any mutation on the table \"helper_kids.exchange_item\""
type HelperKidsExchangeItemMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsExchangeItem!]!
}

"aggregate stddev on columns"
type HelperKidsExchangeItemStddevFields {
    "交換ポイント"
    point: Float
}

"aggregate stddevPop on columns"
type HelperKidsExchangeItemStddevPopFields {
    "交換ポイント"
    point: Float
}

"aggregate stddevSamp on columns"
type HelperKidsExchangeItemStddevSampFields {
    "交換ポイント"
    point: Float
}

"aggregate sum on columns"
type HelperKidsExchangeItemSumFields {
    "交換ポイント"
    point: Int
}

"aggregate varPop on columns"
type HelperKidsExchangeItemVarPopFields {
    "交換ポイント"
    point: Float
}

"aggregate varSamp on columns"
type HelperKidsExchangeItemVarSampFields {
    "交換ポイント"
    point: Float
}

"aggregate variance on columns"
type HelperKidsExchangeItemVarianceFields {
    "交換ポイント"
    point: Float
}

"お手伝い項目マスタ"
type HelperKidsHelpItem {
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "ID"
    helpItemId: uuid!
    "An array relationship"
    helpPointEarnedDetails(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "An aggregate relationship"
    helpPointEarnedDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): HelperKidsHelpPointEarnedDetailAggregate!
    "メモ"
    memo: String
    "項目名"
    name: String!
    "お手伝いポイント"
    point: Int!
}

"aggregated selection of \"helper_kids.help_item\""
type HelperKidsHelpItemAggregate {
    aggregate: HelperKidsHelpItemAggregateFields
    nodes: [HelperKidsHelpItem!]!
}

"aggregate fields of \"helper_kids.help_item\""
type HelperKidsHelpItemAggregateFields {
    avg: HelperKidsHelpItemAvgFields
    count(columns: [HelperKidsHelpItemSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelpItemMaxFields
    min: HelperKidsHelpItemMinFields
    stddev: HelperKidsHelpItemStddevFields
    stddevPop: HelperKidsHelpItemStddevPopFields
    stddevSamp: HelperKidsHelpItemStddevSampFields
    sum: HelperKidsHelpItemSumFields
    varPop: HelperKidsHelpItemVarPopFields
    varSamp: HelperKidsHelpItemVarSampFields
    variance: HelperKidsHelpItemVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelpItemAvgFields {
    "お手伝いポイント"
    point: Float
}

"aggregate max on columns"
type HelperKidsHelpItemMaxFields {
    "グループID"
    groupId: uuid
    "ID"
    helpItemId: uuid
    "メモ"
    memo: String
    "項目名"
    name: String
    "お手伝いポイント"
    point: Int
}

"aggregate min on columns"
type HelperKidsHelpItemMinFields {
    "グループID"
    groupId: uuid
    "ID"
    helpItemId: uuid
    "メモ"
    memo: String
    "項目名"
    name: String
    "お手伝いポイント"
    point: Int
}

"response of any mutation on the table \"helper_kids.help_item\""
type HelperKidsHelpItemMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpItem!]!
}

"aggregate stddev on columns"
type HelperKidsHelpItemStddevFields {
    "お手伝いポイント"
    point: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelpItemStddevPopFields {
    "お手伝いポイント"
    point: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelpItemStddevSampFields {
    "お手伝いポイント"
    point: Float
}

"aggregate sum on columns"
type HelperKidsHelpItemSumFields {
    "お手伝いポイント"
    point: Int
}

"aggregate varPop on columns"
type HelperKidsHelpItemVarPopFields {
    "お手伝いポイント"
    point: Float
}

"aggregate varSamp on columns"
type HelperKidsHelpItemVarSampFields {
    "お手伝いポイント"
    point: Float
}

"aggregate variance on columns"
type HelperKidsHelpItemVarianceFields {
    "お手伝いポイント"
    point: Float
}

"お手伝いポイント獲得実績"
type HelperKidsHelpPointEarnedAchievement {
    "獲得日時"
    earnedDatetime: timestamp!
    "獲得ポイント"
    earnedPoint: Int!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "ID"
    helpPointEarnedAchievementId: uuid!
    "An array relationship"
    helpPointEarnedDetails(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "An aggregate relationship"
    helpPointEarnedDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): HelperKidsHelpPointEarnedDetailAggregate!
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    "お手伝いキッズID"
    helperKidId: uuid!
}

"aggregated selection of \"helper_kids.help_point_earned_achievement\""
type HelperKidsHelpPointEarnedAchievementAggregate {
    aggregate: HelperKidsHelpPointEarnedAchievementAggregateFields
    nodes: [HelperKidsHelpPointEarnedAchievement!]!
}

"aggregate fields of \"helper_kids.help_point_earned_achievement\""
type HelperKidsHelpPointEarnedAchievementAggregateFields {
    avg: HelperKidsHelpPointEarnedAchievementAvgFields
    count(columns: [HelperKidsHelpPointEarnedAchievementSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelpPointEarnedAchievementMaxFields
    min: HelperKidsHelpPointEarnedAchievementMinFields
    stddev: HelperKidsHelpPointEarnedAchievementStddevFields
    stddevPop: HelperKidsHelpPointEarnedAchievementStddevPopFields
    stddevSamp: HelperKidsHelpPointEarnedAchievementStddevSampFields
    sum: HelperKidsHelpPointEarnedAchievementSumFields
    varPop: HelperKidsHelpPointEarnedAchievementVarPopFields
    varSamp: HelperKidsHelpPointEarnedAchievementVarSampFields
    variance: HelperKidsHelpPointEarnedAchievementVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelpPointEarnedAchievementAvgFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate max on columns"
type HelperKidsHelpPointEarnedAchievementMaxFields {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"aggregate min on columns"
type HelperKidsHelpPointEarnedAchievementMinFields {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"response of any mutation on the table \"helper_kids.help_point_earned_achievement\""
type HelperKidsHelpPointEarnedAchievementMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpPointEarnedAchievement!]!
}

"aggregate stddev on columns"
type HelperKidsHelpPointEarnedAchievementStddevFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelpPointEarnedAchievementStddevPopFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelpPointEarnedAchievementStddevSampFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate sum on columns"
type HelperKidsHelpPointEarnedAchievementSumFields {
    "獲得ポイント"
    earnedPoint: Int
}

"aggregate varPop on columns"
type HelperKidsHelpPointEarnedAchievementVarPopFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate varSamp on columns"
type HelperKidsHelpPointEarnedAchievementVarSampFields {
    "獲得ポイント"
    earnedPoint: Float
}

"aggregate variance on columns"
type HelperKidsHelpPointEarnedAchievementVarianceFields {
    "獲得ポイント"
    earnedPoint: Float
}

"お手伝いポイント獲得明細"
type HelperKidsHelpPointEarnedDetail {
    "獲得実績ID"
    earnedAchievementId: uuid!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "An object relationship"
    helpItem: HelperKidsHelpItem!
    "お手伝い項目件数"
    helpItemCount: Int!
    "お手伝い項目ID"
    helpItemId: uuid!
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int!
    "An object relationship"
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievement!
    "ID"
    helpPointEarnedDetailId: uuid!
}

"aggregated selection of \"helper_kids.help_point_earned_detail\""
type HelperKidsHelpPointEarnedDetailAggregate {
    aggregate: HelperKidsHelpPointEarnedDetailAggregateFields
    nodes: [HelperKidsHelpPointEarnedDetail!]!
}

"aggregate fields of \"helper_kids.help_point_earned_detail\""
type HelperKidsHelpPointEarnedDetailAggregateFields {
    avg: HelperKidsHelpPointEarnedDetailAvgFields
    count(columns: [HelperKidsHelpPointEarnedDetailSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelpPointEarnedDetailMaxFields
    min: HelperKidsHelpPointEarnedDetailMinFields
    stddev: HelperKidsHelpPointEarnedDetailStddevFields
    stddevPop: HelperKidsHelpPointEarnedDetailStddevPopFields
    stddevSamp: HelperKidsHelpPointEarnedDetailStddevSampFields
    sum: HelperKidsHelpPointEarnedDetailSumFields
    varPop: HelperKidsHelpPointEarnedDetailVarPopFields
    varSamp: HelperKidsHelpPointEarnedDetailVarSampFields
    variance: HelperKidsHelpPointEarnedDetailVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelpPointEarnedDetailAvgFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"aggregate max on columns"
type HelperKidsHelpPointEarnedDetailMaxFields {
    "獲得実績ID"
    earnedAchievementId: uuid
    "グループID"
    groupId: uuid
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    "ID"
    helpPointEarnedDetailId: uuid
}

"aggregate min on columns"
type HelperKidsHelpPointEarnedDetailMinFields {
    "獲得実績ID"
    earnedAchievementId: uuid
    "グループID"
    groupId: uuid
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    "ID"
    helpPointEarnedDetailId: uuid
}

"response of any mutation on the table \"helper_kids.help_point_earned_detail\""
type HelperKidsHelpPointEarnedDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpPointEarnedDetail!]!
}

"aggregate stddev on columns"
type HelperKidsHelpPointEarnedDetailStddevFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelpPointEarnedDetailStddevPopFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelpPointEarnedDetailStddevSampFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"aggregate sum on columns"
type HelperKidsHelpPointEarnedDetailSumFields {
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
}

"aggregate varPop on columns"
type HelperKidsHelpPointEarnedDetailVarPopFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"aggregate varSamp on columns"
type HelperKidsHelpPointEarnedDetailVarSampFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"aggregate variance on columns"
type HelperKidsHelpPointEarnedDetailVarianceFields {
    "お手伝い項目件数"
    helpItemCount: Float
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Float
}

"お手伝いポイント交換実績"
type HelperKidsHelpPointExchangedAchievement {
    "交換件数"
    exchangeCount: Int!
    "An object relationship"
    exchangeItem: HelperKidsExchangeItem!
    "交換品ID"
    exchangeItemId: uuid!
    "交換合計ポイント"
    exchangeTotalPoint: Int!
    "交換日時"
    exchangedDatetime: timestamp!
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "ID"
    helpPointExchangedAchievementId: uuid!
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    "お手伝いキッズID"
    helperKidId: uuid!
}

"aggregated selection of \"helper_kids.help_point_exchanged_achievement\""
type HelperKidsHelpPointExchangedAchievementAggregate {
    aggregate: HelperKidsHelpPointExchangedAchievementAggregateFields
    nodes: [HelperKidsHelpPointExchangedAchievement!]!
}

"aggregate fields of \"helper_kids.help_point_exchanged_achievement\""
type HelperKidsHelpPointExchangedAchievementAggregateFields {
    avg: HelperKidsHelpPointExchangedAchievementAvgFields
    count(columns: [HelperKidsHelpPointExchangedAchievementSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelpPointExchangedAchievementMaxFields
    min: HelperKidsHelpPointExchangedAchievementMinFields
    stddev: HelperKidsHelpPointExchangedAchievementStddevFields
    stddevPop: HelperKidsHelpPointExchangedAchievementStddevPopFields
    stddevSamp: HelperKidsHelpPointExchangedAchievementStddevSampFields
    sum: HelperKidsHelpPointExchangedAchievementSumFields
    varPop: HelperKidsHelpPointExchangedAchievementVarPopFields
    varSamp: HelperKidsHelpPointExchangedAchievementVarSampFields
    variance: HelperKidsHelpPointExchangedAchievementVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelpPointExchangedAchievementAvgFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate max on columns"
type HelperKidsHelpPointExchangedAchievementMaxFields {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"aggregate min on columns"
type HelperKidsHelpPointExchangedAchievementMinFields {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"response of any mutation on the table \"helper_kids.help_point_exchanged_achievement\""
type HelperKidsHelpPointExchangedAchievementMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelpPointExchangedAchievement!]!
}

"aggregate stddev on columns"
type HelperKidsHelpPointExchangedAchievementStddevFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelpPointExchangedAchievementStddevPopFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelpPointExchangedAchievementStddevSampFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate sum on columns"
type HelperKidsHelpPointExchangedAchievementSumFields {
    "交換件数"
    exchangeCount: Int
    "交換合計ポイント"
    exchangeTotalPoint: Int
}

"aggregate varPop on columns"
type HelperKidsHelpPointExchangedAchievementVarPopFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate varSamp on columns"
type HelperKidsHelpPointExchangedAchievementVarSampFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"aggregate variance on columns"
type HelperKidsHelpPointExchangedAchievementVarianceFields {
    "交換件数"
    exchangeCount: Float
    "交換合計ポイント"
    exchangeTotalPoint: Float
}

"お手伝いキッズマスタ"
type HelperKidsHelperKid {
    "An object relationship"
    group: Group!
    "グループID"
    groupId: uuid!
    "An array relationship"
    helpPointEarnedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "An aggregate relationship"
    helpPointEarnedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "An array relationship"
    helpPointExchangedAchievements(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "An aggregate relationship"
    helpPointExchangedAchievementsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "ID"
    helperKidId: uuid!
    "An array relationship"
    helperKidParents(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "An aggregate relationship"
    helperKidParentsAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): HelperKidsHelperKidParentAggregate!
    "An object relationship"
    helperKidPoint: HelperKidsHelperKidPoint
    "氏名"
    name: String!
    "名前 接尾辞"
    nameSuffix: String!
}

"aggregated selection of \"helper_kids.helper_kid\""
type HelperKidsHelperKidAggregate {
    aggregate: HelperKidsHelperKidAggregateFields
    nodes: [HelperKidsHelperKid!]!
}

"aggregate fields of \"helper_kids.helper_kid\""
type HelperKidsHelperKidAggregateFields {
    count(columns: [HelperKidsHelperKidSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelperKidMaxFields
    min: HelperKidsHelperKidMinFields
}

"aggregate max on columns"
type HelperKidsHelperKidMaxFields {
    "グループID"
    groupId: uuid
    "ID"
    helperKidId: uuid
    "氏名"
    name: String
    "名前 接尾辞"
    nameSuffix: String
}

"aggregate min on columns"
type HelperKidsHelperKidMinFields {
    "グループID"
    groupId: uuid
    "ID"
    helperKidId: uuid
    "氏名"
    name: String
    "名前 接尾辞"
    nameSuffix: String
}

"response of any mutation on the table \"helper_kids.helper_kid\""
type HelperKidsHelperKidMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelperKid!]!
}

"columns and relationships of \"helper_kids.helper_kid_parent\""
type HelperKidsHelperKidParent {
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    helperKidId: uuid!
    helperKidParentId: uuid!
    parentUserId: uuid!
    "An object relationship"
    user: User!
}

"aggregated selection of \"helper_kids.helper_kid_parent\""
type HelperKidsHelperKidParentAggregate {
    aggregate: HelperKidsHelperKidParentAggregateFields
    nodes: [HelperKidsHelperKidParent!]!
}

"aggregate fields of \"helper_kids.helper_kid_parent\""
type HelperKidsHelperKidParentAggregateFields {
    count(columns: [HelperKidsHelperKidParentSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelperKidParentMaxFields
    min: HelperKidsHelperKidParentMinFields
}

"aggregate max on columns"
type HelperKidsHelperKidParentMaxFields {
    helperKidId: uuid
    helperKidParentId: uuid
    parentUserId: uuid
}

"aggregate min on columns"
type HelperKidsHelperKidParentMinFields {
    helperKidId: uuid
    helperKidParentId: uuid
    parentUserId: uuid
}

"response of any mutation on the table \"helper_kids.helper_kid_parent\""
type HelperKidsHelperKidParentMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelperKidParent!]!
}

"お手伝いキッズポイント"
type HelperKidsHelperKidPoint {
    "An object relationship"
    helperKid: HelperKidsHelperKid!
    "お手伝いキッズID"
    helperKidId: uuid!
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp!
    "ポイント"
    point: Int!
}

"aggregated selection of \"helper_kids.helper_kid_point\""
type HelperKidsHelperKidPointAggregate {
    aggregate: HelperKidsHelperKidPointAggregateFields
    nodes: [HelperKidsHelperKidPoint!]!
}

"aggregate fields of \"helper_kids.helper_kid_point\""
type HelperKidsHelperKidPointAggregateFields {
    avg: HelperKidsHelperKidPointAvgFields
    count(columns: [HelperKidsHelperKidPointSelectColumn!], distinct: Boolean): Int!
    max: HelperKidsHelperKidPointMaxFields
    min: HelperKidsHelperKidPointMinFields
    stddev: HelperKidsHelperKidPointStddevFields
    stddevPop: HelperKidsHelperKidPointStddevPopFields
    stddevSamp: HelperKidsHelperKidPointStddevSampFields
    sum: HelperKidsHelperKidPointSumFields
    varPop: HelperKidsHelperKidPointVarPopFields
    varSamp: HelperKidsHelperKidPointVarSampFields
    variance: HelperKidsHelperKidPointVarianceFields
}

"aggregate avg on columns"
type HelperKidsHelperKidPointAvgFields {
    "ポイント"
    point: Float
}

"aggregate max on columns"
type HelperKidsHelperKidPointMaxFields {
    "お手伝いキッズID"
    helperKidId: uuid
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp
    "ポイント"
    point: Int
}

"aggregate min on columns"
type HelperKidsHelperKidPointMinFields {
    "お手伝いキッズID"
    helperKidId: uuid
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp
    "ポイント"
    point: Int
}

"response of any mutation on the table \"helper_kids.helper_kid_point\""
type HelperKidsHelperKidPointMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HelperKidsHelperKidPoint!]!
}

"aggregate stddev on columns"
type HelperKidsHelperKidPointStddevFields {
    "ポイント"
    point: Float
}

"aggregate stddevPop on columns"
type HelperKidsHelperKidPointStddevPopFields {
    "ポイント"
    point: Float
}

"aggregate stddevSamp on columns"
type HelperKidsHelperKidPointStddevSampFields {
    "ポイント"
    point: Float
}

"aggregate sum on columns"
type HelperKidsHelperKidPointSumFields {
    "ポイント"
    point: Int
}

"aggregate varPop on columns"
type HelperKidsHelperKidPointVarPopFields {
    "ポイント"
    point: Float
}

"aggregate varSamp on columns"
type HelperKidsHelperKidPointVarSampFields {
    "ポイント"
    point: Float
}

"aggregate variance on columns"
type HelperKidsHelperKidPointVarianceFields {
    "ポイント"
    point: Float
}

"columns and relationships of \"import_file_history\""
type ImportFileHistory {
    "An object relationship"
    credit_card_summary: CreditCardSummary
    fileName: String!
    fileType: String!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
    importDatetime: timestamp!
    importUserId: uuid!
    "An object relationship"
    user: User!
}

"aggregated selection of \"import_file_history\""
type ImportFileHistoryAggregate {
    aggregate: ImportFileHistoryAggregateFields
    nodes: [ImportFileHistory!]!
}

"aggregate fields of \"import_file_history\""
type ImportFileHistoryAggregateFields {
    count(columns: [ImportFileHistorySelectColumn!], distinct: Boolean): Int!
    max: ImportFileHistoryMaxFields
    min: ImportFileHistoryMinFields
}

"aggregate max on columns"
type ImportFileHistoryMaxFields {
    fileName: String
    fileType: String
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
}

"aggregate min on columns"
type ImportFileHistoryMinFields {
    fileName: String
    fileType: String
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
}

"response of any mutation on the table \"import_file_history\""
type ImportFileHistoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [ImportFileHistory!]!
}

"columns and relationships of \"summary_category_by_group\""
type SummaryCategoryByGroup {
    "An object relationship"
    category: Category!
    categoryId: uuid!
    displayOrder: Int!
    "An object relationship"
    group: Group!
    groupId: uuid!
    id: uuid!
}

"aggregated selection of \"summary_category_by_group\""
type SummaryCategoryByGroupAggregate {
    aggregate: SummaryCategoryByGroupAggregateFields
    nodes: [SummaryCategoryByGroup!]!
}

"aggregate fields of \"summary_category_by_group\""
type SummaryCategoryByGroupAggregateFields {
    avg: SummaryCategoryByGroupAvgFields
    count(columns: [SummaryCategoryByGroupSelectColumn!], distinct: Boolean): Int!
    max: SummaryCategoryByGroupMaxFields
    min: SummaryCategoryByGroupMinFields
    stddev: SummaryCategoryByGroupStddevFields
    stddevPop: SummaryCategoryByGroupStddevPopFields
    stddevSamp: SummaryCategoryByGroupStddevSampFields
    sum: SummaryCategoryByGroupSumFields
    varPop: SummaryCategoryByGroupVarPopFields
    varSamp: SummaryCategoryByGroupVarSampFields
    variance: SummaryCategoryByGroupVarianceFields
}

"aggregate avg on columns"
type SummaryCategoryByGroupAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type SummaryCategoryByGroupMaxFields {
    categoryId: uuid
    displayOrder: Int
    groupId: uuid
    id: uuid
}

"aggregate min on columns"
type SummaryCategoryByGroupMinFields {
    categoryId: uuid
    displayOrder: Int
    groupId: uuid
    id: uuid
}

"response of any mutation on the table \"summary_category_by_group\""
type SummaryCategoryByGroupMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [SummaryCategoryByGroup!]!
}

"aggregate stddev on columns"
type SummaryCategoryByGroupStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type SummaryCategoryByGroupStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type SummaryCategoryByGroupStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type SummaryCategoryByGroupSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type SummaryCategoryByGroupVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type SummaryCategoryByGroupVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type SummaryCategoryByGroupVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"summary_category_by_user\""
type SummaryCategoryByUser {
    "An object relationship"
    category: Category!
    categoryId: uuid!
    displayOrder: Int!
    id: uuid!
    "An object relationship"
    user: User!
    userId: uuid!
}

"aggregated selection of \"summary_category_by_user\""
type SummaryCategoryByUserAggregate {
    aggregate: SummaryCategoryByUserAggregateFields
    nodes: [SummaryCategoryByUser!]!
}

"aggregate fields of \"summary_category_by_user\""
type SummaryCategoryByUserAggregateFields {
    avg: SummaryCategoryByUserAvgFields
    count(columns: [SummaryCategoryByUserSelectColumn!], distinct: Boolean): Int!
    max: SummaryCategoryByUserMaxFields
    min: SummaryCategoryByUserMinFields
    stddev: SummaryCategoryByUserStddevFields
    stddevPop: SummaryCategoryByUserStddevPopFields
    stddevSamp: SummaryCategoryByUserStddevSampFields
    sum: SummaryCategoryByUserSumFields
    varPop: SummaryCategoryByUserVarPopFields
    varSamp: SummaryCategoryByUserVarSampFields
    variance: SummaryCategoryByUserVarianceFields
}

"aggregate avg on columns"
type SummaryCategoryByUserAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type SummaryCategoryByUserMaxFields {
    categoryId: uuid
    displayOrder: Int
    id: uuid
    userId: uuid
}

"aggregate min on columns"
type SummaryCategoryByUserMinFields {
    categoryId: uuid
    displayOrder: Int
    id: uuid
    userId: uuid
}

"response of any mutation on the table \"summary_category_by_user\""
type SummaryCategoryByUserMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [SummaryCategoryByUser!]!
}

"aggregate stddev on columns"
type SummaryCategoryByUserStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type SummaryCategoryByUserStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type SummaryCategoryByUserStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type SummaryCategoryByUserSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type SummaryCategoryByUserVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type SummaryCategoryByUserVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type SummaryCategoryByUserVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"total_by_account_view\""
type TotalByAccountView {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

type TotalByAccountViewAggregate {
    aggregate: TotalByAccountViewAggregateFields
    nodes: [TotalByAccountView!]!
}

"aggregate fields of \"total_by_account_view\""
type TotalByAccountViewAggregateFields {
    avg: TotalByAccountViewAvgFields
    count(columns: [TotalByAccountViewSelectColumn!], distinct: Boolean): Int!
    max: TotalByAccountViewMaxFields
    min: TotalByAccountViewMinFields
    stddev: TotalByAccountViewStddevFields
    stddevPop: TotalByAccountViewStddevPopFields
    stddevSamp: TotalByAccountViewStddevSampFields
    sum: TotalByAccountViewSumFields
    varPop: TotalByAccountViewVarPopFields
    varSamp: TotalByAccountViewVarSampFields
    variance: TotalByAccountViewVarianceFields
}

"aggregate avg on columns"
type TotalByAccountViewAvgFields {
    displayOrder: Float
    total: Float
}

"aggregate max on columns"
type TotalByAccountViewMaxFields {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate min on columns"
type TotalByAccountViewMinFields {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate stddev on columns"
type TotalByAccountViewStddevFields {
    displayOrder: Float
    total: Float
}

"aggregate stddevPop on columns"
type TotalByAccountViewStddevPopFields {
    displayOrder: Float
    total: Float
}

"aggregate stddevSamp on columns"
type TotalByAccountViewStddevSampFields {
    displayOrder: Float
    total: Float
}

"aggregate sum on columns"
type TotalByAccountViewSumFields {
    displayOrder: Int
    total: numeric
}

"aggregate varPop on columns"
type TotalByAccountViewVarPopFields {
    displayOrder: Float
    total: Float
}

"aggregate varSamp on columns"
type TotalByAccountViewVarSampFields {
    displayOrder: Float
    total: Float
}

"aggregate variance on columns"
type TotalByAccountViewVarianceFields {
    displayOrder: Float
    total: Float
}

"columns and relationships of \"total_by_category_view\""
type TotalByCategoryView {
    categoryId: uuid
    categoryName: String
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

type TotalByCategoryViewAggregate {
    aggregate: TotalByCategoryViewAggregateFields
    nodes: [TotalByCategoryView!]!
}

"aggregate fields of \"total_by_category_view\""
type TotalByCategoryViewAggregateFields {
    avg: TotalByCategoryViewAvgFields
    count(columns: [TotalByCategoryViewSelectColumn!], distinct: Boolean): Int!
    max: TotalByCategoryViewMaxFields
    min: TotalByCategoryViewMinFields
    stddev: TotalByCategoryViewStddevFields
    stddevPop: TotalByCategoryViewStddevPopFields
    stddevSamp: TotalByCategoryViewStddevSampFields
    sum: TotalByCategoryViewSumFields
    varPop: TotalByCategoryViewVarPopFields
    varSamp: TotalByCategoryViewVarSampFields
    variance: TotalByCategoryViewVarianceFields
}

"aggregate avg on columns"
type TotalByCategoryViewAvgFields {
    total: Float
}

"aggregate max on columns"
type TotalByCategoryViewMaxFields {
    categoryId: uuid
    categoryName: String
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate min on columns"
type TotalByCategoryViewMinFields {
    categoryId: uuid
    categoryName: String
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate stddev on columns"
type TotalByCategoryViewStddevFields {
    total: Float
}

"aggregate stddevPop on columns"
type TotalByCategoryViewStddevPopFields {
    total: Float
}

"aggregate stddevSamp on columns"
type TotalByCategoryViewStddevSampFields {
    total: Float
}

"aggregate sum on columns"
type TotalByCategoryViewSumFields {
    total: numeric
}

"aggregate varPop on columns"
type TotalByCategoryViewVarPopFields {
    total: Float
}

"aggregate varSamp on columns"
type TotalByCategoryViewVarSampFields {
    total: Float
}

"aggregate variance on columns"
type TotalByCategoryViewVarianceFields {
    total: Float
}

"columns and relationships of \"total_by_genre_view\""
type TotalByGenreView {
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

type TotalByGenreViewAggregate {
    aggregate: TotalByGenreViewAggregateFields
    nodes: [TotalByGenreView!]!
}

"aggregate fields of \"total_by_genre_view\""
type TotalByGenreViewAggregateFields {
    avg: TotalByGenreViewAvgFields
    count(columns: [TotalByGenreViewSelectColumn!], distinct: Boolean): Int!
    max: TotalByGenreViewMaxFields
    min: TotalByGenreViewMinFields
    stddev: TotalByGenreViewStddevFields
    stddevPop: TotalByGenreViewStddevPopFields
    stddevSamp: TotalByGenreViewStddevSampFields
    sum: TotalByGenreViewSumFields
    varPop: TotalByGenreViewVarPopFields
    varSamp: TotalByGenreViewVarSampFields
    variance: TotalByGenreViewVarianceFields
}

"aggregate avg on columns"
type TotalByGenreViewAvgFields {
    total: Float
}

"aggregate max on columns"
type TotalByGenreViewMaxFields {
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate min on columns"
type TotalByGenreViewMinFields {
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"aggregate stddev on columns"
type TotalByGenreViewStddevFields {
    total: Float
}

"aggregate stddevPop on columns"
type TotalByGenreViewStddevPopFields {
    total: Float
}

"aggregate stddevSamp on columns"
type TotalByGenreViewStddevSampFields {
    total: Float
}

"aggregate sum on columns"
type TotalByGenreViewSumFields {
    total: numeric
}

"aggregate varPop on columns"
type TotalByGenreViewVarPopFields {
    total: Float
}

"aggregate varSamp on columns"
type TotalByGenreViewVarSampFields {
    total: Float
}

"aggregate variance on columns"
type TotalByGenreViewVarianceFields {
    total: Float
}

"振替カテゴリ"
type TransferCategory {
    "グループID"
    groupId: uuid!
    "収入カテゴリID"
    incomeCategoryId: uuid!
    "支出カテゴリID"
    outcomeCategoryId: uuid!
}

"aggregated selection of \"transfer_category\""
type TransferCategoryAggregate {
    aggregate: TransferCategoryAggregateFields
    nodes: [TransferCategory!]!
}

"aggregate fields of \"transfer_category\""
type TransferCategoryAggregateFields {
    count(columns: [TransferCategorySelectColumn!], distinct: Boolean): Int!
    max: TransferCategoryMaxFields
    min: TransferCategoryMinFields
}

"aggregate max on columns"
type TransferCategoryMaxFields {
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

"aggregate min on columns"
type TransferCategoryMinFields {
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

"response of any mutation on the table \"transfer_category\""
type TransferCategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [TransferCategory!]!
}

"ユーザ"
type User {
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An aggregate relationship"
    affiliationsAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): CreditCardDetailAggregate!
    "An array relationship"
    credit_card_details(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "An array relationship"
    daily_details(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    displayOrder: Int
    email: String
    "An aggregate relationship"
    importFileHistoriesAggregate(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): ImportFileHistoryAggregate!
    "An array relationship"
    import_file_histories(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "An aggregate relationship"
    summaryCategoryByUsersAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): SummaryCategoryByUserAggregate!
    "An array relationship"
    summary_category_by_users(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): [SummaryCategoryByUser!]!
    userId: uuid!
    userName: String
}

"aggregated selection of \"user\""
type UserAggregate {
    aggregate: UserAggregateFields
    nodes: [User!]!
}

"aggregate fields of \"user\""
type UserAggregateFields {
    avg: UserAvgFields
    count(columns: [UserSelectColumn!], distinct: Boolean): Int!
    max: UserMaxFields
    min: UserMinFields
    stddev: UserStddevFields
    stddevPop: UserStddevPopFields
    stddevSamp: UserStddevSampFields
    sum: UserSumFields
    varPop: UserVarPopFields
    varSamp: UserVarSampFields
    variance: UserVarianceFields
}

"aggregate avg on columns"
type UserAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type UserMaxFields {
    displayOrder: Int
    email: String
    userId: uuid
    userName: String
}

"aggregate min on columns"
type UserMinFields {
    displayOrder: Int
    email: String
    userId: uuid
    userName: String
}

"response of any mutation on the table \"user\""
type UserMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [User!]!
}

"aggregate stddev on columns"
type UserStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type UserStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type UserStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type UserSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type UserVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type UserVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type UserVarianceFields {
    displayOrder: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"account\""
    deleteAccount(
        "filter the rows which have to be deleted"
        where: AccountBoolExp!
    ): AccountMutationResponse
    "delete single row from the table: \"account\""
    deleteAccountByPk(accountId: uuid!): Account
    "delete data from the table: \"affiliation\""
    deleteAffiliation(
        "filter the rows which have to be deleted"
        where: AffiliationBoolExp!
    ): AffiliationMutationResponse
    "delete single row from the table: \"affiliation\""
    deleteAffiliationByPk(affiliationId: uuid!): Affiliation
    "delete data from the table: \"application\""
    deleteApplication(
        "filter the rows which have to be deleted"
        where: ApplicationBoolExp!
    ): ApplicationMutationResponse
    "delete single row from the table: \"application\""
    deleteApplicationByPk(applicationId: uuid!): Application
    "delete data from the table: \"category\""
    deleteCategory(
        "filter the rows which have to be deleted"
        where: CategoryBoolExp!
    ): CategoryMutationResponse
    "delete single row from the table: \"category\""
    deleteCategoryByPk(categoryId: uuid!): Category
    "delete data from the table: \"credit_card_detail\""
    deleteCreditCardDetail(
        "filter the rows which have to be deleted"
        where: CreditCardDetailBoolExp!
    ): CreditCardDetailMutationResponse
    "delete single row from the table: \"credit_card_detail\""
    deleteCreditCardDetailByPk(id: uuid!): CreditCardDetail
    "delete data from the table: \"credit_card_summary\""
    deleteCreditCardSummary(
        "filter the rows which have to be deleted"
        where: CreditCardSummaryBoolExp!
    ): CreditCardSummaryMutationResponse
    "delete single row from the table: \"credit_card_summary\""
    deleteCreditCardSummaryByPk(id: uuid!): CreditCardSummary
    "delete data from the table: \"daily_detail\""
    deleteDailyDetail(
        "filter the rows which have to be deleted"
        where: DailyDetailBoolExp!
    ): DailyDetailMutationResponse
    "delete single row from the table: \"daily_detail\""
    deleteDailyDetailByPk(id: uuid!): DailyDetail
    "delete data from the table: \"genre\""
    deleteGenre(
        "filter the rows which have to be deleted"
        where: GenreBoolExp!
    ): GenreMutationResponse
    "delete single row from the table: \"genre\""
    deleteGenreByPk(genreId: uuid!): Genre
    "delete data from the table: \"group\""
    deleteGroup(
        "filter the rows which have to be deleted"
        where: GroupBoolExp!
    ): GroupMutationResponse
    "delete data from the table: \"group_application\""
    deleteGroupApplication(
        "filter the rows which have to be deleted"
        where: GroupApplicationBoolExp!
    ): GroupApplicationMutationResponse
    "delete single row from the table: \"group_application\""
    deleteGroupApplicationByPk(groupApplicationId: uuid!): GroupApplication
    "delete single row from the table: \"group\""
    deleteGroupByPk(groupId: uuid!): Group
    "delete data from the table: \"group_role\""
    deleteGroupRole(
        "filter the rows which have to be deleted"
        where: GroupRoleBoolExp!
    ): GroupRoleMutationResponse
    "delete single row from the table: \"group_role\""
    deleteGroupRoleByPk(groupRoleId: uuid!): GroupRole
    "delete data from the table: \"helper_kids.exchange_item\""
    deleteHelperKidsExchangeItem(
        "filter the rows which have to be deleted"
        where: HelperKidsExchangeItemBoolExp!
    ): HelperKidsExchangeItemMutationResponse
    "delete single row from the table: \"helper_kids.exchange_item\""
    deleteHelperKidsExchangeItemByPk(
        "ID"
        exchangeItemId: uuid!
    ): HelperKidsExchangeItem
    "delete data from the table: \"helper_kids.help_item\""
    deleteHelperKidsHelpItem(
        "filter the rows which have to be deleted"
        where: HelperKidsHelpItemBoolExp!
    ): HelperKidsHelpItemMutationResponse
    "delete single row from the table: \"helper_kids.help_item\""
    deleteHelperKidsHelpItemByPk(
        "ID"
        helpItemId: uuid!
    ): HelperKidsHelpItem
    "delete data from the table: \"helper_kids.help_point_earned_achievement\""
    deleteHelperKidsHelpPointEarnedAchievement(
        "filter the rows which have to be deleted"
        where: HelperKidsHelpPointEarnedAchievementBoolExp!
    ): HelperKidsHelpPointEarnedAchievementMutationResponse
    "delete single row from the table: \"helper_kids.help_point_earned_achievement\""
    deleteHelperKidsHelpPointEarnedAchievementByPk(
        "ID"
        helpPointEarnedAchievementId: uuid!
    ): HelperKidsHelpPointEarnedAchievement
    "delete data from the table: \"helper_kids.help_point_earned_detail\""
    deleteHelperKidsHelpPointEarnedDetail(
        "filter the rows which have to be deleted"
        where: HelperKidsHelpPointEarnedDetailBoolExp!
    ): HelperKidsHelpPointEarnedDetailMutationResponse
    "delete single row from the table: \"helper_kids.help_point_earned_detail\""
    deleteHelperKidsHelpPointEarnedDetailByPk(
        "ID"
        helpPointEarnedDetailId: uuid!
    ): HelperKidsHelpPointEarnedDetail
    "delete data from the table: \"helper_kids.help_point_exchanged_achievement\""
    deleteHelperKidsHelpPointExchangedAchievement(
        "filter the rows which have to be deleted"
        where: HelperKidsHelpPointExchangedAchievementBoolExp!
    ): HelperKidsHelpPointExchangedAchievementMutationResponse
    "delete single row from the table: \"helper_kids.help_point_exchanged_achievement\""
    deleteHelperKidsHelpPointExchangedAchievementByPk(
        "ID"
        helpPointExchangedAchievementId: uuid!
    ): HelperKidsHelpPointExchangedAchievement
    "delete data from the table: \"helper_kids.helper_kid\""
    deleteHelperKidsHelperKid(
        "filter the rows which have to be deleted"
        where: HelperKidsHelperKidBoolExp!
    ): HelperKidsHelperKidMutationResponse
    "delete single row from the table: \"helper_kids.helper_kid\""
    deleteHelperKidsHelperKidByPk(
        "ID"
        helperKidId: uuid!
    ): HelperKidsHelperKid
    "delete data from the table: \"helper_kids.helper_kid_parent\""
    deleteHelperKidsHelperKidParent(
        "filter the rows which have to be deleted"
        where: HelperKidsHelperKidParentBoolExp!
    ): HelperKidsHelperKidParentMutationResponse
    "delete single row from the table: \"helper_kids.helper_kid_parent\""
    deleteHelperKidsHelperKidParentByPk(helperKidParentId: uuid!): HelperKidsHelperKidParent
    "delete data from the table: \"helper_kids.helper_kid_point\""
    deleteHelperKidsHelperKidPoint(
        "filter the rows which have to be deleted"
        where: HelperKidsHelperKidPointBoolExp!
    ): HelperKidsHelperKidPointMutationResponse
    "delete single row from the table: \"helper_kids.helper_kid_point\""
    deleteHelperKidsHelperKidPointByPk(
        "お手伝いキッズID"
        helperKidId: uuid!
    ): HelperKidsHelperKidPoint
    "delete data from the table: \"import_file_history\""
    deleteImportFileHistory(
        "filter the rows which have to be deleted"
        where: ImportFileHistoryBoolExp!
    ): ImportFileHistoryMutationResponse
    "delete single row from the table: \"import_file_history\""
    deleteImportFileHistoryByPk(id: uuid!): ImportFileHistory
    "delete data from the table: \"summary_category_by_group\""
    deleteSummaryCategoryByGroup(
        "filter the rows which have to be deleted"
        where: SummaryCategoryByGroupBoolExp!
    ): SummaryCategoryByGroupMutationResponse
    "delete single row from the table: \"summary_category_by_group\""
    deleteSummaryCategoryByGroupByPk(id: uuid!): SummaryCategoryByGroup
    "delete data from the table: \"summary_category_by_user\""
    deleteSummaryCategoryByUser(
        "filter the rows which have to be deleted"
        where: SummaryCategoryByUserBoolExp!
    ): SummaryCategoryByUserMutationResponse
    "delete single row from the table: \"summary_category_by_user\""
    deleteSummaryCategoryByUserByPk(id: uuid!): SummaryCategoryByUser
    "delete data from the table: \"transfer_category\""
    deleteTransferCategory(
        "filter the rows which have to be deleted"
        where: TransferCategoryBoolExp!
    ): TransferCategoryMutationResponse
    "delete single row from the table: \"transfer_category\""
    deleteTransferCategoryByPk(
        "グループID"
        groupId: uuid!
    ): TransferCategory
    "delete data from the table: \"user\""
    deleteUser(
        "filter the rows which have to be deleted"
        where: UserBoolExp!
    ): UserMutationResponse
    "delete single row from the table: \"user\""
    deleteUserByPk(userId: uuid!): User
    "insert data into the table: \"account\""
    insertAccount(
        "the rows to be inserted"
        objects: [AccountInsertInput!]!,
        "upsert condition"
        onConflict: AccountOnConflict
    ): AccountMutationResponse
    "insert a single row into the table: \"account\""
    insertAccountOne(
        "the row to be inserted"
        object: AccountInsertInput!,
        "upsert condition"
        onConflict: AccountOnConflict
    ): Account
    "insert data into the table: \"affiliation\""
    insertAffiliation(
        "the rows to be inserted"
        objects: [AffiliationInsertInput!]!,
        "upsert condition"
        onConflict: AffiliationOnConflict
    ): AffiliationMutationResponse
    "insert a single row into the table: \"affiliation\""
    insertAffiliationOne(
        "the row to be inserted"
        object: AffiliationInsertInput!,
        "upsert condition"
        onConflict: AffiliationOnConflict
    ): Affiliation
    "insert data into the table: \"application\""
    insertApplication(
        "the rows to be inserted"
        objects: [ApplicationInsertInput!]!,
        "upsert condition"
        onConflict: ApplicationOnConflict
    ): ApplicationMutationResponse
    "insert a single row into the table: \"application\""
    insertApplicationOne(
        "the row to be inserted"
        object: ApplicationInsertInput!,
        "upsert condition"
        onConflict: ApplicationOnConflict
    ): Application
    "insert data into the table: \"category\""
    insertCategory(
        "the rows to be inserted"
        objects: [CategoryInsertInput!]!,
        "upsert condition"
        onConflict: CategoryOnConflict
    ): CategoryMutationResponse
    "insert a single row into the table: \"category\""
    insertCategoryOne(
        "the row to be inserted"
        object: CategoryInsertInput!,
        "upsert condition"
        onConflict: CategoryOnConflict
    ): Category
    "insert data into the table: \"credit_card_detail\""
    insertCreditCardDetail(
        "the rows to be inserted"
        objects: [CreditCardDetailInsertInput!]!,
        "upsert condition"
        onConflict: CreditCardDetailOnConflict
    ): CreditCardDetailMutationResponse
    "insert a single row into the table: \"credit_card_detail\""
    insertCreditCardDetailOne(
        "the row to be inserted"
        object: CreditCardDetailInsertInput!,
        "upsert condition"
        onConflict: CreditCardDetailOnConflict
    ): CreditCardDetail
    "insert data into the table: \"credit_card_summary\""
    insertCreditCardSummary(
        "the rows to be inserted"
        objects: [CreditCardSummaryInsertInput!]!,
        "upsert condition"
        onConflict: CreditCardSummaryOnConflict
    ): CreditCardSummaryMutationResponse
    "insert a single row into the table: \"credit_card_summary\""
    insertCreditCardSummaryOne(
        "the row to be inserted"
        object: CreditCardSummaryInsertInput!,
        "upsert condition"
        onConflict: CreditCardSummaryOnConflict
    ): CreditCardSummary
    "insert data into the table: \"daily_detail\""
    insertDailyDetail(
        "the rows to be inserted"
        objects: [DailyDetailInsertInput!]!,
        "upsert condition"
        onConflict: DailyDetailOnConflict
    ): DailyDetailMutationResponse
    "insert a single row into the table: \"daily_detail\""
    insertDailyDetailOne(
        "the row to be inserted"
        object: DailyDetailInsertInput!,
        "upsert condition"
        onConflict: DailyDetailOnConflict
    ): DailyDetail
    "insert data into the table: \"genre\""
    insertGenre(
        "the rows to be inserted"
        objects: [GenreInsertInput!]!,
        "upsert condition"
        onConflict: GenreOnConflict
    ): GenreMutationResponse
    "insert a single row into the table: \"genre\""
    insertGenreOne(
        "the row to be inserted"
        object: GenreInsertInput!,
        "upsert condition"
        onConflict: GenreOnConflict
    ): Genre
    "insert data into the table: \"group\""
    insertGroup(
        "the rows to be inserted"
        objects: [GroupInsertInput!]!,
        "upsert condition"
        onConflict: GroupOnConflict
    ): GroupMutationResponse
    "insert data into the table: \"group_application\""
    insertGroupApplication(
        "the rows to be inserted"
        objects: [GroupApplicationInsertInput!]!,
        "upsert condition"
        onConflict: GroupApplicationOnConflict
    ): GroupApplicationMutationResponse
    "insert a single row into the table: \"group_application\""
    insertGroupApplicationOne(
        "the row to be inserted"
        object: GroupApplicationInsertInput!,
        "upsert condition"
        onConflict: GroupApplicationOnConflict
    ): GroupApplication
    "insert a single row into the table: \"group\""
    insertGroupOne(
        "the row to be inserted"
        object: GroupInsertInput!,
        "upsert condition"
        onConflict: GroupOnConflict
    ): Group
    "insert data into the table: \"group_role\""
    insertGroupRole(
        "the rows to be inserted"
        objects: [GroupRoleInsertInput!]!,
        "upsert condition"
        onConflict: GroupRoleOnConflict
    ): GroupRoleMutationResponse
    "insert a single row into the table: \"group_role\""
    insertGroupRoleOne(
        "the row to be inserted"
        object: GroupRoleInsertInput!,
        "upsert condition"
        onConflict: GroupRoleOnConflict
    ): GroupRole
    "insert data into the table: \"helper_kids.exchange_item\""
    insertHelperKidsExchangeItem(
        "the rows to be inserted"
        objects: [HelperKidsExchangeItemInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsExchangeItemOnConflict
    ): HelperKidsExchangeItemMutationResponse
    "insert a single row into the table: \"helper_kids.exchange_item\""
    insertHelperKidsExchangeItemOne(
        "the row to be inserted"
        object: HelperKidsExchangeItemInsertInput!,
        "upsert condition"
        onConflict: HelperKidsExchangeItemOnConflict
    ): HelperKidsExchangeItem
    "insert data into the table: \"helper_kids.help_item\""
    insertHelperKidsHelpItem(
        "the rows to be inserted"
        objects: [HelperKidsHelpItemInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpItemOnConflict
    ): HelperKidsHelpItemMutationResponse
    "insert a single row into the table: \"helper_kids.help_item\""
    insertHelperKidsHelpItemOne(
        "the row to be inserted"
        object: HelperKidsHelpItemInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpItemOnConflict
    ): HelperKidsHelpItem
    "insert data into the table: \"helper_kids.help_point_earned_achievement\""
    insertHelperKidsHelpPointEarnedAchievement(
        "the rows to be inserted"
        objects: [HelperKidsHelpPointEarnedAchievementInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
    ): HelperKidsHelpPointEarnedAchievementMutationResponse
    "insert a single row into the table: \"helper_kids.help_point_earned_achievement\""
    insertHelperKidsHelpPointEarnedAchievementOne(
        "the row to be inserted"
        object: HelperKidsHelpPointEarnedAchievementInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
    ): HelperKidsHelpPointEarnedAchievement
    "insert data into the table: \"helper_kids.help_point_earned_detail\""
    insertHelperKidsHelpPointEarnedDetail(
        "the rows to be inserted"
        objects: [HelperKidsHelpPointEarnedDetailInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedDetailOnConflict
    ): HelperKidsHelpPointEarnedDetailMutationResponse
    "insert a single row into the table: \"helper_kids.help_point_earned_detail\""
    insertHelperKidsHelpPointEarnedDetailOne(
        "the row to be inserted"
        object: HelperKidsHelpPointEarnedDetailInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpPointEarnedDetailOnConflict
    ): HelperKidsHelpPointEarnedDetail
    "insert data into the table: \"helper_kids.help_point_exchanged_achievement\""
    insertHelperKidsHelpPointExchangedAchievement(
        "the rows to be inserted"
        objects: [HelperKidsHelpPointExchangedAchievementInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelpPointExchangedAchievementOnConflict
    ): HelperKidsHelpPointExchangedAchievementMutationResponse
    "insert a single row into the table: \"helper_kids.help_point_exchanged_achievement\""
    insertHelperKidsHelpPointExchangedAchievementOne(
        "the row to be inserted"
        object: HelperKidsHelpPointExchangedAchievementInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelpPointExchangedAchievementOnConflict
    ): HelperKidsHelpPointExchangedAchievement
    "insert data into the table: \"helper_kids.helper_kid\""
    insertHelperKidsHelperKid(
        "the rows to be inserted"
        objects: [HelperKidsHelperKidInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelperKidOnConflict
    ): HelperKidsHelperKidMutationResponse
    "insert a single row into the table: \"helper_kids.helper_kid\""
    insertHelperKidsHelperKidOne(
        "the row to be inserted"
        object: HelperKidsHelperKidInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelperKidOnConflict
    ): HelperKidsHelperKid
    "insert data into the table: \"helper_kids.helper_kid_parent\""
    insertHelperKidsHelperKidParent(
        "the rows to be inserted"
        objects: [HelperKidsHelperKidParentInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelperKidParentOnConflict
    ): HelperKidsHelperKidParentMutationResponse
    "insert a single row into the table: \"helper_kids.helper_kid_parent\""
    insertHelperKidsHelperKidParentOne(
        "the row to be inserted"
        object: HelperKidsHelperKidParentInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelperKidParentOnConflict
    ): HelperKidsHelperKidParent
    "insert data into the table: \"helper_kids.helper_kid_point\""
    insertHelperKidsHelperKidPoint(
        "the rows to be inserted"
        objects: [HelperKidsHelperKidPointInsertInput!]!,
        "upsert condition"
        onConflict: HelperKidsHelperKidPointOnConflict
    ): HelperKidsHelperKidPointMutationResponse
    "insert a single row into the table: \"helper_kids.helper_kid_point\""
    insertHelperKidsHelperKidPointOne(
        "the row to be inserted"
        object: HelperKidsHelperKidPointInsertInput!,
        "upsert condition"
        onConflict: HelperKidsHelperKidPointOnConflict
    ): HelperKidsHelperKidPoint
    "insert data into the table: \"import_file_history\""
    insertImportFileHistory(
        "the rows to be inserted"
        objects: [ImportFileHistoryInsertInput!]!,
        "upsert condition"
        onConflict: ImportFileHistoryOnConflict
    ): ImportFileHistoryMutationResponse
    "insert a single row into the table: \"import_file_history\""
    insertImportFileHistoryOne(
        "the row to be inserted"
        object: ImportFileHistoryInsertInput!,
        "upsert condition"
        onConflict: ImportFileHistoryOnConflict
    ): ImportFileHistory
    "insert data into the table: \"summary_category_by_group\""
    insertSummaryCategoryByGroup(
        "the rows to be inserted"
        objects: [SummaryCategoryByGroupInsertInput!]!,
        "upsert condition"
        onConflict: SummaryCategoryByGroupOnConflict
    ): SummaryCategoryByGroupMutationResponse
    "insert a single row into the table: \"summary_category_by_group\""
    insertSummaryCategoryByGroupOne(
        "the row to be inserted"
        object: SummaryCategoryByGroupInsertInput!,
        "upsert condition"
        onConflict: SummaryCategoryByGroupOnConflict
    ): SummaryCategoryByGroup
    "insert data into the table: \"summary_category_by_user\""
    insertSummaryCategoryByUser(
        "the rows to be inserted"
        objects: [SummaryCategoryByUserInsertInput!]!,
        "upsert condition"
        onConflict: SummaryCategoryByUserOnConflict
    ): SummaryCategoryByUserMutationResponse
    "insert a single row into the table: \"summary_category_by_user\""
    insertSummaryCategoryByUserOne(
        "the row to be inserted"
        object: SummaryCategoryByUserInsertInput!,
        "upsert condition"
        onConflict: SummaryCategoryByUserOnConflict
    ): SummaryCategoryByUser
    "insert data into the table: \"transfer_category\""
    insertTransferCategory(
        "the rows to be inserted"
        objects: [TransferCategoryInsertInput!]!,
        "upsert condition"
        onConflict: TransferCategoryOnConflict
    ): TransferCategoryMutationResponse
    "insert a single row into the table: \"transfer_category\""
    insertTransferCategoryOne(
        "the row to be inserted"
        object: TransferCategoryInsertInput!,
        "upsert condition"
        onConflict: TransferCategoryOnConflict
    ): TransferCategory
    "insert data into the table: \"user\""
    insertUser(
        "the rows to be inserted"
        objects: [UserInsertInput!]!,
        "upsert condition"
        onConflict: UserOnConflict
    ): UserMutationResponse
    "insert a single row into the table: \"user\""
    insertUserOne(
        "the row to be inserted"
        object: UserInsertInput!,
        "upsert condition"
        onConflict: UserOnConflict
    ): User
    "update data of the table: \"account\""
    updateAccount(
        "increments the numeric columns with given value of the filtered values"
        _inc: AccountIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: AccountSetInput,
        "filter the rows which have to be updated"
        where: AccountBoolExp!
    ): AccountMutationResponse
    "update single row of the table: \"account\""
    updateAccountByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: AccountIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: AccountSetInput,
        pkColumns: AccountPkColumnsInput!
    ): Account
    "update multiples rows of table: \"account\""
    updateAccountMany(
        "updates to execute, in order"
        updates: [AccountUpdates!]!
    ): [AccountMutationResponse]
    "update data of the table: \"affiliation\""
    updateAffiliation(
        "sets the columns of the filtered rows to the given values"
        _set: AffiliationSetInput,
        "filter the rows which have to be updated"
        where: AffiliationBoolExp!
    ): AffiliationMutationResponse
    "update single row of the table: \"affiliation\""
    updateAffiliationByPk(
        "sets the columns of the filtered rows to the given values"
        _set: AffiliationSetInput,
        pkColumns: AffiliationPkColumnsInput!
    ): Affiliation
    "update multiples rows of table: \"affiliation\""
    updateAffiliationMany(
        "updates to execute, in order"
        updates: [AffiliationUpdates!]!
    ): [AffiliationMutationResponse]
    "update data of the table: \"application\""
    updateApplication(
        "sets the columns of the filtered rows to the given values"
        _set: ApplicationSetInput,
        "filter the rows which have to be updated"
        where: ApplicationBoolExp!
    ): ApplicationMutationResponse
    "update single row of the table: \"application\""
    updateApplicationByPk(
        "sets the columns of the filtered rows to the given values"
        _set: ApplicationSetInput,
        pkColumns: ApplicationPkColumnsInput!
    ): Application
    "update multiples rows of table: \"application\""
    updateApplicationMany(
        "updates to execute, in order"
        updates: [ApplicationUpdates!]!
    ): [ApplicationMutationResponse]
    "update data of the table: \"category\""
    updateCategory(
        "increments the numeric columns with given value of the filtered values"
        _inc: CategoryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CategorySetInput,
        "filter the rows which have to be updated"
        where: CategoryBoolExp!
    ): CategoryMutationResponse
    "update single row of the table: \"category\""
    updateCategoryByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: CategoryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CategorySetInput,
        pkColumns: CategoryPkColumnsInput!
    ): Category
    "update multiples rows of table: \"category\""
    updateCategoryMany(
        "updates to execute, in order"
        updates: [CategoryUpdates!]!
    ): [CategoryMutationResponse]
    "update data of the table: \"credit_card_detail\""
    updateCreditCardDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: CreditCardDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CreditCardDetailSetInput,
        "filter the rows which have to be updated"
        where: CreditCardDetailBoolExp!
    ): CreditCardDetailMutationResponse
    "update single row of the table: \"credit_card_detail\""
    updateCreditCardDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: CreditCardDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CreditCardDetailSetInput,
        pkColumns: CreditCardDetailPkColumnsInput!
    ): CreditCardDetail
    "update multiples rows of table: \"credit_card_detail\""
    updateCreditCardDetailMany(
        "updates to execute, in order"
        updates: [CreditCardDetailUpdates!]!
    ): [CreditCardDetailMutationResponse]
    "update data of the table: \"credit_card_summary\""
    updateCreditCardSummary(
        "increments the numeric columns with given value of the filtered values"
        _inc: CreditCardSummaryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CreditCardSummarySetInput,
        "filter the rows which have to be updated"
        where: CreditCardSummaryBoolExp!
    ): CreditCardSummaryMutationResponse
    "update single row of the table: \"credit_card_summary\""
    updateCreditCardSummaryByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: CreditCardSummaryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: CreditCardSummarySetInput,
        pkColumns: CreditCardSummaryPkColumnsInput!
    ): CreditCardSummary
    "update multiples rows of table: \"credit_card_summary\""
    updateCreditCardSummaryMany(
        "updates to execute, in order"
        updates: [CreditCardSummaryUpdates!]!
    ): [CreditCardSummaryMutationResponse]
    "update data of the table: \"daily_detail\""
    updateDailyDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: DailyDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: DailyDetailSetInput,
        "filter the rows which have to be updated"
        where: DailyDetailBoolExp!
    ): DailyDetailMutationResponse
    "update single row of the table: \"daily_detail\""
    updateDailyDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: DailyDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: DailyDetailSetInput,
        pkColumns: DailyDetailPkColumnsInput!
    ): DailyDetail
    "update multiples rows of table: \"daily_detail\""
    updateDailyDetailMany(
        "updates to execute, in order"
        updates: [DailyDetailUpdates!]!
    ): [DailyDetailMutationResponse]
    "update data of the table: \"genre\""
    updateGenre(
        "increments the numeric columns with given value of the filtered values"
        _inc: GenreIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: GenreSetInput,
        "filter the rows which have to be updated"
        where: GenreBoolExp!
    ): GenreMutationResponse
    "update single row of the table: \"genre\""
    updateGenreByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: GenreIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: GenreSetInput,
        pkColumns: GenrePkColumnsInput!
    ): Genre
    "update multiples rows of table: \"genre\""
    updateGenreMany(
        "updates to execute, in order"
        updates: [GenreUpdates!]!
    ): [GenreMutationResponse]
    "update data of the table: \"group\""
    updateGroup(
        "sets the columns of the filtered rows to the given values"
        _set: GroupSetInput,
        "filter the rows which have to be updated"
        where: GroupBoolExp!
    ): GroupMutationResponse
    "update data of the table: \"group_application\""
    updateGroupApplication(
        "sets the columns of the filtered rows to the given values"
        _set: GroupApplicationSetInput,
        "filter the rows which have to be updated"
        where: GroupApplicationBoolExp!
    ): GroupApplicationMutationResponse
    "update single row of the table: \"group_application\""
    updateGroupApplicationByPk(
        "sets the columns of the filtered rows to the given values"
        _set: GroupApplicationSetInput,
        pkColumns: GroupApplicationPkColumnsInput!
    ): GroupApplication
    "update multiples rows of table: \"group_application\""
    updateGroupApplicationMany(
        "updates to execute, in order"
        updates: [GroupApplicationUpdates!]!
    ): [GroupApplicationMutationResponse]
    "update single row of the table: \"group\""
    updateGroupByPk(
        "sets the columns of the filtered rows to the given values"
        _set: GroupSetInput,
        pkColumns: GroupPkColumnsInput!
    ): Group
    "update multiples rows of table: \"group\""
    updateGroupMany(
        "updates to execute, in order"
        updates: [GroupUpdates!]!
    ): [GroupMutationResponse]
    "update data of the table: \"group_role\""
    updateGroupRole(
        "sets the columns of the filtered rows to the given values"
        _set: GroupRoleSetInput,
        "filter the rows which have to be updated"
        where: GroupRoleBoolExp!
    ): GroupRoleMutationResponse
    "update single row of the table: \"group_role\""
    updateGroupRoleByPk(
        "sets the columns of the filtered rows to the given values"
        _set: GroupRoleSetInput,
        pkColumns: GroupRolePkColumnsInput!
    ): GroupRole
    "update multiples rows of table: \"group_role\""
    updateGroupRoleMany(
        "updates to execute, in order"
        updates: [GroupRoleUpdates!]!
    ): [GroupRoleMutationResponse]
    "update data of the table: \"helper_kids.exchange_item\""
    updateHelperKidsExchangeItem(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsExchangeItemIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsExchangeItemSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsExchangeItemBoolExp!
    ): HelperKidsExchangeItemMutationResponse
    "update single row of the table: \"helper_kids.exchange_item\""
    updateHelperKidsExchangeItemByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsExchangeItemIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsExchangeItemSetInput,
        pkColumns: HelperKidsExchangeItemPkColumnsInput!
    ): HelperKidsExchangeItem
    "update multiples rows of table: \"helper_kids.exchange_item\""
    updateHelperKidsExchangeItemMany(
        "updates to execute, in order"
        updates: [HelperKidsExchangeItemUpdates!]!
    ): [HelperKidsExchangeItemMutationResponse]
    "update data of the table: \"helper_kids.help_item\""
    updateHelperKidsHelpItem(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpItemIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpItemSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelpItemBoolExp!
    ): HelperKidsHelpItemMutationResponse
    "update single row of the table: \"helper_kids.help_item\""
    updateHelperKidsHelpItemByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpItemIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpItemSetInput,
        pkColumns: HelperKidsHelpItemPkColumnsInput!
    ): HelperKidsHelpItem
    "update multiples rows of table: \"helper_kids.help_item\""
    updateHelperKidsHelpItemMany(
        "updates to execute, in order"
        updates: [HelperKidsHelpItemUpdates!]!
    ): [HelperKidsHelpItemMutationResponse]
    "update data of the table: \"helper_kids.help_point_earned_achievement\""
    updateHelperKidsHelpPointEarnedAchievement(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpPointEarnedAchievementIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpPointEarnedAchievementSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelpPointEarnedAchievementBoolExp!
    ): HelperKidsHelpPointEarnedAchievementMutationResponse
    "update single row of the table: \"helper_kids.help_point_earned_achievement\""
    updateHelperKidsHelpPointEarnedAchievementByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpPointEarnedAchievementIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpPointEarnedAchievementSetInput,
        pkColumns: HelperKidsHelpPointEarnedAchievementPkColumnsInput!
    ): HelperKidsHelpPointEarnedAchievement
    "update multiples rows of table: \"helper_kids.help_point_earned_achievement\""
    updateHelperKidsHelpPointEarnedAchievementMany(
        "updates to execute, in order"
        updates: [HelperKidsHelpPointEarnedAchievementUpdates!]!
    ): [HelperKidsHelpPointEarnedAchievementMutationResponse]
    "update data of the table: \"helper_kids.help_point_earned_detail\""
    updateHelperKidsHelpPointEarnedDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpPointEarnedDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpPointEarnedDetailSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelpPointEarnedDetailBoolExp!
    ): HelperKidsHelpPointEarnedDetailMutationResponse
    "update single row of the table: \"helper_kids.help_point_earned_detail\""
    updateHelperKidsHelpPointEarnedDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpPointEarnedDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpPointEarnedDetailSetInput,
        pkColumns: HelperKidsHelpPointEarnedDetailPkColumnsInput!
    ): HelperKidsHelpPointEarnedDetail
    "update multiples rows of table: \"helper_kids.help_point_earned_detail\""
    updateHelperKidsHelpPointEarnedDetailMany(
        "updates to execute, in order"
        updates: [HelperKidsHelpPointEarnedDetailUpdates!]!
    ): [HelperKidsHelpPointEarnedDetailMutationResponse]
    "update data of the table: \"helper_kids.help_point_exchanged_achievement\""
    updateHelperKidsHelpPointExchangedAchievement(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpPointExchangedAchievementIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpPointExchangedAchievementSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelpPointExchangedAchievementBoolExp!
    ): HelperKidsHelpPointExchangedAchievementMutationResponse
    "update single row of the table: \"helper_kids.help_point_exchanged_achievement\""
    updateHelperKidsHelpPointExchangedAchievementByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelpPointExchangedAchievementIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelpPointExchangedAchievementSetInput,
        pkColumns: HelperKidsHelpPointExchangedAchievementPkColumnsInput!
    ): HelperKidsHelpPointExchangedAchievement
    "update multiples rows of table: \"helper_kids.help_point_exchanged_achievement\""
    updateHelperKidsHelpPointExchangedAchievementMany(
        "updates to execute, in order"
        updates: [HelperKidsHelpPointExchangedAchievementUpdates!]!
    ): [HelperKidsHelpPointExchangedAchievementMutationResponse]
    "update data of the table: \"helper_kids.helper_kid\""
    updateHelperKidsHelperKid(
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelperKidSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelperKidBoolExp!
    ): HelperKidsHelperKidMutationResponse
    "update single row of the table: \"helper_kids.helper_kid\""
    updateHelperKidsHelperKidByPk(
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelperKidSetInput,
        pkColumns: HelperKidsHelperKidPkColumnsInput!
    ): HelperKidsHelperKid
    "update multiples rows of table: \"helper_kids.helper_kid\""
    updateHelperKidsHelperKidMany(
        "updates to execute, in order"
        updates: [HelperKidsHelperKidUpdates!]!
    ): [HelperKidsHelperKidMutationResponse]
    "update data of the table: \"helper_kids.helper_kid_parent\""
    updateHelperKidsHelperKidParent(
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelperKidParentSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelperKidParentBoolExp!
    ): HelperKidsHelperKidParentMutationResponse
    "update single row of the table: \"helper_kids.helper_kid_parent\""
    updateHelperKidsHelperKidParentByPk(
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelperKidParentSetInput,
        pkColumns: HelperKidsHelperKidParentPkColumnsInput!
    ): HelperKidsHelperKidParent
    "update multiples rows of table: \"helper_kids.helper_kid_parent\""
    updateHelperKidsHelperKidParentMany(
        "updates to execute, in order"
        updates: [HelperKidsHelperKidParentUpdates!]!
    ): [HelperKidsHelperKidParentMutationResponse]
    "update data of the table: \"helper_kids.helper_kid_point\""
    updateHelperKidsHelperKidPoint(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelperKidPointIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelperKidPointSetInput,
        "filter the rows which have to be updated"
        where: HelperKidsHelperKidPointBoolExp!
    ): HelperKidsHelperKidPointMutationResponse
    "update single row of the table: \"helper_kids.helper_kid_point\""
    updateHelperKidsHelperKidPointByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HelperKidsHelperKidPointIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HelperKidsHelperKidPointSetInput,
        pkColumns: HelperKidsHelperKidPointPkColumnsInput!
    ): HelperKidsHelperKidPoint
    "update multiples rows of table: \"helper_kids.helper_kid_point\""
    updateHelperKidsHelperKidPointMany(
        "updates to execute, in order"
        updates: [HelperKidsHelperKidPointUpdates!]!
    ): [HelperKidsHelperKidPointMutationResponse]
    "update data of the table: \"import_file_history\""
    updateImportFileHistory(
        "sets the columns of the filtered rows to the given values"
        _set: ImportFileHistorySetInput,
        "filter the rows which have to be updated"
        where: ImportFileHistoryBoolExp!
    ): ImportFileHistoryMutationResponse
    "update single row of the table: \"import_file_history\""
    updateImportFileHistoryByPk(
        "sets the columns of the filtered rows to the given values"
        _set: ImportFileHistorySetInput,
        pkColumns: ImportFileHistoryPkColumnsInput!
    ): ImportFileHistory
    "update multiples rows of table: \"import_file_history\""
    updateImportFileHistoryMany(
        "updates to execute, in order"
        updates: [ImportFileHistoryUpdates!]!
    ): [ImportFileHistoryMutationResponse]
    "update data of the table: \"summary_category_by_group\""
    updateSummaryCategoryByGroup(
        "increments the numeric columns with given value of the filtered values"
        _inc: SummaryCategoryByGroupIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: SummaryCategoryByGroupSetInput,
        "filter the rows which have to be updated"
        where: SummaryCategoryByGroupBoolExp!
    ): SummaryCategoryByGroupMutationResponse
    "update single row of the table: \"summary_category_by_group\""
    updateSummaryCategoryByGroupByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: SummaryCategoryByGroupIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: SummaryCategoryByGroupSetInput,
        pkColumns: SummaryCategoryByGroupPkColumnsInput!
    ): SummaryCategoryByGroup
    "update multiples rows of table: \"summary_category_by_group\""
    updateSummaryCategoryByGroupMany(
        "updates to execute, in order"
        updates: [SummaryCategoryByGroupUpdates!]!
    ): [SummaryCategoryByGroupMutationResponse]
    "update data of the table: \"summary_category_by_user\""
    updateSummaryCategoryByUser(
        "increments the numeric columns with given value of the filtered values"
        _inc: SummaryCategoryByUserIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: SummaryCategoryByUserSetInput,
        "filter the rows which have to be updated"
        where: SummaryCategoryByUserBoolExp!
    ): SummaryCategoryByUserMutationResponse
    "update single row of the table: \"summary_category_by_user\""
    updateSummaryCategoryByUserByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: SummaryCategoryByUserIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: SummaryCategoryByUserSetInput,
        pkColumns: SummaryCategoryByUserPkColumnsInput!
    ): SummaryCategoryByUser
    "update multiples rows of table: \"summary_category_by_user\""
    updateSummaryCategoryByUserMany(
        "updates to execute, in order"
        updates: [SummaryCategoryByUserUpdates!]!
    ): [SummaryCategoryByUserMutationResponse]
    "update data of the table: \"transfer_category\""
    updateTransferCategory(
        "sets the columns of the filtered rows to the given values"
        _set: TransferCategorySetInput,
        "filter the rows which have to be updated"
        where: TransferCategoryBoolExp!
    ): TransferCategoryMutationResponse
    "update single row of the table: \"transfer_category\""
    updateTransferCategoryByPk(
        "sets the columns of the filtered rows to the given values"
        _set: TransferCategorySetInput,
        pkColumns: TransferCategoryPkColumnsInput!
    ): TransferCategory
    "update multiples rows of table: \"transfer_category\""
    updateTransferCategoryMany(
        "updates to execute, in order"
        updates: [TransferCategoryUpdates!]!
    ): [TransferCategoryMutationResponse]
    "update data of the table: \"user\""
    updateUser(
        "increments the numeric columns with given value of the filtered values"
        _inc: UserIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: UserSetInput,
        "filter the rows which have to be updated"
        where: UserBoolExp!
    ): UserMutationResponse
    "update single row of the table: \"user\""
    updateUserByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: UserIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: UserSetInput,
        pkColumns: UserPkColumnsInput!
    ): User
    "update multiples rows of table: \"user\""
    updateUserMany(
        "updates to execute, in order"
        updates: [UserUpdates!]!
    ): [UserMutationResponse]
}

type query_root {
    "fetch data from the table: \"account\""
    account(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "fetch aggregated fields from the table: \"account\""
    accountAggregate(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): AccountAggregate!
    "fetch data from the table: \"account\" using primary key columns"
    accountByPk(accountId: uuid!): Account
    "execute function \"account_total\" which returns \"total_by_account_view\""
    accountTotal(
        "input parameters for function \"accountTotal\""
        args: accountTotalArgs!,
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): [TotalByAccountView!]!
    "execute function \"account_total\" and query aggregates on result of table type \"total_by_account_view\""
    accountTotalAggregate(
        "input parameters for function \"accountTotalAggregate\""
        args: accountTotalArgs!,
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): TotalByAccountViewAggregate!
    "fetch data from the table: \"affiliation\""
    affiliation(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch aggregated fields from the table: \"affiliation\""
    affiliationAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "fetch data from the table: \"affiliation\" using primary key columns"
    affiliationByPk(affiliationId: uuid!): Affiliation
    "fetch data from the table: \"application\""
    application(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch aggregated fields from the table: \"application\""
    applicationAggregate(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): ApplicationAggregate!
    "fetch data from the table: \"application\" using primary key columns"
    applicationByPk(applicationId: uuid!): Application
    "fetch data from the table: \"category\""
    category(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "fetch aggregated fields from the table: \"category\""
    categoryAggregate(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): CategoryAggregate!
    "fetch data from the table: \"category\" using primary key columns"
    categoryByPk(categoryId: uuid!): Category
    "execute function \"category_total_by_month\" which returns \"total_by_category_view\""
    categoryTotalByMonth(
        "input parameters for function \"categoryTotalByMonth\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "execute function \"category_total_by_month\" and query aggregates on result of table type \"total_by_category_view\""
    categoryTotalByMonthAggregate(
        "input parameters for function \"categoryTotalByMonthAggregate\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): TotalByCategoryViewAggregate!
    "fetch data from the table: \"credit_card_detail\""
    creditCardDetail(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "fetch aggregated fields from the table: \"credit_card_detail\""
    creditCardDetailAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): CreditCardDetailAggregate!
    "fetch data from the table: \"credit_card_detail\" using primary key columns"
    creditCardDetailByPk(id: uuid!): CreditCardDetail
    "fetch data from the table: \"credit_card_summary\""
    creditCardSummary(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "fetch aggregated fields from the table: \"credit_card_summary\""
    creditCardSummaryAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): CreditCardSummaryAggregate!
    "fetch data from the table: \"credit_card_summary\" using primary key columns"
    creditCardSummaryByPk(id: uuid!): CreditCardSummary
    "fetch data from the table: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountView(
        "distinct select on columns"
        distinctOn: [CreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): [CreditCardSummaryTotalByAccountView!]!
    "fetch aggregated fields from the table: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountViewAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): CreditCardSummaryTotalByAccountViewAggregate!
    "fetch data from the table: \"daily_detail\""
    dailyDetail(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "fetch aggregated fields from the table: \"daily_detail\""
    dailyDetailAggregate(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "execute function \"daily_detail_by_date\" which returns \"daily_detail\""
    dailyDetailByDate(
        "input parameters for function \"dailyDetailByDate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "execute function \"daily_detail_by_date\" and query aggregates on result of table type \"daily_detail\""
    dailyDetailByDateAggregate(
        "input parameters for function \"dailyDetailByDateAggregate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "fetch data from the table: \"daily_detail\" using primary key columns"
    dailyDetailByPk(id: uuid!): DailyDetail
    "fetch data from the table: \"daily_total_view\""
    dailyTotalView(
        "distinct select on columns"
        distinctOn: [DailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyTotalViewOrderBy!],
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): [DailyTotalView!]!
    "fetch aggregated fields from the table: \"daily_total_view\""
    dailyTotalViewAggregate(
        "distinct select on columns"
        distinctOn: [DailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyTotalViewOrderBy!],
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): DailyTotalViewAggregate!
    "fetch data from the table: \"genre\""
    genre(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "fetch aggregated fields from the table: \"genre\""
    genreAggregate(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): GenreAggregate!
    "fetch data from the table: \"genre\" using primary key columns"
    genreByPk(genreId: uuid!): Genre
    "execute function \"genre_total_by_month\" which returns \"total_by_genre_view\""
    genreTotalByMonth(
        "input parameters for function \"genreTotalByMonth\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "execute function \"genre_total_by_month\" and query aggregates on result of table type \"total_by_genre_view\""
    genreTotalByMonthAggregate(
        "input parameters for function \"genreTotalByMonthAggregate\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): TotalByGenreViewAggregate!
    "fetch data from the table: \"group\""
    group(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch aggregated fields from the table: \"group\""
    groupAggregate(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): GroupAggregate!
    "fetch data from the table: \"group_application\""
    groupApplication(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch aggregated fields from the table: \"group_application\""
    groupApplicationAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    "fetch data from the table: \"group_application\" using primary key columns"
    groupApplicationByPk(groupApplicationId: uuid!): GroupApplication
    "fetch data from the table: \"group\" using primary key columns"
    groupByPk(groupId: uuid!): Group
    "fetch data from the table: \"group_role\""
    groupRole(
        "distinct select on columns"
        distinctOn: [GroupRoleSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupRoleOrderBy!],
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): [GroupRole!]!
    "fetch aggregated fields from the table: \"group_role\""
    groupRoleAggregate(
        "distinct select on columns"
        distinctOn: [GroupRoleSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupRoleOrderBy!],
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): GroupRoleAggregate!
    "fetch data from the table: \"group_role\" using primary key columns"
    groupRoleByPk(groupRoleId: uuid!): GroupRole
    "fetch data from the table: \"helper_kids.exchange_item\""
    helperKidsExchangeItem(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "fetch aggregated fields from the table: \"helper_kids.exchange_item\""
    helperKidsExchangeItemAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): HelperKidsExchangeItemAggregate!
    "fetch data from the table: \"helper_kids.exchange_item\" using primary key columns"
    helperKidsExchangeItemByPk(
        "ID"
        exchangeItemId: uuid!
    ): HelperKidsExchangeItem
    "fetch data from the table: \"helper_kids.help_item\""
    helperKidsHelpItem(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "fetch aggregated fields from the table: \"helper_kids.help_item\""
    helperKidsHelpItemAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): HelperKidsHelpItemAggregate!
    "fetch data from the table: \"helper_kids.help_item\" using primary key columns"
    helperKidsHelpItemByPk(
        "ID"
        helpItemId: uuid!
    ): HelperKidsHelpItem
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\" using primary key columns"
    helperKidsHelpPointEarnedAchievementByPk(
        "ID"
        helpPointEarnedAchievementId: uuid!
    ): HelperKidsHelpPointEarnedAchievement
    "fetch data from the table: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetail(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetailAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): HelperKidsHelpPointEarnedDetailAggregate!
    "fetch data from the table: \"helper_kids.help_point_earned_detail\" using primary key columns"
    helperKidsHelpPointEarnedDetailByPk(
        "ID"
        helpPointEarnedDetailId: uuid!
    ): HelperKidsHelpPointEarnedDetail
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\" using primary key columns"
    helperKidsHelpPointExchangedAchievementByPk(
        "ID"
        helpPointExchangedAchievementId: uuid!
    ): HelperKidsHelpPointExchangedAchievement
    "fetch data from the table: \"helper_kids.helper_kid\""
    helperKidsHelperKid(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "fetch aggregated fields from the table: \"helper_kids.helper_kid\""
    helperKidsHelperKidAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): HelperKidsHelperKidAggregate!
    "fetch data from the table: \"helper_kids.helper_kid\" using primary key columns"
    helperKidsHelperKidByPk(
        "ID"
        helperKidId: uuid!
    ): HelperKidsHelperKid
    "fetch data from the table: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParent(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "fetch aggregated fields from the table: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParentAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): HelperKidsHelperKidParentAggregate!
    "fetch data from the table: \"helper_kids.helper_kid_parent\" using primary key columns"
    helperKidsHelperKidParentByPk(helperKidParentId: uuid!): HelperKidsHelperKidParent
    "fetch data from the table: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPoint(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidPointSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidPointOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): [HelperKidsHelperKidPoint!]!
    "fetch aggregated fields from the table: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPointAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidPointSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidPointOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): HelperKidsHelperKidPointAggregate!
    "fetch data from the table: \"helper_kids.helper_kid_point\" using primary key columns"
    helperKidsHelperKidPointByPk(
        "お手伝いキッズID"
        helperKidId: uuid!
    ): HelperKidsHelperKidPoint
    "fetch data from the table: \"import_file_history\""
    importFileHistory(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "fetch aggregated fields from the table: \"import_file_history\""
    importFileHistoryAggregate(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): ImportFileHistoryAggregate!
    "fetch data from the table: \"import_file_history\" using primary key columns"
    importFileHistoryByPk(id: uuid!): ImportFileHistory
    "fetch data from the table: \"summary_category_by_group\""
    summaryCategoryByGroup(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "fetch aggregated fields from the table: \"summary_category_by_group\""
    summaryCategoryByGroupAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): SummaryCategoryByGroupAggregate!
    "fetch data from the table: \"summary_category_by_group\" using primary key columns"
    summaryCategoryByGroupByPk(id: uuid!): SummaryCategoryByGroup
    "fetch data from the table: \"summary_category_by_user\""
    summaryCategoryByUser(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): [SummaryCategoryByUser!]!
    "fetch aggregated fields from the table: \"summary_category_by_user\""
    summaryCategoryByUserAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): SummaryCategoryByUserAggregate!
    "fetch data from the table: \"summary_category_by_user\" using primary key columns"
    summaryCategoryByUserByPk(id: uuid!): SummaryCategoryByUser
    "fetch data from the table: \"total_by_account_view\""
    totalByAccountView(
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): [TotalByAccountView!]!
    "fetch aggregated fields from the table: \"total_by_account_view\""
    totalByAccountViewAggregate(
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): TotalByAccountViewAggregate!
    "fetch data from the table: \"total_by_category_view\""
    totalByCategoryView(
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch aggregated fields from the table: \"total_by_category_view\""
    totalByCategoryViewAggregate(
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): TotalByCategoryViewAggregate!
    "fetch data from the table: \"total_by_genre_view\""
    totalByGenreView(
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch aggregated fields from the table: \"total_by_genre_view\""
    totalByGenreViewAggregate(
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): TotalByGenreViewAggregate!
    "fetch data from the table: \"transfer_category\""
    transferCategory(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "fetch aggregated fields from the table: \"transfer_category\""
    transferCategoryAggregate(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): TransferCategoryAggregate!
    "fetch data from the table: \"transfer_category\" using primary key columns"
    transferCategoryByPk(
        "グループID"
        groupId: uuid!
    ): TransferCategory
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
    "fetch aggregated fields from the table: \"user\""
    userAggregate(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): UserAggregate!
    "fetch data from the table: \"user\" using primary key columns"
    userByPk(userId: uuid!): User
}

type subscription_root {
    "fetch data from the table: \"account\""
    account(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "fetch aggregated fields from the table: \"account\""
    accountAggregate(
        "distinct select on columns"
        distinctOn: [AccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AccountOrderBy!],
        "filter the rows returned"
        where: AccountBoolExp
    ): AccountAggregate!
    "fetch data from the table: \"account\" using primary key columns"
    accountByPk(accountId: uuid!): Account
    "fetch data from the table in a streaming manner: \"account\""
    accountStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [AccountStreamCursorInput]!,
        "filter the rows returned"
        where: AccountBoolExp
    ): [Account!]!
    "execute function \"account_total\" which returns \"total_by_account_view\""
    accountTotal(
        "input parameters for function \"accountTotal\""
        args: accountTotalArgs!,
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): [TotalByAccountView!]!
    "execute function \"account_total\" and query aggregates on result of table type \"total_by_account_view\""
    accountTotalAggregate(
        "input parameters for function \"accountTotalAggregate\""
        args: accountTotalArgs!,
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): TotalByAccountViewAggregate!
    "fetch data from the table: \"affiliation\""
    affiliation(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch aggregated fields from the table: \"affiliation\""
    affiliationAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "fetch data from the table: \"affiliation\" using primary key columns"
    affiliationByPk(affiliationId: uuid!): Affiliation
    "fetch data from the table in a streaming manner: \"affiliation\""
    affiliationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [AffiliationStreamCursorInput]!,
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch data from the table: \"application\""
    application(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch aggregated fields from the table: \"application\""
    applicationAggregate(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): ApplicationAggregate!
    "fetch data from the table: \"application\" using primary key columns"
    applicationByPk(applicationId: uuid!): Application
    "fetch data from the table in a streaming manner: \"application\""
    applicationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [ApplicationStreamCursorInput]!,
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch data from the table: \"category\""
    category(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "fetch aggregated fields from the table: \"category\""
    categoryAggregate(
        "distinct select on columns"
        distinctOn: [CategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CategoryOrderBy!],
        "filter the rows returned"
        where: CategoryBoolExp
    ): CategoryAggregate!
    "fetch data from the table: \"category\" using primary key columns"
    categoryByPk(categoryId: uuid!): Category
    "fetch data from the table in a streaming manner: \"category\""
    categoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CategoryStreamCursorInput]!,
        "filter the rows returned"
        where: CategoryBoolExp
    ): [Category!]!
    "execute function \"category_total_by_month\" which returns \"total_by_category_view\""
    categoryTotalByMonth(
        "input parameters for function \"categoryTotalByMonth\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "execute function \"category_total_by_month\" and query aggregates on result of table type \"total_by_category_view\""
    categoryTotalByMonthAggregate(
        "input parameters for function \"categoryTotalByMonthAggregate\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): TotalByCategoryViewAggregate!
    "fetch data from the table: \"credit_card_detail\""
    creditCardDetail(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "fetch aggregated fields from the table: \"credit_card_detail\""
    creditCardDetailAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardDetailOrderBy!],
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): CreditCardDetailAggregate!
    "fetch data from the table: \"credit_card_detail\" using primary key columns"
    creditCardDetailByPk(id: uuid!): CreditCardDetail
    "fetch data from the table in a streaming manner: \"credit_card_detail\""
    creditCardDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CreditCardDetailStreamCursorInput]!,
        "filter the rows returned"
        where: CreditCardDetailBoolExp
    ): [CreditCardDetail!]!
    "fetch data from the table: \"credit_card_summary\""
    creditCardSummary(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "fetch aggregated fields from the table: \"credit_card_summary\""
    creditCardSummaryAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): CreditCardSummaryAggregate!
    "fetch data from the table: \"credit_card_summary\" using primary key columns"
    creditCardSummaryByPk(id: uuid!): CreditCardSummary
    "fetch data from the table in a streaming manner: \"credit_card_summary\""
    creditCardSummaryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CreditCardSummaryStreamCursorInput]!,
        "filter the rows returned"
        where: CreditCardSummaryBoolExp
    ): [CreditCardSummary!]!
    "fetch data from the table: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountView(
        "distinct select on columns"
        distinctOn: [CreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): [CreditCardSummaryTotalByAccountView!]!
    "fetch aggregated fields from the table: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountViewAggregate(
        "distinct select on columns"
        distinctOn: [CreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [CreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): CreditCardSummaryTotalByAccountViewAggregate!
    "fetch data from the table in a streaming manner: \"credit_card_summary_total_by_account_view\""
    creditCardSummaryTotalByAccountViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [CreditCardSummaryTotalByAccountViewStreamCursorInput]!,
        "filter the rows returned"
        where: CreditCardSummaryTotalByAccountViewBoolExp
    ): [CreditCardSummaryTotalByAccountView!]!
    "fetch data from the table: \"daily_detail\""
    dailyDetail(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "fetch aggregated fields from the table: \"daily_detail\""
    dailyDetailAggregate(
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "execute function \"daily_detail_by_date\" which returns \"daily_detail\""
    dailyDetailByDate(
        "input parameters for function \"dailyDetailByDate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "execute function \"daily_detail_by_date\" and query aggregates on result of table type \"daily_detail\""
    dailyDetailByDateAggregate(
        "input parameters for function \"dailyDetailByDateAggregate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [DailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyDetailOrderBy!],
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): DailyDetailAggregate!
    "fetch data from the table: \"daily_detail\" using primary key columns"
    dailyDetailByPk(id: uuid!): DailyDetail
    "fetch data from the table in a streaming manner: \"daily_detail\""
    dailyDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [DailyDetailStreamCursorInput]!,
        "filter the rows returned"
        where: DailyDetailBoolExp
    ): [DailyDetail!]!
    "fetch data from the table: \"daily_total_view\""
    dailyTotalView(
        "distinct select on columns"
        distinctOn: [DailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyTotalViewOrderBy!],
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): [DailyTotalView!]!
    "fetch aggregated fields from the table: \"daily_total_view\""
    dailyTotalViewAggregate(
        "distinct select on columns"
        distinctOn: [DailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [DailyTotalViewOrderBy!],
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): DailyTotalViewAggregate!
    "fetch data from the table in a streaming manner: \"daily_total_view\""
    dailyTotalViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [DailyTotalViewStreamCursorInput]!,
        "filter the rows returned"
        where: DailyTotalViewBoolExp
    ): [DailyTotalView!]!
    "fetch data from the table: \"genre\""
    genre(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "fetch aggregated fields from the table: \"genre\""
    genreAggregate(
        "distinct select on columns"
        distinctOn: [GenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GenreOrderBy!],
        "filter the rows returned"
        where: GenreBoolExp
    ): GenreAggregate!
    "fetch data from the table: \"genre\" using primary key columns"
    genreByPk(genreId: uuid!): Genre
    "fetch data from the table in a streaming manner: \"genre\""
    genreStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GenreStreamCursorInput]!,
        "filter the rows returned"
        where: GenreBoolExp
    ): [Genre!]!
    "execute function \"genre_total_by_month\" which returns \"total_by_genre_view\""
    genreTotalByMonth(
        "input parameters for function \"genreTotalByMonth\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "execute function \"genre_total_by_month\" and query aggregates on result of table type \"total_by_genre_view\""
    genreTotalByMonthAggregate(
        "input parameters for function \"genreTotalByMonthAggregate\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): TotalByGenreViewAggregate!
    "fetch data from the table: \"group\""
    group(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch aggregated fields from the table: \"group\""
    groupAggregate(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): GroupAggregate!
    "fetch data from the table: \"group_application\""
    groupApplication(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch aggregated fields from the table: \"group_application\""
    groupApplicationAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    "fetch data from the table: \"group_application\" using primary key columns"
    groupApplicationByPk(groupApplicationId: uuid!): GroupApplication
    "fetch data from the table in a streaming manner: \"group_application\""
    groupApplicationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupApplicationStreamCursorInput]!,
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch data from the table: \"group\" using primary key columns"
    groupByPk(groupId: uuid!): Group
    "fetch data from the table: \"group_role\""
    groupRole(
        "distinct select on columns"
        distinctOn: [GroupRoleSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupRoleOrderBy!],
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): [GroupRole!]!
    "fetch aggregated fields from the table: \"group_role\""
    groupRoleAggregate(
        "distinct select on columns"
        distinctOn: [GroupRoleSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupRoleOrderBy!],
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): GroupRoleAggregate!
    "fetch data from the table: \"group_role\" using primary key columns"
    groupRoleByPk(groupRoleId: uuid!): GroupRole
    "fetch data from the table in a streaming manner: \"group_role\""
    groupRoleStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupRoleStreamCursorInput]!,
        "filter the rows returned"
        where: GroupRoleBoolExp
    ): [GroupRole!]!
    "fetch data from the table in a streaming manner: \"group\""
    groupStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupStreamCursorInput]!,
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch data from the table: \"helper_kids.exchange_item\""
    helperKidsExchangeItem(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "fetch aggregated fields from the table: \"helper_kids.exchange_item\""
    helperKidsExchangeItemAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsExchangeItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsExchangeItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): HelperKidsExchangeItemAggregate!
    "fetch data from the table: \"helper_kids.exchange_item\" using primary key columns"
    helperKidsExchangeItemByPk(
        "ID"
        exchangeItemId: uuid!
    ): HelperKidsExchangeItem
    "fetch data from the table in a streaming manner: \"helper_kids.exchange_item\""
    helperKidsExchangeItemStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsExchangeItemStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsExchangeItemBoolExp
    ): [HelperKidsExchangeItem!]!
    "fetch data from the table: \"helper_kids.help_item\""
    helperKidsHelpItem(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "fetch aggregated fields from the table: \"helper_kids.help_item\""
    helperKidsHelpItemAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpItemSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpItemOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): HelperKidsHelpItemAggregate!
    "fetch data from the table: \"helper_kids.help_item\" using primary key columns"
    helperKidsHelpItemByPk(
        "ID"
        helpItemId: uuid!
    ): HelperKidsHelpItem
    "fetch data from the table in a streaming manner: \"helper_kids.help_item\""
    helperKidsHelpItemStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpItemStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpItemBoolExp
    ): [HelperKidsHelpItem!]!
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): HelperKidsHelpPointEarnedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_earned_achievement\" using primary key columns"
    helperKidsHelpPointEarnedAchievementByPk(
        "ID"
        helpPointEarnedAchievementId: uuid!
    ): HelperKidsHelpPointEarnedAchievement
    "fetch data from the table in a streaming manner: \"helper_kids.help_point_earned_achievement\""
    helperKidsHelpPointEarnedAchievementStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpPointEarnedAchievementStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedAchievementBoolExp
    ): [HelperKidsHelpPointEarnedAchievement!]!
    "fetch data from the table: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetail(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetailAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointEarnedDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointEarnedDetailOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): HelperKidsHelpPointEarnedDetailAggregate!
    "fetch data from the table: \"helper_kids.help_point_earned_detail\" using primary key columns"
    helperKidsHelpPointEarnedDetailByPk(
        "ID"
        helpPointEarnedDetailId: uuid!
    ): HelperKidsHelpPointEarnedDetail
    "fetch data from the table in a streaming manner: \"helper_kids.help_point_earned_detail\""
    helperKidsHelpPointEarnedDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpPointEarnedDetailStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpPointEarnedDetailBoolExp
    ): [HelperKidsHelpPointEarnedDetail!]!
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievement(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "fetch aggregated fields from the table: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievementAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelpPointExchangedAchievementSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelpPointExchangedAchievementOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): HelperKidsHelpPointExchangedAchievementAggregate!
    "fetch data from the table: \"helper_kids.help_point_exchanged_achievement\" using primary key columns"
    helperKidsHelpPointExchangedAchievementByPk(
        "ID"
        helpPointExchangedAchievementId: uuid!
    ): HelperKidsHelpPointExchangedAchievement
    "fetch data from the table in a streaming manner: \"helper_kids.help_point_exchanged_achievement\""
    helperKidsHelpPointExchangedAchievementStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelpPointExchangedAchievementStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelpPointExchangedAchievementBoolExp
    ): [HelperKidsHelpPointExchangedAchievement!]!
    "fetch data from the table: \"helper_kids.helper_kid\""
    helperKidsHelperKid(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "fetch aggregated fields from the table: \"helper_kids.helper_kid\""
    helperKidsHelperKidAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): HelperKidsHelperKidAggregate!
    "fetch data from the table: \"helper_kids.helper_kid\" using primary key columns"
    helperKidsHelperKidByPk(
        "ID"
        helperKidId: uuid!
    ): HelperKidsHelperKid
    "fetch data from the table: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParent(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "fetch aggregated fields from the table: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParentAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidParentSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidParentOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): HelperKidsHelperKidParentAggregate!
    "fetch data from the table: \"helper_kids.helper_kid_parent\" using primary key columns"
    helperKidsHelperKidParentByPk(helperKidParentId: uuid!): HelperKidsHelperKidParent
    "fetch data from the table in a streaming manner: \"helper_kids.helper_kid_parent\""
    helperKidsHelperKidParentStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelperKidParentStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelperKidParentBoolExp
    ): [HelperKidsHelperKidParent!]!
    "fetch data from the table: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPoint(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidPointSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidPointOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): [HelperKidsHelperKidPoint!]!
    "fetch aggregated fields from the table: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPointAggregate(
        "distinct select on columns"
        distinctOn: [HelperKidsHelperKidPointSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HelperKidsHelperKidPointOrderBy!],
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): HelperKidsHelperKidPointAggregate!
    "fetch data from the table: \"helper_kids.helper_kid_point\" using primary key columns"
    helperKidsHelperKidPointByPk(
        "お手伝いキッズID"
        helperKidId: uuid!
    ): HelperKidsHelperKidPoint
    "fetch data from the table in a streaming manner: \"helper_kids.helper_kid_point\""
    helperKidsHelperKidPointStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelperKidPointStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelperKidPointBoolExp
    ): [HelperKidsHelperKidPoint!]!
    "fetch data from the table in a streaming manner: \"helper_kids.helper_kid\""
    helperKidsHelperKidStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HelperKidsHelperKidStreamCursorInput]!,
        "filter the rows returned"
        where: HelperKidsHelperKidBoolExp
    ): [HelperKidsHelperKid!]!
    "fetch data from the table: \"import_file_history\""
    importFileHistory(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "fetch aggregated fields from the table: \"import_file_history\""
    importFileHistoryAggregate(
        "distinct select on columns"
        distinctOn: [ImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): ImportFileHistoryAggregate!
    "fetch data from the table: \"import_file_history\" using primary key columns"
    importFileHistoryByPk(id: uuid!): ImportFileHistory
    "fetch data from the table in a streaming manner: \"import_file_history\""
    importFileHistoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [ImportFileHistoryStreamCursorInput]!,
        "filter the rows returned"
        where: ImportFileHistoryBoolExp
    ): [ImportFileHistory!]!
    "fetch data from the table: \"summary_category_by_group\""
    summaryCategoryByGroup(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "fetch aggregated fields from the table: \"summary_category_by_group\""
    summaryCategoryByGroupAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByGroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByGroupOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): SummaryCategoryByGroupAggregate!
    "fetch data from the table: \"summary_category_by_group\" using primary key columns"
    summaryCategoryByGroupByPk(id: uuid!): SummaryCategoryByGroup
    "fetch data from the table in a streaming manner: \"summary_category_by_group\""
    summaryCategoryByGroupStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [SummaryCategoryByGroupStreamCursorInput]!,
        "filter the rows returned"
        where: SummaryCategoryByGroupBoolExp
    ): [SummaryCategoryByGroup!]!
    "fetch data from the table: \"summary_category_by_user\""
    summaryCategoryByUser(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): [SummaryCategoryByUser!]!
    "fetch aggregated fields from the table: \"summary_category_by_user\""
    summaryCategoryByUserAggregate(
        "distinct select on columns"
        distinctOn: [SummaryCategoryByUserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [SummaryCategoryByUserOrderBy!],
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): SummaryCategoryByUserAggregate!
    "fetch data from the table: \"summary_category_by_user\" using primary key columns"
    summaryCategoryByUserByPk(id: uuid!): SummaryCategoryByUser
    "fetch data from the table in a streaming manner: \"summary_category_by_user\""
    summaryCategoryByUserStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [SummaryCategoryByUserStreamCursorInput]!,
        "filter the rows returned"
        where: SummaryCategoryByUserBoolExp
    ): [SummaryCategoryByUser!]!
    "fetch data from the table: \"total_by_account_view\""
    totalByAccountView(
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): [TotalByAccountView!]!
    "fetch aggregated fields from the table: \"total_by_account_view\""
    totalByAccountViewAggregate(
        "distinct select on columns"
        distinctOn: [TotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): TotalByAccountViewAggregate!
    "fetch data from the table in a streaming manner: \"total_by_account_view\""
    totalByAccountViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TotalByAccountViewStreamCursorInput]!,
        "filter the rows returned"
        where: TotalByAccountViewBoolExp
    ): [TotalByAccountView!]!
    "fetch data from the table: \"total_by_category_view\""
    totalByCategoryView(
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch aggregated fields from the table: \"total_by_category_view\""
    totalByCategoryViewAggregate(
        "distinct select on columns"
        distinctOn: [TotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): TotalByCategoryViewAggregate!
    "fetch data from the table in a streaming manner: \"total_by_category_view\""
    totalByCategoryViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TotalByCategoryViewStreamCursorInput]!,
        "filter the rows returned"
        where: TotalByCategoryViewBoolExp
    ): [TotalByCategoryView!]!
    "fetch data from the table: \"total_by_genre_view\""
    totalByGenreView(
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch aggregated fields from the table: \"total_by_genre_view\""
    totalByGenreViewAggregate(
        "distinct select on columns"
        distinctOn: [TotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): TotalByGenreViewAggregate!
    "fetch data from the table in a streaming manner: \"total_by_genre_view\""
    totalByGenreViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TotalByGenreViewStreamCursorInput]!,
        "filter the rows returned"
        where: TotalByGenreViewBoolExp
    ): [TotalByGenreView!]!
    "fetch data from the table: \"transfer_category\""
    transferCategory(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "fetch aggregated fields from the table: \"transfer_category\""
    transferCategoryAggregate(
        "distinct select on columns"
        distinctOn: [TransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [TransferCategoryOrderBy!],
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): TransferCategoryAggregate!
    "fetch data from the table: \"transfer_category\" using primary key columns"
    transferCategoryByPk(
        "グループID"
        groupId: uuid!
    ): TransferCategory
    "fetch data from the table in a streaming manner: \"transfer_category\""
    transferCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [TransferCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: TransferCategoryBoolExp
    ): [TransferCategory!]!
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
    "fetch aggregated fields from the table: \"user\""
    userAggregate(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): UserAggregate!
    "fetch data from the table: \"user\" using primary key columns"
    userByPk(userId: uuid!): User
    "fetch data from the table in a streaming manner: \"user\""
    userStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [UserStreamCursorInput]!,
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
}

"unique or primary key constraints on table \"account\""
enum AccountConstraint {
    "unique or primary key constraint on columns \"account_id\""
    account_pkey
}

"select columns of table \"account\""
enum AccountSelectColumn {
    "column name"
    accountId
    "column name"
    accountName
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    validFlag
}

"select \"accountAggregateBoolExpBool_andArgumentsColumns\" columns of table \"account\""
enum AccountSelectColumnAccountAggregateBoolExpBool_andArgumentsColumns {
    "column name"
    validFlag
}

"select \"accountAggregateBoolExpBool_orArgumentsColumns\" columns of table \"account\""
enum AccountSelectColumnAccountAggregateBoolExpBool_orArgumentsColumns {
    "column name"
    validFlag
}

"update columns of table \"account\""
enum AccountUpdateColumn {
    "column name"
    accountId
    "column name"
    accountName
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    validFlag
}

"unique or primary key constraints on table \"affiliation\""
enum AffiliationConstraint {
    "unique or primary key constraint on columns \"affiliation_id\""
    affiliation_pkey
}

"select columns of table \"affiliation\""
enum AffiliationSelectColumn {
    "column name"
    affiliationId
    "column name"
    groupId
    "column name"
    groupRoleId
    "column name"
    userId
}

"update columns of table \"affiliation\""
enum AffiliationUpdateColumn {
    "column name"
    affiliationId
    "column name"
    groupId
    "column name"
    groupRoleId
    "column name"
    userId
}

"unique or primary key constraints on table \"application\""
enum ApplicationConstraint {
    "unique or primary key constraint on columns \"application_id\""
    application_pkey
}

"select columns of table \"application\""
enum ApplicationSelectColumn {
    "column name"
    application
    "column name"
    applicationId
    "column name"
    topUrl
    "column name"
    validFlag
}

"update columns of table \"application\""
enum ApplicationUpdateColumn {
    "column name"
    application
    "column name"
    applicationId
    "column name"
    topUrl
    "column name"
    validFlag
}

"unique or primary key constraints on table \"category\""
enum CategoryConstraint {
    "unique or primary key constraint on columns \"category_id\""
    category_pkey
}

"select columns of table \"category\""
enum CategorySelectColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    validFlag
}

"select \"categoryAggregateBoolExpBool_andArgumentsColumns\" columns of table \"category\""
enum CategorySelectColumnCategoryAggregateBoolExpBool_andArgumentsColumns {
    "column name"
    validFlag
}

"select \"categoryAggregateBoolExpBool_orArgumentsColumns\" columns of table \"category\""
enum CategorySelectColumnCategoryAggregateBoolExpBool_orArgumentsColumns {
    "column name"
    validFlag
}

"update columns of table \"category\""
enum CategoryUpdateColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    validFlag
}

"unique or primary key constraints on table \"credit_card_detail\""
enum CreditCardDetailConstraint {
    "unique or primary key constraint on columns \"id\""
    credit_card_detail_pkey
}

"select columns of table \"credit_card_detail\""
enum CreditCardDetailSelectColumn {
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    groupId
    "column name"
    id
    "column name"
    memo
    "column name"
    summaryId
    "column name"
    userId
}

"update columns of table \"credit_card_detail\""
enum CreditCardDetailUpdateColumn {
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    groupId
    "column name"
    id
    "column name"
    memo
    "column name"
    summaryId
    "column name"
    userId
}

"unique or primary key constraints on table \"credit_card_summary\""
enum CreditCardSummaryConstraint {
    "unique or primary key constraint on columns \"id\""
    credit_card_summary_pkey
}

"select columns of table \"credit_card_summary\""
enum CreditCardSummarySelectColumn {
    "column name"
    accountId
    "column name"
    count
    "column name"
    creditCard
    "column name"
    groupId
    "column name"
    id
    "column name"
    totalAmount
    "column name"
    withdrawalDate
}

"select columns of table \"credit_card_summary_total_by_account_view\""
enum CreditCardSummaryTotalByAccountViewSelectColumn {
    "column name"
    accountId
    "column name"
    accountName
    "column name"
    date
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"update columns of table \"credit_card_summary\""
enum CreditCardSummaryUpdateColumn {
    "column name"
    accountId
    "column name"
    count
    "column name"
    creditCard
    "column name"
    groupId
    "column name"
    id
    "column name"
    totalAmount
    "column name"
    withdrawalDate
}

"ordering argument of a cursor"
enum CursorOrdering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"unique or primary key constraints on table \"daily_detail\""
enum DailyDetailConstraint {
    "unique or primary key constraint on columns \"id\""
    daily_detail_pkey
}

"select columns of table \"daily_detail\""
enum DailyDetailSelectColumn {
    "column name"
    accountId
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    groupId
    "column name"
    id
    "column name"
    memo
    "column name"
    userId
}

"update columns of table \"daily_detail\""
enum DailyDetailUpdateColumn {
    "column name"
    accountId
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    groupId
    "column name"
    id
    "column name"
    memo
    "column name"
    userId
}

"select columns of table \"daily_total_view\""
enum DailyTotalViewSelectColumn {
    "column name"
    date
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"unique or primary key constraints on table \"genre\""
enum GenreConstraint {
    "unique or primary key constraint on columns \"genre_id\""
    genre_pkey
}

"select columns of table \"genre\""
enum GenreSelectColumn {
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    genreType
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    validFlag
}

"select \"genreAggregateBoolExpBool_andArgumentsColumns\" columns of table \"genre\""
enum GenreSelectColumnGenreAggregateBoolExpBool_andArgumentsColumns {
    "column name"
    validFlag
}

"select \"genreAggregateBoolExpBool_orArgumentsColumns\" columns of table \"genre\""
enum GenreSelectColumnGenreAggregateBoolExpBool_orArgumentsColumns {
    "column name"
    validFlag
}

"update columns of table \"genre\""
enum GenreUpdateColumn {
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    genreType
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    validFlag
}

"unique or primary key constraints on table \"group_application\""
enum GroupApplicationConstraint {
    "unique or primary key constraint on columns \"group_application_id\""
    group_application_pkey
}

"select columns of table \"group_application\""
enum GroupApplicationSelectColumn {
    "column name"
    applicationId
    "column name"
    groupApplicationId
    "column name"
    groupId
}

"update columns of table \"group_application\""
enum GroupApplicationUpdateColumn {
    "column name"
    applicationId
    "column name"
    groupApplicationId
    "column name"
    groupId
}

"unique or primary key constraints on table \"group\""
enum GroupConstraint {
    "unique or primary key constraint on columns \"group_id\""
    group_pkey
}

"unique or primary key constraints on table \"group_role\""
enum GroupRoleConstraint {
    "unique or primary key constraint on columns \"group_role_id\""
    group_role_pkey
}

"select columns of table \"group_role\""
enum GroupRoleSelectColumn {
    "column name"
    groupRoleId
    "column name"
    role
}

"update columns of table \"group_role\""
enum GroupRoleUpdateColumn {
    "column name"
    groupRoleId
    "column name"
    role
}

"select columns of table \"group\""
enum GroupSelectColumn {
    "column name"
    groupId
    "column name"
    groupName
}

"update columns of table \"group\""
enum GroupUpdateColumn {
    "column name"
    groupId
    "column name"
    groupName
}

"unique or primary key constraints on table \"helper_kids.exchange_item\""
enum HelperKidsExchangeItemConstraint {
    "unique or primary key constraint on columns \"exchange_item_id\""
    exchange_item_pkey
}

"select columns of table \"helper_kids.exchange_item\""
enum HelperKidsExchangeItemSelectColumn {
    "column name"
    exchangeItemId
    "column name"
    groupId
    "column name"
    memo
    "column name"
    name
    "column name"
    point
}

"update columns of table \"helper_kids.exchange_item\""
enum HelperKidsExchangeItemUpdateColumn {
    "column name"
    exchangeItemId
    "column name"
    groupId
    "column name"
    memo
    "column name"
    name
    "column name"
    point
}

"unique or primary key constraints on table \"helper_kids.help_item\""
enum HelperKidsHelpItemConstraint {
    "unique or primary key constraint on columns \"help_item_id\""
    help_item_pkey
}

"select columns of table \"helper_kids.help_item\""
enum HelperKidsHelpItemSelectColumn {
    "column name"
    groupId
    "column name"
    helpItemId
    "column name"
    memo
    "column name"
    name
    "column name"
    point
}

"update columns of table \"helper_kids.help_item\""
enum HelperKidsHelpItemUpdateColumn {
    "column name"
    groupId
    "column name"
    helpItemId
    "column name"
    memo
    "column name"
    name
    "column name"
    point
}

"unique or primary key constraints on table \"helper_kids.help_point_earned_achievement\""
enum HelperKidsHelpPointEarnedAchievementConstraint {
    "unique or primary key constraint on columns \"help_point_earned_achievement_id\""
    help_point_earned_achievement_pkey
}

"select columns of table \"helper_kids.help_point_earned_achievement\""
enum HelperKidsHelpPointEarnedAchievementSelectColumn {
    "column name"
    earnedDatetime
    "column name"
    earnedPoint
    "column name"
    groupId
    "column name"
    helpPointEarnedAchievementId
    "column name"
    helperKidId
}

"update columns of table \"helper_kids.help_point_earned_achievement\""
enum HelperKidsHelpPointEarnedAchievementUpdateColumn {
    "column name"
    earnedDatetime
    "column name"
    earnedPoint
    "column name"
    groupId
    "column name"
    helpPointEarnedAchievementId
    "column name"
    helperKidId
}

"unique or primary key constraints on table \"helper_kids.help_point_earned_detail\""
enum HelperKidsHelpPointEarnedDetailConstraint {
    "unique or primary key constraint on columns \"help_point_earned_detail_id\""
    help_point_earned_detail_pkey
}

"select columns of table \"helper_kids.help_point_earned_detail\""
enum HelperKidsHelpPointEarnedDetailSelectColumn {
    "column name"
    earnedAchievementId
    "column name"
    groupId
    "column name"
    helpItemCount
    "column name"
    helpItemId
    "column name"
    helpItemTotalPoint
    "column name"
    helpPointEarnedDetailId
}

"update columns of table \"helper_kids.help_point_earned_detail\""
enum HelperKidsHelpPointEarnedDetailUpdateColumn {
    "column name"
    earnedAchievementId
    "column name"
    groupId
    "column name"
    helpItemCount
    "column name"
    helpItemId
    "column name"
    helpItemTotalPoint
    "column name"
    helpPointEarnedDetailId
}

"unique or primary key constraints on table \"helper_kids.help_point_exchanged_achievement\""
enum HelperKidsHelpPointExchangedAchievementConstraint {
    "unique or primary key constraint on columns \"help_point_exchanged_achievement_id\""
    help_point_exchanged_achievement_pkey
}

"select columns of table \"helper_kids.help_point_exchanged_achievement\""
enum HelperKidsHelpPointExchangedAchievementSelectColumn {
    "column name"
    exchangeCount
    "column name"
    exchangeItemId
    "column name"
    exchangeTotalPoint
    "column name"
    exchangedDatetime
    "column name"
    groupId
    "column name"
    helpPointExchangedAchievementId
    "column name"
    helperKidId
}

"update columns of table \"helper_kids.help_point_exchanged_achievement\""
enum HelperKidsHelpPointExchangedAchievementUpdateColumn {
    "column name"
    exchangeCount
    "column name"
    exchangeItemId
    "column name"
    exchangeTotalPoint
    "column name"
    exchangedDatetime
    "column name"
    groupId
    "column name"
    helpPointExchangedAchievementId
    "column name"
    helperKidId
}

"unique or primary key constraints on table \"helper_kids.helper_kid\""
enum HelperKidsHelperKidConstraint {
    "unique or primary key constraint on columns \"helper_kid_id\""
    helper_kid_pkey
}

"unique or primary key constraints on table \"helper_kids.helper_kid_parent\""
enum HelperKidsHelperKidParentConstraint {
    "unique or primary key constraint on columns \"helper_kid_parent_id\""
    helper_kid_parent_pkey
}

"select columns of table \"helper_kids.helper_kid_parent\""
enum HelperKidsHelperKidParentSelectColumn {
    "column name"
    helperKidId
    "column name"
    helperKidParentId
    "column name"
    parentUserId
}

"update columns of table \"helper_kids.helper_kid_parent\""
enum HelperKidsHelperKidParentUpdateColumn {
    "column name"
    helperKidId
    "column name"
    helperKidParentId
    "column name"
    parentUserId
}

"unique or primary key constraints on table \"helper_kids.helper_kid_point\""
enum HelperKidsHelperKidPointConstraint {
    "unique or primary key constraint on columns \"helper_kid_id\""
    helper_kid_point_pkey
}

"select columns of table \"helper_kids.helper_kid_point\""
enum HelperKidsHelperKidPointSelectColumn {
    "column name"
    helperKidId
    "column name"
    lastHelpDatetime
    "column name"
    point
}

"update columns of table \"helper_kids.helper_kid_point\""
enum HelperKidsHelperKidPointUpdateColumn {
    "column name"
    helperKidId
    "column name"
    lastHelpDatetime
    "column name"
    point
}

"select columns of table \"helper_kids.helper_kid\""
enum HelperKidsHelperKidSelectColumn {
    "column name"
    groupId
    "column name"
    helperKidId
    "column name"
    name
    "column name"
    nameSuffix
}

"update columns of table \"helper_kids.helper_kid\""
enum HelperKidsHelperKidUpdateColumn {
    "column name"
    groupId
    "column name"
    helperKidId
    "column name"
    name
    "column name"
    nameSuffix
}

"unique or primary key constraints on table \"import_file_history\""
enum ImportFileHistoryConstraint {
    "unique or primary key constraint on columns \"id\""
    import_file_history_pkey
}

"select columns of table \"import_file_history\""
enum ImportFileHistorySelectColumn {
    "column name"
    fileName
    "column name"
    fileType
    "column name"
    groupId
    "column name"
    id
    "column name"
    importDatetime
    "column name"
    importUserId
}

"update columns of table \"import_file_history\""
enum ImportFileHistoryUpdateColumn {
    "column name"
    fileName
    "column name"
    fileType
    "column name"
    groupId
    "column name"
    id
    "column name"
    importDatetime
    "column name"
    importUserId
}

"column ordering options"
enum OrderBy {
    "in ascending order, nulls last"
    ASC
    "in ascending order, nulls first"
    ASC_NULLS_FIRST
    "in ascending order, nulls last"
    ASC_NULLS_LAST
    "in descending order, nulls first"
    DESC
    "in descending order, nulls first"
    DESC_NULLS_FIRST
    "in descending order, nulls last"
    DESC_NULLS_LAST
}

"unique or primary key constraints on table \"summary_category_by_group\""
enum SummaryCategoryByGroupConstraint {
    "unique or primary key constraint on columns \"id\""
    summary_category_by_group_pkey
}

"select columns of table \"summary_category_by_group\""
enum SummaryCategoryByGroupSelectColumn {
    "column name"
    categoryId
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    id
}

"update columns of table \"summary_category_by_group\""
enum SummaryCategoryByGroupUpdateColumn {
    "column name"
    categoryId
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    id
}

"unique or primary key constraints on table \"summary_category_by_user\""
enum SummaryCategoryByUserConstraint {
    "unique or primary key constraint on columns \"id\""
    summary_category_by_user_pkey
}

"select columns of table \"summary_category_by_user\""
enum SummaryCategoryByUserSelectColumn {
    "column name"
    categoryId
    "column name"
    displayOrder
    "column name"
    id
    "column name"
    userId
}

"update columns of table \"summary_category_by_user\""
enum SummaryCategoryByUserUpdateColumn {
    "column name"
    categoryId
    "column name"
    displayOrder
    "column name"
    id
    "column name"
    userId
}

"select columns of table \"total_by_account_view\""
enum TotalByAccountViewSelectColumn {
    "column name"
    accountId
    "column name"
    accountName
    "column name"
    date
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"select columns of table \"total_by_category_view\""
enum TotalByCategoryViewSelectColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    date
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"select columns of table \"total_by_genre_view\""
enum TotalByGenreViewSelectColumn {
    "column name"
    date
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"unique or primary key constraints on table \"transfer_category\""
enum TransferCategoryConstraint {
    "unique or primary key constraint on columns \"group_id\""
    transfer_category_pkey
}

"select columns of table \"transfer_category\""
enum TransferCategorySelectColumn {
    "column name"
    groupId
    "column name"
    incomeCategoryId
    "column name"
    outcomeCategoryId
}

"update columns of table \"transfer_category\""
enum TransferCategoryUpdateColumn {
    "column name"
    groupId
    "column name"
    incomeCategoryId
    "column name"
    outcomeCategoryId
}

"unique or primary key constraints on table \"user\""
enum UserConstraint {
    "unique or primary key constraint on columns \"email\""
    user_email_key
    "unique or primary key constraint on columns \"user_id\""
    user_pkey
}

"select columns of table \"user\""
enum UserSelectColumn {
    "column name"
    displayOrder
    "column name"
    email
    "column name"
    userId
    "column name"
    userName
}

"update columns of table \"user\""
enum UserUpdateColumn {
    "column name"
    displayOrder
    "column name"
    email
    "column name"
    userId
    "column name"
    userName
}

scalar date

scalar genre_type

scalar iocome_type

scalar numeric

scalar timestamp

scalar uuid

input AccountAggregateBoolExp {
    bool_and: accountAggregateBoolExpBool_and
    bool_or: accountAggregateBoolExpBool_or
    count: accountAggregateBoolExpCount
}

"order by aggregate values of table \"account\""
input AccountAggregateOrderBy {
    avg: AccountAvgOrderBy
    count: OrderBy
    max: AccountMaxOrderBy
    min: AccountMinOrderBy
    stddev: AccountStddevOrderBy
    stddevPop: AccountStddevPopOrderBy
    stddevSamp: AccountStddevSampOrderBy
    sum: AccountSumOrderBy
    varPop: AccountVarPopOrderBy
    varSamp: AccountVarSampOrderBy
    variance: AccountVarianceOrderBy
}

"input type for inserting array relation for remote table \"account\""
input AccountArrRelInsertInput {
    data: [AccountInsertInput!]!
    "upsert condition"
    onConflict: AccountOnConflict
}

"order by avg() on columns of table \"account\""
input AccountAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"account\". All fields are combined with a logical 'AND'."
input AccountBoolExp {
    _and: [AccountBoolExp!]
    _not: AccountBoolExp
    _or: [AccountBoolExp!]
    accountId: UuidComparisonExp
    accountName: StringComparisonExp
    credit_card_summaries: CreditCardSummaryBoolExp
    credit_card_summariesAggregate: CreditCardSummaryAggregateBoolExp
    daily_details: DailyDetailBoolExp
    daily_detailsAggregate: DailyDetailAggregateBoolExp
    displayOrder: IntComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"account\""
input AccountIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"account\""
input AccountInsertInput {
    accountId: uuid
    accountName: String
    credit_card_summaries: CreditCardSummaryArrRelInsertInput
    daily_details: DailyDetailArrRelInsertInput
    displayOrder: Int
    group: GroupObjRelInsertInput
    groupId: uuid
    validFlag: Boolean
}

"order by max() on columns of table \"account\""
input AccountMaxOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"account\""
input AccountMinOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
}

"input type for inserting object relation for remote table \"account\""
input AccountObjRelInsertInput {
    data: AccountInsertInput!
    "upsert condition"
    onConflict: AccountOnConflict
}

"on_conflict condition type for table \"account\""
input AccountOnConflict {
    constraint: AccountConstraint!
    updateColumns: [AccountUpdateColumn!]! = []
    where: AccountBoolExp
}

"Ordering options when selecting data from \"account\"."
input AccountOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    credit_card_summariesAggregate: CreditCardSummaryAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    displayOrder: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    validFlag: OrderBy
}

"primary key columns input for table: account"
input AccountPkColumnsInput {
    accountId: uuid!
}

"input type for updating data in table \"account\""
input AccountSetInput {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
    validFlag: Boolean
}

"order by stddev() on columns of table \"account\""
input AccountStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"account\""
input AccountStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"account\""
input AccountStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"account\""
input AccountStreamCursorInput {
    "Stream column input with initial value"
    initialValue: AccountStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input AccountStreamCursorValueInput {
    accountId: uuid
    accountName: String
    displayOrder: Int
    groupId: uuid
    validFlag: Boolean
}

"order by sum() on columns of table \"account\""
input AccountSumOrderBy {
    displayOrder: OrderBy
}

input AccountUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: AccountIncInput
    "sets the columns of the filtered rows to the given values"
    _set: AccountSetInput
    "filter the rows which have to be updated"
    where: AccountBoolExp!
}

"order by varPop() on columns of table \"account\""
input AccountVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"account\""
input AccountVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"account\""
input AccountVarianceOrderBy {
    displayOrder: OrderBy
}

input AffiliationAggregateBoolExp {
    count: affiliationAggregateBoolExpCount
}

"order by aggregate values of table \"affiliation\""
input AffiliationAggregateOrderBy {
    count: OrderBy
    max: AffiliationMaxOrderBy
    min: AffiliationMinOrderBy
}

"input type for inserting array relation for remote table \"affiliation\""
input AffiliationArrRelInsertInput {
    data: [AffiliationInsertInput!]!
    "upsert condition"
    onConflict: AffiliationOnConflict
}

"Boolean expression to filter rows from the table \"affiliation\". All fields are combined with a logical 'AND'."
input AffiliationBoolExp {
    _and: [AffiliationBoolExp!]
    _not: AffiliationBoolExp
    _or: [AffiliationBoolExp!]
    affiliationId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    groupRoleId: UuidComparisonExp
    group_role: GroupRoleBoolExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"input type for inserting data into table \"affiliation\""
input AffiliationInsertInput {
    affiliationId: uuid
    group: GroupObjRelInsertInput
    groupId: uuid
    groupRoleId: uuid
    group_role: GroupRoleObjRelInsertInput
    user: UserObjRelInsertInput
    userId: uuid
}

"order by max() on columns of table \"affiliation\""
input AffiliationMaxOrderBy {
    affiliationId: OrderBy
    groupId: OrderBy
    groupRoleId: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"affiliation\""
input AffiliationMinOrderBy {
    affiliationId: OrderBy
    groupId: OrderBy
    groupRoleId: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"affiliation\""
input AffiliationOnConflict {
    constraint: AffiliationConstraint!
    updateColumns: [AffiliationUpdateColumn!]! = []
    where: AffiliationBoolExp
}

"Ordering options when selecting data from \"affiliation\"."
input AffiliationOrderBy {
    affiliationId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    groupRoleId: OrderBy
    group_role: GroupRoleOrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: affiliation"
input AffiliationPkColumnsInput {
    affiliationId: uuid!
}

"input type for updating data in table \"affiliation\""
input AffiliationSetInput {
    affiliationId: uuid
    groupId: uuid
    groupRoleId: uuid
    userId: uuid
}

"Streaming cursor of the table \"affiliation\""
input AffiliationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: AffiliationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input AffiliationStreamCursorValueInput {
    affiliationId: uuid
    groupId: uuid
    groupRoleId: uuid
    userId: uuid
}

input AffiliationUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: AffiliationSetInput
    "filter the rows which have to be updated"
    where: AffiliationBoolExp!
}

"Boolean expression to filter rows from the table \"application\". All fields are combined with a logical 'AND'."
input ApplicationBoolExp {
    _and: [ApplicationBoolExp!]
    _not: ApplicationBoolExp
    _or: [ApplicationBoolExp!]
    application: StringComparisonExp
    applicationId: UuidComparisonExp
    group_applications: GroupApplicationBoolExp
    group_applicationsAggregate: GroupApplicationAggregateBoolExp
    topUrl: StringComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for inserting data into table \"application\""
input ApplicationInsertInput {
    application: String
    applicationId: uuid
    group_applications: GroupApplicationArrRelInsertInput
    topUrl: String
    validFlag: Boolean
}

"input type for inserting object relation for remote table \"application\""
input ApplicationObjRelInsertInput {
    data: ApplicationInsertInput!
    "upsert condition"
    onConflict: ApplicationOnConflict
}

"on_conflict condition type for table \"application\""
input ApplicationOnConflict {
    constraint: ApplicationConstraint!
    updateColumns: [ApplicationUpdateColumn!]! = []
    where: ApplicationBoolExp
}

"Ordering options when selecting data from \"application\"."
input ApplicationOrderBy {
    application: OrderBy
    applicationId: OrderBy
    group_applicationsAggregate: GroupApplicationAggregateOrderBy
    topUrl: OrderBy
    validFlag: OrderBy
}

"primary key columns input for table: application"
input ApplicationPkColumnsInput {
    applicationId: uuid!
}

"input type for updating data in table \"application\""
input ApplicationSetInput {
    application: String
    applicationId: uuid
    topUrl: String
    validFlag: Boolean
}

"Streaming cursor of the table \"application\""
input ApplicationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: ApplicationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input ApplicationStreamCursorValueInput {
    application: String
    applicationId: uuid
    topUrl: String
    validFlag: Boolean
}

input ApplicationUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: ApplicationSetInput
    "filter the rows which have to be updated"
    where: ApplicationBoolExp!
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input BooleanComparisonExp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _isNull: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

input CategoryAggregateBoolExp {
    bool_and: categoryAggregateBoolExpBool_and
    bool_or: categoryAggregateBoolExpBool_or
    count: categoryAggregateBoolExpCount
}

"order by aggregate values of table \"category\""
input CategoryAggregateOrderBy {
    avg: CategoryAvgOrderBy
    count: OrderBy
    max: CategoryMaxOrderBy
    min: CategoryMinOrderBy
    stddev: CategoryStddevOrderBy
    stddevPop: CategoryStddevPopOrderBy
    stddevSamp: CategoryStddevSampOrderBy
    sum: CategorySumOrderBy
    varPop: CategoryVarPopOrderBy
    varSamp: CategoryVarSampOrderBy
    variance: CategoryVarianceOrderBy
}

"input type for inserting array relation for remote table \"category\""
input CategoryArrRelInsertInput {
    data: [CategoryInsertInput!]!
    "upsert condition"
    onConflict: CategoryOnConflict
}

"order by avg() on columns of table \"category\""
input CategoryAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"category\". All fields are combined with a logical 'AND'."
input CategoryBoolExp {
    _and: [CategoryBoolExp!]
    _not: CategoryBoolExp
    _or: [CategoryBoolExp!]
    categoryId: UuidComparisonExp
    categoryName: StringComparisonExp
    credit_card_details: CreditCardDetailBoolExp
    credit_card_detailsAggregate: CreditCardDetailAggregateBoolExp
    daily_details: DailyDetailBoolExp
    daily_detailsAggregate: DailyDetailAggregateBoolExp
    displayOrder: IntComparisonExp
    genre: GenreBoolExp
    genreId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    income_transfer_category: TransferCategoryBoolExp
    income_transfer_categoryAggregate: TransferCategoryAggregateBoolExp
    outcome_transfer_category: TransferCategoryBoolExp
    outcome_transfer_categoryAggregate: TransferCategoryAggregateBoolExp
    summary_category_by_groups: SummaryCategoryByGroupBoolExp
    summary_category_by_groupsAggregate: SummaryCategoryByGroupAggregateBoolExp
    summary_category_by_users: SummaryCategoryByUserBoolExp
    summary_category_by_usersAggregate: SummaryCategoryByUserAggregateBoolExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"category\""
input CategoryIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"category\""
input CategoryInsertInput {
    categoryId: uuid
    categoryName: String
    credit_card_details: CreditCardDetailArrRelInsertInput
    daily_details: DailyDetailArrRelInsertInput
    displayOrder: Int
    genre: GenreObjRelInsertInput
    genreId: uuid
    group: GroupObjRelInsertInput
    groupId: uuid
    income_transfer_category: TransferCategoryArrRelInsertInput
    outcome_transfer_category: TransferCategoryArrRelInsertInput
    summary_category_by_groups: SummaryCategoryByGroupArrRelInsertInput
    summary_category_by_users: SummaryCategoryByUserArrRelInsertInput
    validFlag: Boolean
}

"order by max() on columns of table \"category\""
input CategoryMaxOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    displayOrder: OrderBy
    genreId: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"category\""
input CategoryMinOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    displayOrder: OrderBy
    genreId: OrderBy
    groupId: OrderBy
}

"input type for inserting object relation for remote table \"category\""
input CategoryObjRelInsertInput {
    data: CategoryInsertInput!
    "upsert condition"
    onConflict: CategoryOnConflict
}

"on_conflict condition type for table \"category\""
input CategoryOnConflict {
    constraint: CategoryConstraint!
    updateColumns: [CategoryUpdateColumn!]! = []
    where: CategoryBoolExp
}

"Ordering options when selecting data from \"category\"."
input CategoryOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    credit_card_detailsAggregate: CreditCardDetailAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    displayOrder: OrderBy
    genre: GenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    income_transfer_categoryAggregate: TransferCategoryAggregateOrderBy
    outcome_transfer_categoryAggregate: TransferCategoryAggregateOrderBy
    summary_category_by_groupsAggregate: SummaryCategoryByGroupAggregateOrderBy
    summary_category_by_usersAggregate: SummaryCategoryByUserAggregateOrderBy
    validFlag: OrderBy
}

"primary key columns input for table: category"
input CategoryPkColumnsInput {
    categoryId: uuid!
}

"input type for updating data in table \"category\""
input CategorySetInput {
    categoryId: uuid
    categoryName: String
    displayOrder: Int
    genreId: uuid
    groupId: uuid
    validFlag: Boolean
}

"order by stddev() on columns of table \"category\""
input CategoryStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"category\""
input CategoryStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"category\""
input CategoryStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"category\""
input CategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CategoryStreamCursorValueInput {
    categoryId: uuid
    categoryName: String
    displayOrder: Int
    genreId: uuid
    groupId: uuid
    validFlag: Boolean
}

"order by sum() on columns of table \"category\""
input CategorySumOrderBy {
    displayOrder: OrderBy
}

input CategoryUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: CategoryIncInput
    "sets the columns of the filtered rows to the given values"
    _set: CategorySetInput
    "filter the rows which have to be updated"
    where: CategoryBoolExp!
}

"order by varPop() on columns of table \"category\""
input CategoryVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"category\""
input CategoryVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"category\""
input CategoryVarianceOrderBy {
    displayOrder: OrderBy
}

input CreditCardDetailAggregateBoolExp {
    count: creditCardDetailAggregateBoolExpCount
}

"order by aggregate values of table \"credit_card_detail\""
input CreditCardDetailAggregateOrderBy {
    avg: CreditCardDetailAvgOrderBy
    count: OrderBy
    max: CreditCardDetailMaxOrderBy
    min: CreditCardDetailMinOrderBy
    stddev: CreditCardDetailStddevOrderBy
    stddevPop: CreditCardDetailStddevPopOrderBy
    stddevSamp: CreditCardDetailStddevSampOrderBy
    sum: CreditCardDetailSumOrderBy
    varPop: CreditCardDetailVarPopOrderBy
    varSamp: CreditCardDetailVarSampOrderBy
    variance: CreditCardDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"credit_card_detail\""
input CreditCardDetailArrRelInsertInput {
    data: [CreditCardDetailInsertInput!]!
    "upsert condition"
    onConflict: CreditCardDetailOnConflict
}

"order by avg() on columns of table \"credit_card_detail\""
input CreditCardDetailAvgOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"credit_card_detail\". All fields are combined with a logical 'AND'."
input CreditCardDetailBoolExp {
    _and: [CreditCardDetailBoolExp!]
    _not: CreditCardDetailBoolExp
    _or: [CreditCardDetailBoolExp!]
    amount: NumericComparisonExp
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    credit_card_summary: CreditCardSummaryBoolExp
    date: DateComparisonExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    memo: StringComparisonExp
    summaryId: UuidComparisonExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"credit_card_detail\""
input CreditCardDetailIncInput {
    amount: numeric
}

"input type for inserting data into table \"credit_card_detail\""
input CreditCardDetailInsertInput {
    amount: numeric
    category: CategoryObjRelInsertInput
    categoryId: uuid
    credit_card_summary: CreditCardSummaryObjRelInsertInput
    date: date
    groupId: uuid
    id: uuid
    memo: String
    summaryId: uuid
    user: UserObjRelInsertInput
    userId: uuid
}

"order by max() on columns of table \"credit_card_detail\""
input CreditCardDetailMaxOrderBy {
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    groupId: OrderBy
    id: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"credit_card_detail\""
input CreditCardDetailMinOrderBy {
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    groupId: OrderBy
    id: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"credit_card_detail\""
input CreditCardDetailOnConflict {
    constraint: CreditCardDetailConstraint!
    updateColumns: [CreditCardDetailUpdateColumn!]! = []
    where: CreditCardDetailBoolExp
}

"Ordering options when selecting data from \"credit_card_detail\"."
input CreditCardDetailOrderBy {
    amount: OrderBy
    category: CategoryOrderBy
    categoryId: OrderBy
    credit_card_summary: CreditCardSummaryOrderBy
    date: OrderBy
    groupId: OrderBy
    id: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: credit_card_detail"
input CreditCardDetailPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"credit_card_detail\""
input CreditCardDetailSetInput {
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    summaryId: uuid
    userId: uuid
}

"order by stddev() on columns of table \"credit_card_detail\""
input CreditCardDetailStddevOrderBy {
    amount: OrderBy
}

"order by stddevPop() on columns of table \"credit_card_detail\""
input CreditCardDetailStddevPopOrderBy {
    amount: OrderBy
}

"order by stddevSamp() on columns of table \"credit_card_detail\""
input CreditCardDetailStddevSampOrderBy {
    amount: OrderBy
}

"Streaming cursor of the table \"credit_card_detail\""
input CreditCardDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CreditCardDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CreditCardDetailStreamCursorValueInput {
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    summaryId: uuid
    userId: uuid
}

"order by sum() on columns of table \"credit_card_detail\""
input CreditCardDetailSumOrderBy {
    amount: OrderBy
}

input CreditCardDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: CreditCardDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: CreditCardDetailSetInput
    "filter the rows which have to be updated"
    where: CreditCardDetailBoolExp!
}

"order by varPop() on columns of table \"credit_card_detail\""
input CreditCardDetailVarPopOrderBy {
    amount: OrderBy
}

"order by varSamp() on columns of table \"credit_card_detail\""
input CreditCardDetailVarSampOrderBy {
    amount: OrderBy
}

"order by variance() on columns of table \"credit_card_detail\""
input CreditCardDetailVarianceOrderBy {
    amount: OrderBy
}

input CreditCardSummaryAggregateBoolExp {
    count: creditCardSummaryAggregateBoolExpCount
}

"order by aggregate values of table \"credit_card_summary\""
input CreditCardSummaryAggregateOrderBy {
    avg: CreditCardSummaryAvgOrderBy
    count: OrderBy
    max: CreditCardSummaryMaxOrderBy
    min: CreditCardSummaryMinOrderBy
    stddev: CreditCardSummaryStddevOrderBy
    stddevPop: CreditCardSummaryStddevPopOrderBy
    stddevSamp: CreditCardSummaryStddevSampOrderBy
    sum: CreditCardSummarySumOrderBy
    varPop: CreditCardSummaryVarPopOrderBy
    varSamp: CreditCardSummaryVarSampOrderBy
    variance: CreditCardSummaryVarianceOrderBy
}

"input type for inserting array relation for remote table \"credit_card_summary\""
input CreditCardSummaryArrRelInsertInput {
    data: [CreditCardSummaryInsertInput!]!
    "upsert condition"
    onConflict: CreditCardSummaryOnConflict
}

"order by avg() on columns of table \"credit_card_summary\""
input CreditCardSummaryAvgOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Boolean expression to filter rows from the table \"credit_card_summary\". All fields are combined with a logical 'AND'."
input CreditCardSummaryBoolExp {
    _and: [CreditCardSummaryBoolExp!]
    _not: CreditCardSummaryBoolExp
    _or: [CreditCardSummaryBoolExp!]
    account: AccountBoolExp
    accountId: UuidComparisonExp
    count: IntComparisonExp
    creditCard: StringComparisonExp
    credit_card_details: CreditCardDetailBoolExp
    credit_card_detailsAggregate: CreditCardDetailAggregateBoolExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    import_file_history: ImportFileHistoryBoolExp
    totalAmount: NumericComparisonExp
    withdrawalDate: DateComparisonExp
}

"input type for incrementing numeric columns in table \"credit_card_summary\""
input CreditCardSummaryIncInput {
    count: Int
    totalAmount: numeric
}

"input type for inserting data into table \"credit_card_summary\""
input CreditCardSummaryInsertInput {
    account: AccountObjRelInsertInput
    accountId: uuid
    count: Int
    creditCard: String
    credit_card_details: CreditCardDetailArrRelInsertInput
    group: GroupObjRelInsertInput
    groupId: uuid
    id: uuid
    import_file_history: ImportFileHistoryObjRelInsertInput
    totalAmount: numeric
    withdrawalDate: date
}

"order by max() on columns of table \"credit_card_summary\""
input CreditCardSummaryMaxOrderBy {
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"order by min() on columns of table \"credit_card_summary\""
input CreditCardSummaryMinOrderBy {
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"input type for inserting object relation for remote table \"credit_card_summary\""
input CreditCardSummaryObjRelInsertInput {
    data: CreditCardSummaryInsertInput!
    "upsert condition"
    onConflict: CreditCardSummaryOnConflict
}

"on_conflict condition type for table \"credit_card_summary\""
input CreditCardSummaryOnConflict {
    constraint: CreditCardSummaryConstraint!
    updateColumns: [CreditCardSummaryUpdateColumn!]! = []
    where: CreditCardSummaryBoolExp
}

"Ordering options when selecting data from \"credit_card_summary\"."
input CreditCardSummaryOrderBy {
    account: AccountOrderBy
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    credit_card_detailsAggregate: CreditCardDetailAggregateOrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    import_file_history: ImportFileHistoryOrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"primary key columns input for table: credit_card_summary"
input CreditCardSummaryPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"credit_card_summary\""
input CreditCardSummarySetInput {
    accountId: uuid
    count: Int
    creditCard: String
    groupId: uuid
    id: uuid
    totalAmount: numeric
    withdrawalDate: date
}

"order by stddev() on columns of table \"credit_card_summary\""
input CreditCardSummaryStddevOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by stddevPop() on columns of table \"credit_card_summary\""
input CreditCardSummaryStddevPopOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by stddevSamp() on columns of table \"credit_card_summary\""
input CreditCardSummaryStddevSampOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Streaming cursor of the table \"credit_card_summary\""
input CreditCardSummaryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CreditCardSummaryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CreditCardSummaryStreamCursorValueInput {
    accountId: uuid
    count: Int
    creditCard: String
    groupId: uuid
    id: uuid
    totalAmount: numeric
    withdrawalDate: date
}

"order by sum() on columns of table \"credit_card_summary\""
input CreditCardSummarySumOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Boolean expression to filter rows from the table \"credit_card_summary_total_by_account_view\". All fields are combined with a logical 'AND'."
input CreditCardSummaryTotalByAccountViewBoolExp {
    _and: [CreditCardSummaryTotalByAccountViewBoolExp!]
    _not: CreditCardSummaryTotalByAccountViewBoolExp
    _or: [CreditCardSummaryTotalByAccountViewBoolExp!]
    accountId: UuidComparisonExp
    accountName: StringComparisonExp
    date: DateComparisonExp
    displayOrder: IntComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"credit_card_summary_total_by_account_view\"."
input CreditCardSummaryTotalByAccountViewOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    date: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"credit_card_summary_total_by_account_view\""
input CreditCardSummaryTotalByAccountViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: CreditCardSummaryTotalByAccountViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input CreditCardSummaryTotalByAccountViewStreamCursorValueInput {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

input CreditCardSummaryUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: CreditCardSummaryIncInput
    "sets the columns of the filtered rows to the given values"
    _set: CreditCardSummarySetInput
    "filter the rows which have to be updated"
    where: CreditCardSummaryBoolExp!
}

"order by varPop() on columns of table \"credit_card_summary\""
input CreditCardSummaryVarPopOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by varSamp() on columns of table \"credit_card_summary\""
input CreditCardSummaryVarSampOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by variance() on columns of table \"credit_card_summary\""
input CreditCardSummaryVarianceOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

input DailyDetailAggregateBoolExp {
    count: dailyDetailAggregateBoolExpCount
}

"order by aggregate values of table \"daily_detail\""
input DailyDetailAggregateOrderBy {
    avg: DailyDetailAvgOrderBy
    count: OrderBy
    max: DailyDetailMaxOrderBy
    min: DailyDetailMinOrderBy
    stddev: DailyDetailStddevOrderBy
    stddevPop: DailyDetailStddevPopOrderBy
    stddevSamp: DailyDetailStddevSampOrderBy
    sum: DailyDetailSumOrderBy
    varPop: DailyDetailVarPopOrderBy
    varSamp: DailyDetailVarSampOrderBy
    variance: DailyDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"daily_detail\""
input DailyDetailArrRelInsertInput {
    data: [DailyDetailInsertInput!]!
    "upsert condition"
    onConflict: DailyDetailOnConflict
}

"order by avg() on columns of table \"daily_detail\""
input DailyDetailAvgOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"daily_detail\". All fields are combined with a logical 'AND'."
input DailyDetailBoolExp {
    _and: [DailyDetailBoolExp!]
    _not: DailyDetailBoolExp
    _or: [DailyDetailBoolExp!]
    account: AccountBoolExp
    accountId: UuidComparisonExp
    amount: NumericComparisonExp
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    date: DateComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    memo: StringComparisonExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"daily_detail\""
input DailyDetailIncInput {
    amount: numeric
}

"input type for inserting data into table \"daily_detail\""
input DailyDetailInsertInput {
    account: AccountObjRelInsertInput
    accountId: uuid
    amount: numeric
    category: CategoryObjRelInsertInput
    categoryId: uuid
    date: date
    group: GroupObjRelInsertInput
    groupId: uuid
    id: uuid
    memo: String
    user: UserObjRelInsertInput
    userId: uuid
}

"order by max() on columns of table \"daily_detail\""
input DailyDetailMaxOrderBy {
    accountId: OrderBy
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    groupId: OrderBy
    id: OrderBy
    memo: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"daily_detail\""
input DailyDetailMinOrderBy {
    accountId: OrderBy
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    groupId: OrderBy
    id: OrderBy
    memo: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"daily_detail\""
input DailyDetailOnConflict {
    constraint: DailyDetailConstraint!
    updateColumns: [DailyDetailUpdateColumn!]! = []
    where: DailyDetailBoolExp
}

"Ordering options when selecting data from \"daily_detail\"."
input DailyDetailOrderBy {
    account: AccountOrderBy
    accountId: OrderBy
    amount: OrderBy
    category: CategoryOrderBy
    categoryId: OrderBy
    date: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    memo: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: daily_detail"
input DailyDetailPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"daily_detail\""
input DailyDetailSetInput {
    accountId: uuid
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    userId: uuid
}

"order by stddev() on columns of table \"daily_detail\""
input DailyDetailStddevOrderBy {
    amount: OrderBy
}

"order by stddevPop() on columns of table \"daily_detail\""
input DailyDetailStddevPopOrderBy {
    amount: OrderBy
}

"order by stddevSamp() on columns of table \"daily_detail\""
input DailyDetailStddevSampOrderBy {
    amount: OrderBy
}

"Streaming cursor of the table \"daily_detail\""
input DailyDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: DailyDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input DailyDetailStreamCursorValueInput {
    accountId: uuid
    amount: numeric
    categoryId: uuid
    date: date
    groupId: uuid
    id: uuid
    memo: String
    userId: uuid
}

"order by sum() on columns of table \"daily_detail\""
input DailyDetailSumOrderBy {
    amount: OrderBy
}

input DailyDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: DailyDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: DailyDetailSetInput
    "filter the rows which have to be updated"
    where: DailyDetailBoolExp!
}

"order by varPop() on columns of table \"daily_detail\""
input DailyDetailVarPopOrderBy {
    amount: OrderBy
}

"order by varSamp() on columns of table \"daily_detail\""
input DailyDetailVarSampOrderBy {
    amount: OrderBy
}

"order by variance() on columns of table \"daily_detail\""
input DailyDetailVarianceOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"daily_total_view\". All fields are combined with a logical 'AND'."
input DailyTotalViewBoolExp {
    _and: [DailyTotalViewBoolExp!]
    _not: DailyTotalViewBoolExp
    _or: [DailyTotalViewBoolExp!]
    date: DateComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"daily_total_view\"."
input DailyTotalViewOrderBy {
    date: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"daily_total_view\""
input DailyTotalViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: DailyTotalViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input DailyTotalViewStreamCursorValueInput {
    date: date
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input DateComparisonExp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _isNull: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

input GenreAggregateBoolExp {
    bool_and: genreAggregateBoolExpBool_and
    bool_or: genreAggregateBoolExpBool_or
    count: genreAggregateBoolExpCount
}

"order by aggregate values of table \"genre\""
input GenreAggregateOrderBy {
    avg: GenreAvgOrderBy
    count: OrderBy
    max: GenreMaxOrderBy
    min: GenreMinOrderBy
    stddev: GenreStddevOrderBy
    stddevPop: GenreStddevPopOrderBy
    stddevSamp: GenreStddevSampOrderBy
    sum: GenreSumOrderBy
    varPop: GenreVarPopOrderBy
    varSamp: GenreVarSampOrderBy
    variance: GenreVarianceOrderBy
}

"input type for inserting array relation for remote table \"genre\""
input GenreArrRelInsertInput {
    data: [GenreInsertInput!]!
    "upsert condition"
    onConflict: GenreOnConflict
}

"order by avg() on columns of table \"genre\""
input GenreAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"genre\". All fields are combined with a logical 'AND'."
input GenreBoolExp {
    _and: [GenreBoolExp!]
    _not: GenreBoolExp
    _or: [GenreBoolExp!]
    categories: CategoryBoolExp
    categoriesAggregate: CategoryAggregateBoolExp
    displayOrder: IntComparisonExp
    genreId: UuidComparisonExp
    genreName: StringComparisonExp
    genreType: GenreTypeComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"genre\""
input GenreIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"genre\""
input GenreInsertInput {
    categories: CategoryArrRelInsertInput
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    group: GroupObjRelInsertInput
    groupId: uuid
    iocomeType: iocome_type
    validFlag: Boolean
}

"order by max() on columns of table \"genre\""
input GenreMaxOrderBy {
    displayOrder: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    genreType: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
}

"order by min() on columns of table \"genre\""
input GenreMinOrderBy {
    displayOrder: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    genreType: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
}

"input type for inserting object relation for remote table \"genre\""
input GenreObjRelInsertInput {
    data: GenreInsertInput!
    "upsert condition"
    onConflict: GenreOnConflict
}

"on_conflict condition type for table \"genre\""
input GenreOnConflict {
    constraint: GenreConstraint!
    updateColumns: [GenreUpdateColumn!]! = []
    where: GenreBoolExp
}

"Ordering options when selecting data from \"genre\"."
input GenreOrderBy {
    categoriesAggregate: CategoryAggregateOrderBy
    displayOrder: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    genreType: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    validFlag: OrderBy
}

"primary key columns input for table: genre"
input GenrePkColumnsInput {
    genreId: uuid!
}

"input type for updating data in table \"genre\""
input GenreSetInput {
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
    validFlag: Boolean
}

"order by stddev() on columns of table \"genre\""
input GenreStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"genre\""
input GenreStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"genre\""
input GenreStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"genre\""
input GenreStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GenreStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GenreStreamCursorValueInput {
    displayOrder: Int
    genreId: uuid
    genreName: String
    genreType: genre_type
    groupId: uuid
    iocomeType: iocome_type
    validFlag: Boolean
}

"order by sum() on columns of table \"genre\""
input GenreSumOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to compare columns of type \"genre_type\". All fields are combined with logical 'AND'."
input GenreTypeComparisonExp {
    _eq: genre_type
    _gt: genre_type
    _gte: genre_type
    _in: [genre_type!]
    _isNull: Boolean
    _lt: genre_type
    _lte: genre_type
    _neq: genre_type
    _nin: [genre_type!]
}

input GenreUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: GenreIncInput
    "sets the columns of the filtered rows to the given values"
    _set: GenreSetInput
    "filter the rows which have to be updated"
    where: GenreBoolExp!
}

"order by varPop() on columns of table \"genre\""
input GenreVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"genre\""
input GenreVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"genre\""
input GenreVarianceOrderBy {
    displayOrder: OrderBy
}

input GroupApplicationAggregateBoolExp {
    count: groupApplicationAggregateBoolExpCount
}

"order by aggregate values of table \"group_application\""
input GroupApplicationAggregateOrderBy {
    count: OrderBy
    max: GroupApplicationMaxOrderBy
    min: GroupApplicationMinOrderBy
}

"input type for inserting array relation for remote table \"group_application\""
input GroupApplicationArrRelInsertInput {
    data: [GroupApplicationInsertInput!]!
    "upsert condition"
    onConflict: GroupApplicationOnConflict
}

"Boolean expression to filter rows from the table \"group_application\". All fields are combined with a logical 'AND'."
input GroupApplicationBoolExp {
    _and: [GroupApplicationBoolExp!]
    _not: GroupApplicationBoolExp
    _or: [GroupApplicationBoolExp!]
    application: ApplicationBoolExp
    applicationId: UuidComparisonExp
    group: GroupBoolExp
    groupApplicationId: UuidComparisonExp
    groupId: UuidComparisonExp
}

"input type for inserting data into table \"group_application\""
input GroupApplicationInsertInput {
    application: ApplicationObjRelInsertInput
    applicationId: uuid
    group: GroupObjRelInsertInput
    groupApplicationId: uuid
    groupId: uuid
}

"order by max() on columns of table \"group_application\""
input GroupApplicationMaxOrderBy {
    applicationId: OrderBy
    groupApplicationId: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"group_application\""
input GroupApplicationMinOrderBy {
    applicationId: OrderBy
    groupApplicationId: OrderBy
    groupId: OrderBy
}

"on_conflict condition type for table \"group_application\""
input GroupApplicationOnConflict {
    constraint: GroupApplicationConstraint!
    updateColumns: [GroupApplicationUpdateColumn!]! = []
    where: GroupApplicationBoolExp
}

"Ordering options when selecting data from \"group_application\"."
input GroupApplicationOrderBy {
    application: ApplicationOrderBy
    applicationId: OrderBy
    group: GroupOrderBy
    groupApplicationId: OrderBy
    groupId: OrderBy
}

"primary key columns input for table: group_application"
input GroupApplicationPkColumnsInput {
    groupApplicationId: uuid!
}

"input type for updating data in table \"group_application\""
input GroupApplicationSetInput {
    applicationId: uuid
    groupApplicationId: uuid
    groupId: uuid
}

"Streaming cursor of the table \"group_application\""
input GroupApplicationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupApplicationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupApplicationStreamCursorValueInput {
    applicationId: uuid
    groupApplicationId: uuid
    groupId: uuid
}

input GroupApplicationUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: GroupApplicationSetInput
    "filter the rows which have to be updated"
    where: GroupApplicationBoolExp!
}

"Boolean expression to filter rows from the table \"group\". All fields are combined with a logical 'AND'."
input GroupBoolExp {
    _and: [GroupBoolExp!]
    _not: GroupBoolExp
    _or: [GroupBoolExp!]
    accounts: AccountBoolExp
    accountsAggregate: AccountAggregateBoolExp
    affiliations: AffiliationBoolExp
    affiliationsAggregate: AffiliationAggregateBoolExp
    categories: CategoryBoolExp
    categoriesAggregate: CategoryAggregateBoolExp
    credit_card_summaries: CreditCardSummaryBoolExp
    credit_card_summariesAggregate: CreditCardSummaryAggregateBoolExp
    daily_details: DailyDetailBoolExp
    daily_detailsAggregate: DailyDetailAggregateBoolExp
    genres: GenreBoolExp
    genresAggregate: GenreAggregateBoolExp
    groupId: UuidComparisonExp
    groupName: StringComparisonExp
    group_applications: GroupApplicationBoolExp
    group_applicationsAggregate: GroupApplicationAggregateBoolExp
    import_file_histories: ImportFileHistoryBoolExp
    import_file_historiesAggregate: ImportFileHistoryAggregateBoolExp
    summary_category_by_groups: SummaryCategoryByGroupBoolExp
    summary_category_by_groupsAggregate: SummaryCategoryByGroupAggregateBoolExp
}

"input type for inserting data into table \"group\""
input GroupInsertInput {
    accounts: AccountArrRelInsertInput
    affiliations: AffiliationArrRelInsertInput
    categories: CategoryArrRelInsertInput
    credit_card_summaries: CreditCardSummaryArrRelInsertInput
    daily_details: DailyDetailArrRelInsertInput
    genres: GenreArrRelInsertInput
    groupId: uuid
    groupName: String
    group_applications: GroupApplicationArrRelInsertInput
    import_file_histories: ImportFileHistoryArrRelInsertInput
    summary_category_by_groups: SummaryCategoryByGroupArrRelInsertInput
}

"input type for inserting object relation for remote table \"group\""
input GroupObjRelInsertInput {
    data: GroupInsertInput!
    "upsert condition"
    onConflict: GroupOnConflict
}

"on_conflict condition type for table \"group\""
input GroupOnConflict {
    constraint: GroupConstraint!
    updateColumns: [GroupUpdateColumn!]! = []
    where: GroupBoolExp
}

"Ordering options when selecting data from \"group\"."
input GroupOrderBy {
    accountsAggregate: AccountAggregateOrderBy
    affiliationsAggregate: AffiliationAggregateOrderBy
    categoriesAggregate: CategoryAggregateOrderBy
    credit_card_summariesAggregate: CreditCardSummaryAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    genresAggregate: GenreAggregateOrderBy
    groupId: OrderBy
    groupName: OrderBy
    group_applicationsAggregate: GroupApplicationAggregateOrderBy
    import_file_historiesAggregate: ImportFileHistoryAggregateOrderBy
    summary_category_by_groupsAggregate: SummaryCategoryByGroupAggregateOrderBy
}

"primary key columns input for table: group"
input GroupPkColumnsInput {
    groupId: uuid!
}

"Boolean expression to filter rows from the table \"group_role\". All fields are combined with a logical 'AND'."
input GroupRoleBoolExp {
    _and: [GroupRoleBoolExp!]
    _not: GroupRoleBoolExp
    _or: [GroupRoleBoolExp!]
    affiliations: AffiliationBoolExp
    affiliationsAggregate: AffiliationAggregateBoolExp
    groupRoleId: UuidComparisonExp
    role: StringComparisonExp
}

"input type for inserting data into table \"group_role\""
input GroupRoleInsertInput {
    affiliations: AffiliationArrRelInsertInput
    groupRoleId: uuid
    role: String
}

"input type for inserting object relation for remote table \"group_role\""
input GroupRoleObjRelInsertInput {
    data: GroupRoleInsertInput!
    "upsert condition"
    onConflict: GroupRoleOnConflict
}

"on_conflict condition type for table \"group_role\""
input GroupRoleOnConflict {
    constraint: GroupRoleConstraint!
    updateColumns: [GroupRoleUpdateColumn!]! = []
    where: GroupRoleBoolExp
}

"Ordering options when selecting data from \"group_role\"."
input GroupRoleOrderBy {
    affiliationsAggregate: AffiliationAggregateOrderBy
    groupRoleId: OrderBy
    role: OrderBy
}

"primary key columns input for table: group_role"
input GroupRolePkColumnsInput {
    groupRoleId: uuid!
}

"input type for updating data in table \"group_role\""
input GroupRoleSetInput {
    groupRoleId: uuid
    role: String
}

"Streaming cursor of the table \"group_role\""
input GroupRoleStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupRoleStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupRoleStreamCursorValueInput {
    groupRoleId: uuid
    role: String
}

input GroupRoleUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: GroupRoleSetInput
    "filter the rows which have to be updated"
    where: GroupRoleBoolExp!
}

"input type for updating data in table \"group\""
input GroupSetInput {
    groupId: uuid
    groupName: String
}

"Streaming cursor of the table \"group\""
input GroupStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupStreamCursorValueInput {
    groupId: uuid
    groupName: String
}

input GroupUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: GroupSetInput
    "filter the rows which have to be updated"
    where: GroupBoolExp!
}

"Boolean expression to filter rows from the table \"helper_kids.exchange_item\". All fields are combined with a logical 'AND'."
input HelperKidsExchangeItemBoolExp {
    _and: [HelperKidsExchangeItemBoolExp!]
    _not: HelperKidsExchangeItemBoolExp
    _or: [HelperKidsExchangeItemBoolExp!]
    exchangeItemId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementBoolExp
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateBoolExp
    memo: StringComparisonExp
    name: StringComparisonExp
    point: IntComparisonExp
}

"input type for incrementing numeric columns in table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemIncInput {
    "交換ポイント"
    point: Int
}

"input type for inserting data into table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemInsertInput {
    "ID"
    exchangeItemId: uuid
    group: GroupObjRelInsertInput
    "グループID"
    groupId: uuid
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementArrRelInsertInput
    "メモ"
    memo: String
    "品名"
    name: String
    "交換ポイント"
    point: Int
}

"input type for inserting object relation for remote table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemObjRelInsertInput {
    data: HelperKidsExchangeItemInsertInput!
    "upsert condition"
    onConflict: HelperKidsExchangeItemOnConflict
}

"on_conflict condition type for table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemOnConflict {
    constraint: HelperKidsExchangeItemConstraint!
    updateColumns: [HelperKidsExchangeItemUpdateColumn!]! = []
    where: HelperKidsExchangeItemBoolExp
}

"Ordering options when selecting data from \"helper_kids.exchange_item\"."
input HelperKidsExchangeItemOrderBy {
    exchangeItemId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateOrderBy
    memo: OrderBy
    name: OrderBy
    point: OrderBy
}

"primary key columns input for table: helper_kids.exchange_item"
input HelperKidsExchangeItemPkColumnsInput {
    "ID"
    exchangeItemId: uuid!
}

"input type for updating data in table \"helper_kids.exchange_item\""
input HelperKidsExchangeItemSetInput {
    "ID"
    exchangeItemId: uuid
    "グループID"
    groupId: uuid
    "メモ"
    memo: String
    "品名"
    name: String
    "交換ポイント"
    point: Int
}

"Streaming cursor of the table \"helper_kids_exchange_item\""
input HelperKidsExchangeItemStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsExchangeItemStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsExchangeItemStreamCursorValueInput {
    "ID"
    exchangeItemId: uuid
    "グループID"
    groupId: uuid
    "メモ"
    memo: String
    "品名"
    name: String
    "交換ポイント"
    point: Int
}

input HelperKidsExchangeItemUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HelperKidsExchangeItemIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsExchangeItemSetInput
    "filter the rows which have to be updated"
    where: HelperKidsExchangeItemBoolExp!
}

"Boolean expression to filter rows from the table \"helper_kids.help_item\". All fields are combined with a logical 'AND'."
input HelperKidsHelpItemBoolExp {
    _and: [HelperKidsHelpItemBoolExp!]
    _not: HelperKidsHelpItemBoolExp
    _or: [HelperKidsHelpItemBoolExp!]
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpItemId: UuidComparisonExp
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailBoolExp
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateBoolExp
    memo: StringComparisonExp
    name: StringComparisonExp
    point: IntComparisonExp
}

"input type for incrementing numeric columns in table \"helper_kids.help_item\""
input HelperKidsHelpItemIncInput {
    "お手伝いポイント"
    point: Int
}

"input type for inserting data into table \"helper_kids.help_item\""
input HelperKidsHelpItemInsertInput {
    group: GroupObjRelInsertInput
    "グループID"
    groupId: uuid
    "ID"
    helpItemId: uuid
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailArrRelInsertInput
    "メモ"
    memo: String
    "項目名"
    name: String
    "お手伝いポイント"
    point: Int
}

"input type for inserting object relation for remote table \"helper_kids.help_item\""
input HelperKidsHelpItemObjRelInsertInput {
    data: HelperKidsHelpItemInsertInput!
    "upsert condition"
    onConflict: HelperKidsHelpItemOnConflict
}

"on_conflict condition type for table \"helper_kids.help_item\""
input HelperKidsHelpItemOnConflict {
    constraint: HelperKidsHelpItemConstraint!
    updateColumns: [HelperKidsHelpItemUpdateColumn!]! = []
    where: HelperKidsHelpItemBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_item\"."
input HelperKidsHelpItemOrderBy {
    group: GroupOrderBy
    groupId: OrderBy
    helpItemId: OrderBy
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateOrderBy
    memo: OrderBy
    name: OrderBy
    point: OrderBy
}

"primary key columns input for table: helper_kids.help_item"
input HelperKidsHelpItemPkColumnsInput {
    "ID"
    helpItemId: uuid!
}

"input type for updating data in table \"helper_kids.help_item\""
input HelperKidsHelpItemSetInput {
    "グループID"
    groupId: uuid
    "ID"
    helpItemId: uuid
    "メモ"
    memo: String
    "項目名"
    name: String
    "お手伝いポイント"
    point: Int
}

"Streaming cursor of the table \"helper_kids_help_item\""
input HelperKidsHelpItemStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpItemStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpItemStreamCursorValueInput {
    "グループID"
    groupId: uuid
    "ID"
    helpItemId: uuid
    "メモ"
    memo: String
    "項目名"
    name: String
    "お手伝いポイント"
    point: Int
}

input HelperKidsHelpItemUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HelperKidsHelpItemIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelpItemSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelpItemBoolExp!
}

input HelperKidsHelpPointEarnedAchievementAggregateBoolExp {
    count: helperKidsHelpPointEarnedAchievementAggregateBoolExpCount
}

"order by aggregate values of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementAggregateOrderBy {
    avg: HelperKidsHelpPointEarnedAchievementAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpPointEarnedAchievementMaxOrderBy
    min: HelperKidsHelpPointEarnedAchievementMinOrderBy
    stddev: HelperKidsHelpPointEarnedAchievementStddevOrderBy
    stddevPop: HelperKidsHelpPointEarnedAchievementStddevPopOrderBy
    stddevSamp: HelperKidsHelpPointEarnedAchievementStddevSampOrderBy
    sum: HelperKidsHelpPointEarnedAchievementSumOrderBy
    varPop: HelperKidsHelpPointEarnedAchievementVarPopOrderBy
    varSamp: HelperKidsHelpPointEarnedAchievementVarSampOrderBy
    variance: HelperKidsHelpPointEarnedAchievementVarianceOrderBy
}

"input type for inserting array relation for remote table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementArrRelInsertInput {
    data: [HelperKidsHelpPointEarnedAchievementInsertInput!]!
    "upsert condition"
    onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
}

"order by avg() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementAvgOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_point_earned_achievement\". All fields are combined with a logical 'AND'."
input HelperKidsHelpPointEarnedAchievementBoolExp {
    _and: [HelperKidsHelpPointEarnedAchievementBoolExp!]
    _not: HelperKidsHelpPointEarnedAchievementBoolExp
    _or: [HelperKidsHelpPointEarnedAchievementBoolExp!]
    earnedDatetime: TimestampComparisonExp
    earnedPoint: IntComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointEarnedAchievementId: UuidComparisonExp
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailBoolExp
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateBoolExp
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementIncInput {
    "獲得ポイント"
    earnedPoint: Int
}

"input type for inserting data into table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementInsertInput {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    group: GroupObjRelInsertInput
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    helpPointEarnedDetails: HelperKidsHelpPointEarnedDetailArrRelInsertInput
    helperKid: HelperKidsHelperKidObjRelInsertInput
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by max() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementMaxOrderBy {
    "獲得日時"
    earnedDatetime: OrderBy
    "獲得ポイント"
    earnedPoint: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointEarnedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"order by min() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementMinOrderBy {
    "獲得日時"
    earnedDatetime: OrderBy
    "獲得ポイント"
    earnedPoint: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointEarnedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"input type for inserting object relation for remote table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementObjRelInsertInput {
    data: HelperKidsHelpPointEarnedAchievementInsertInput!
    "upsert condition"
    onConflict: HelperKidsHelpPointEarnedAchievementOnConflict
}

"on_conflict condition type for table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementOnConflict {
    constraint: HelperKidsHelpPointEarnedAchievementConstraint!
    updateColumns: [HelperKidsHelpPointEarnedAchievementUpdateColumn!]! = []
    where: HelperKidsHelpPointEarnedAchievementBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_point_earned_achievement\"."
input HelperKidsHelpPointEarnedAchievementOrderBy {
    earnedDatetime: OrderBy
    earnedPoint: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpPointEarnedAchievementId: OrderBy
    helpPointEarnedDetailsAggregate: HelperKidsHelpPointEarnedDetailAggregateOrderBy
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
}

"primary key columns input for table: helper_kids.help_point_earned_achievement"
input HelperKidsHelpPointEarnedAchievementPkColumnsInput {
    "ID"
    helpPointEarnedAchievementId: uuid!
}

"input type for updating data in table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementSetInput {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by stddev() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStddevOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStddevPopOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStddevSampOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpPointEarnedAchievementStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpPointEarnedAchievementStreamCursorValueInput {
    "獲得日時"
    earnedDatetime: timestamp
    "獲得ポイント"
    earnedPoint: Int
    "グループID"
    groupId: uuid
    "ID"
    helpPointEarnedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by sum() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementSumOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

input HelperKidsHelpPointEarnedAchievementUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HelperKidsHelpPointEarnedAchievementIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelpPointEarnedAchievementSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelpPointEarnedAchievementBoolExp!
}

"order by varPop() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementVarPopOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementVarSampOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_point_earned_achievement\""
input HelperKidsHelpPointEarnedAchievementVarianceOrderBy {
    "獲得ポイント"
    earnedPoint: OrderBy
}

input HelperKidsHelpPointEarnedDetailAggregateBoolExp {
    count: helperKidsHelpPointEarnedDetailAggregateBoolExpCount
}

"order by aggregate values of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailAggregateOrderBy {
    avg: HelperKidsHelpPointEarnedDetailAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpPointEarnedDetailMaxOrderBy
    min: HelperKidsHelpPointEarnedDetailMinOrderBy
    stddev: HelperKidsHelpPointEarnedDetailStddevOrderBy
    stddevPop: HelperKidsHelpPointEarnedDetailStddevPopOrderBy
    stddevSamp: HelperKidsHelpPointEarnedDetailStddevSampOrderBy
    sum: HelperKidsHelpPointEarnedDetailSumOrderBy
    varPop: HelperKidsHelpPointEarnedDetailVarPopOrderBy
    varSamp: HelperKidsHelpPointEarnedDetailVarSampOrderBy
    variance: HelperKidsHelpPointEarnedDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailArrRelInsertInput {
    data: [HelperKidsHelpPointEarnedDetailInsertInput!]!
    "upsert condition"
    onConflict: HelperKidsHelpPointEarnedDetailOnConflict
}

"order by avg() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailAvgOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_point_earned_detail\". All fields are combined with a logical 'AND'."
input HelperKidsHelpPointEarnedDetailBoolExp {
    _and: [HelperKidsHelpPointEarnedDetailBoolExp!]
    _not: HelperKidsHelpPointEarnedDetailBoolExp
    _or: [HelperKidsHelpPointEarnedDetailBoolExp!]
    earnedAchievementId: UuidComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpItem: HelperKidsHelpItemBoolExp
    helpItemCount: IntComparisonExp
    helpItemId: UuidComparisonExp
    helpItemTotalPoint: IntComparisonExp
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievementBoolExp
    helpPointEarnedDetailId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailIncInput {
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
}

"input type for inserting data into table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailInsertInput {
    "獲得実績ID"
    earnedAchievementId: uuid
    group: GroupObjRelInsertInput
    "グループID"
    groupId: uuid
    helpItem: HelperKidsHelpItemObjRelInsertInput
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievementObjRelInsertInput
    "ID"
    helpPointEarnedDetailId: uuid
}

"order by max() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailMaxOrderBy {
    "獲得実績ID"
    earnedAchievementId: OrderBy
    "グループID"
    groupId: OrderBy
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目ID"
    helpItemId: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
    "ID"
    helpPointEarnedDetailId: OrderBy
}

"order by min() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailMinOrderBy {
    "獲得実績ID"
    earnedAchievementId: OrderBy
    "グループID"
    groupId: OrderBy
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目ID"
    helpItemId: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
    "ID"
    helpPointEarnedDetailId: OrderBy
}

"on_conflict condition type for table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailOnConflict {
    constraint: HelperKidsHelpPointEarnedDetailConstraint!
    updateColumns: [HelperKidsHelpPointEarnedDetailUpdateColumn!]! = []
    where: HelperKidsHelpPointEarnedDetailBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_point_earned_detail\"."
input HelperKidsHelpPointEarnedDetailOrderBy {
    earnedAchievementId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpItem: HelperKidsHelpItemOrderBy
    helpItemCount: OrderBy
    helpItemId: OrderBy
    helpItemTotalPoint: OrderBy
    helpPointEarnedAchievement: HelperKidsHelpPointEarnedAchievementOrderBy
    helpPointEarnedDetailId: OrderBy
}

"primary key columns input for table: helper_kids.help_point_earned_detail"
input HelperKidsHelpPointEarnedDetailPkColumnsInput {
    "ID"
    helpPointEarnedDetailId: uuid!
}

"input type for updating data in table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailSetInput {
    "獲得実績ID"
    earnedAchievementId: uuid
    "グループID"
    groupId: uuid
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    "ID"
    helpPointEarnedDetailId: uuid
}

"order by stddev() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStddevOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStddevPopOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStddevSampOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpPointEarnedDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpPointEarnedDetailStreamCursorValueInput {
    "獲得実績ID"
    earnedAchievementId: uuid
    "グループID"
    groupId: uuid
    "お手伝い項目件数"
    helpItemCount: Int
    "お手伝い項目ID"
    helpItemId: uuid
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: Int
    "ID"
    helpPointEarnedDetailId: uuid
}

"order by sum() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailSumOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

input HelperKidsHelpPointEarnedDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HelperKidsHelpPointEarnedDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelpPointEarnedDetailSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelpPointEarnedDetailBoolExp!
}

"order by varPop() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailVarPopOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailVarSampOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_point_earned_detail\""
input HelperKidsHelpPointEarnedDetailVarianceOrderBy {
    "お手伝い項目件数"
    helpItemCount: OrderBy
    "お手伝い項目合計ポイント"
    helpItemTotalPoint: OrderBy
}

input HelperKidsHelpPointExchangedAchievementAggregateBoolExp {
    count: helperKidsHelpPointExchangedAchievementAggregateBoolExpCount
}

"order by aggregate values of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementAggregateOrderBy {
    avg: HelperKidsHelpPointExchangedAchievementAvgOrderBy
    count: OrderBy
    max: HelperKidsHelpPointExchangedAchievementMaxOrderBy
    min: HelperKidsHelpPointExchangedAchievementMinOrderBy
    stddev: HelperKidsHelpPointExchangedAchievementStddevOrderBy
    stddevPop: HelperKidsHelpPointExchangedAchievementStddevPopOrderBy
    stddevSamp: HelperKidsHelpPointExchangedAchievementStddevSampOrderBy
    sum: HelperKidsHelpPointExchangedAchievementSumOrderBy
    varPop: HelperKidsHelpPointExchangedAchievementVarPopOrderBy
    varSamp: HelperKidsHelpPointExchangedAchievementVarSampOrderBy
    variance: HelperKidsHelpPointExchangedAchievementVarianceOrderBy
}

"input type for inserting array relation for remote table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementArrRelInsertInput {
    data: [HelperKidsHelpPointExchangedAchievementInsertInput!]!
    "upsert condition"
    onConflict: HelperKidsHelpPointExchangedAchievementOnConflict
}

"order by avg() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementAvgOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.help_point_exchanged_achievement\". All fields are combined with a logical 'AND'."
input HelperKidsHelpPointExchangedAchievementBoolExp {
    _and: [HelperKidsHelpPointExchangedAchievementBoolExp!]
    _not: HelperKidsHelpPointExchangedAchievementBoolExp
    _or: [HelperKidsHelpPointExchangedAchievementBoolExp!]
    exchangeCount: IntComparisonExp
    exchangeItem: HelperKidsExchangeItemBoolExp
    exchangeItemId: UuidComparisonExp
    exchangeTotalPoint: IntComparisonExp
    exchangedDatetime: TimestampComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointExchangedAchievementId: UuidComparisonExp
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementIncInput {
    "交換件数"
    exchangeCount: Int
    "交換合計ポイント"
    exchangeTotalPoint: Int
}

"input type for inserting data into table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementInsertInput {
    "交換件数"
    exchangeCount: Int
    exchangeItem: HelperKidsExchangeItemObjRelInsertInput
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    group: GroupObjRelInsertInput
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    helperKid: HelperKidsHelperKidObjRelInsertInput
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by max() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementMaxOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換品ID"
    exchangeItemId: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
    "交換日時"
    exchangedDatetime: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointExchangedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"order by min() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementMinOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換品ID"
    exchangeItemId: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
    "交換日時"
    exchangedDatetime: OrderBy
    "グループID"
    groupId: OrderBy
    "ID"
    helpPointExchangedAchievementId: OrderBy
    "お手伝いキッズID"
    helperKidId: OrderBy
}

"on_conflict condition type for table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementOnConflict {
    constraint: HelperKidsHelpPointExchangedAchievementConstraint!
    updateColumns: [HelperKidsHelpPointExchangedAchievementUpdateColumn!]! = []
    where: HelperKidsHelpPointExchangedAchievementBoolExp
}

"Ordering options when selecting data from \"helper_kids.help_point_exchanged_achievement\"."
input HelperKidsHelpPointExchangedAchievementOrderBy {
    exchangeCount: OrderBy
    exchangeItem: HelperKidsExchangeItemOrderBy
    exchangeItemId: OrderBy
    exchangeTotalPoint: OrderBy
    exchangedDatetime: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    helpPointExchangedAchievementId: OrderBy
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
}

"primary key columns input for table: helper_kids.help_point_exchanged_achievement"
input HelperKidsHelpPointExchangedAchievementPkColumnsInput {
    "ID"
    helpPointExchangedAchievementId: uuid!
}

"input type for updating data in table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementSetInput {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by stddev() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStddevOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by stddevPop() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStddevPopOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by stddevSamp() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStddevSampOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"Streaming cursor of the table \"helper_kids_help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelpPointExchangedAchievementStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelpPointExchangedAchievementStreamCursorValueInput {
    "交換件数"
    exchangeCount: Int
    "交換品ID"
    exchangeItemId: uuid
    "交換合計ポイント"
    exchangeTotalPoint: Int
    "交換日時"
    exchangedDatetime: timestamp
    "グループID"
    groupId: uuid
    "ID"
    helpPointExchangedAchievementId: uuid
    "お手伝いキッズID"
    helperKidId: uuid
}

"order by sum() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementSumOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

input HelperKidsHelpPointExchangedAchievementUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HelperKidsHelpPointExchangedAchievementIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelpPointExchangedAchievementSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelpPointExchangedAchievementBoolExp!
}

"order by varPop() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementVarPopOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by varSamp() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementVarSampOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"order by variance() on columns of table \"helper_kids.help_point_exchanged_achievement\""
input HelperKidsHelpPointExchangedAchievementVarianceOrderBy {
    "交換件数"
    exchangeCount: OrderBy
    "交換合計ポイント"
    exchangeTotalPoint: OrderBy
}

"Boolean expression to filter rows from the table \"helper_kids.helper_kid\". All fields are combined with a logical 'AND'."
input HelperKidsHelperKidBoolExp {
    _and: [HelperKidsHelperKidBoolExp!]
    _not: HelperKidsHelperKidBoolExp
    _or: [HelperKidsHelperKidBoolExp!]
    group: GroupBoolExp
    groupId: UuidComparisonExp
    helpPointEarnedAchievements: HelperKidsHelpPointEarnedAchievementBoolExp
    helpPointEarnedAchievementsAggregate: HelperKidsHelpPointEarnedAchievementAggregateBoolExp
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementBoolExp
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateBoolExp
    helperKidId: UuidComparisonExp
    helperKidParents: HelperKidsHelperKidParentBoolExp
    helperKidParentsAggregate: HelperKidsHelperKidParentAggregateBoolExp
    helperKidPoint: HelperKidsHelperKidPointBoolExp
    name: StringComparisonExp
    nameSuffix: StringComparisonExp
}

"input type for inserting data into table \"helper_kids.helper_kid\""
input HelperKidsHelperKidInsertInput {
    group: GroupObjRelInsertInput
    "グループID"
    groupId: uuid
    helpPointEarnedAchievements: HelperKidsHelpPointEarnedAchievementArrRelInsertInput
    helpPointExchangedAchievements: HelperKidsHelpPointExchangedAchievementArrRelInsertInput
    "ID"
    helperKidId: uuid
    helperKidParents: HelperKidsHelperKidParentArrRelInsertInput
    helperKidPoint: HelperKidsHelperKidPointObjRelInsertInput
    "氏名"
    name: String
    "名前 接尾辞"
    nameSuffix: String
}

"input type for inserting object relation for remote table \"helper_kids.helper_kid\""
input HelperKidsHelperKidObjRelInsertInput {
    data: HelperKidsHelperKidInsertInput!
    "upsert condition"
    onConflict: HelperKidsHelperKidOnConflict
}

"on_conflict condition type for table \"helper_kids.helper_kid\""
input HelperKidsHelperKidOnConflict {
    constraint: HelperKidsHelperKidConstraint!
    updateColumns: [HelperKidsHelperKidUpdateColumn!]! = []
    where: HelperKidsHelperKidBoolExp
}

"Ordering options when selecting data from \"helper_kids.helper_kid\"."
input HelperKidsHelperKidOrderBy {
    group: GroupOrderBy
    groupId: OrderBy
    helpPointEarnedAchievementsAggregate: HelperKidsHelpPointEarnedAchievementAggregateOrderBy
    helpPointExchangedAchievementsAggregate: HelperKidsHelpPointExchangedAchievementAggregateOrderBy
    helperKidId: OrderBy
    helperKidParentsAggregate: HelperKidsHelperKidParentAggregateOrderBy
    helperKidPoint: HelperKidsHelperKidPointOrderBy
    name: OrderBy
    nameSuffix: OrderBy
}

input HelperKidsHelperKidParentAggregateBoolExp {
    count: helperKidsHelperKidParentAggregateBoolExpCount
}

"order by aggregate values of table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentAggregateOrderBy {
    count: OrderBy
    max: HelperKidsHelperKidParentMaxOrderBy
    min: HelperKidsHelperKidParentMinOrderBy
}

"input type for inserting array relation for remote table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentArrRelInsertInput {
    data: [HelperKidsHelperKidParentInsertInput!]!
    "upsert condition"
    onConflict: HelperKidsHelperKidParentOnConflict
}

"Boolean expression to filter rows from the table \"helper_kids.helper_kid_parent\". All fields are combined with a logical 'AND'."
input HelperKidsHelperKidParentBoolExp {
    _and: [HelperKidsHelperKidParentBoolExp!]
    _not: HelperKidsHelperKidParentBoolExp
    _or: [HelperKidsHelperKidParentBoolExp!]
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
    helperKidParentId: UuidComparisonExp
    parentUserId: UuidComparisonExp
    user: UserBoolExp
}

"input type for inserting data into table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentInsertInput {
    helperKid: HelperKidsHelperKidObjRelInsertInput
    helperKidId: uuid
    helperKidParentId: uuid
    parentUserId: uuid
    user: UserObjRelInsertInput
}

"order by max() on columns of table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentMaxOrderBy {
    helperKidId: OrderBy
    helperKidParentId: OrderBy
    parentUserId: OrderBy
}

"order by min() on columns of table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentMinOrderBy {
    helperKidId: OrderBy
    helperKidParentId: OrderBy
    parentUserId: OrderBy
}

"on_conflict condition type for table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentOnConflict {
    constraint: HelperKidsHelperKidParentConstraint!
    updateColumns: [HelperKidsHelperKidParentUpdateColumn!]! = []
    where: HelperKidsHelperKidParentBoolExp
}

"Ordering options when selecting data from \"helper_kids.helper_kid_parent\"."
input HelperKidsHelperKidParentOrderBy {
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
    helperKidParentId: OrderBy
    parentUserId: OrderBy
    user: UserOrderBy
}

"primary key columns input for table: helper_kids.helper_kid_parent"
input HelperKidsHelperKidParentPkColumnsInput {
    helperKidParentId: uuid!
}

"input type for updating data in table \"helper_kids.helper_kid_parent\""
input HelperKidsHelperKidParentSetInput {
    helperKidId: uuid
    helperKidParentId: uuid
    parentUserId: uuid
}

"Streaming cursor of the table \"helper_kids_helper_kid_parent\""
input HelperKidsHelperKidParentStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelperKidParentStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelperKidParentStreamCursorValueInput {
    helperKidId: uuid
    helperKidParentId: uuid
    parentUserId: uuid
}

input HelperKidsHelperKidParentUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelperKidParentSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelperKidParentBoolExp!
}

"primary key columns input for table: helper_kids.helper_kid"
input HelperKidsHelperKidPkColumnsInput {
    "ID"
    helperKidId: uuid!
}

"Boolean expression to filter rows from the table \"helper_kids.helper_kid_point\". All fields are combined with a logical 'AND'."
input HelperKidsHelperKidPointBoolExp {
    _and: [HelperKidsHelperKidPointBoolExp!]
    _not: HelperKidsHelperKidPointBoolExp
    _or: [HelperKidsHelperKidPointBoolExp!]
    helperKid: HelperKidsHelperKidBoolExp
    helperKidId: UuidComparisonExp
    lastHelpDatetime: TimestampComparisonExp
    point: IntComparisonExp
}

"input type for incrementing numeric columns in table \"helper_kids.helper_kid_point\""
input HelperKidsHelperKidPointIncInput {
    "ポイント"
    point: Int
}

"input type for inserting data into table \"helper_kids.helper_kid_point\""
input HelperKidsHelperKidPointInsertInput {
    helperKid: HelperKidsHelperKidObjRelInsertInput
    "お手伝いキッズID"
    helperKidId: uuid
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp
    "ポイント"
    point: Int
}

"input type for inserting object relation for remote table \"helper_kids.helper_kid_point\""
input HelperKidsHelperKidPointObjRelInsertInput {
    data: HelperKidsHelperKidPointInsertInput!
    "upsert condition"
    onConflict: HelperKidsHelperKidPointOnConflict
}

"on_conflict condition type for table \"helper_kids.helper_kid_point\""
input HelperKidsHelperKidPointOnConflict {
    constraint: HelperKidsHelperKidPointConstraint!
    updateColumns: [HelperKidsHelperKidPointUpdateColumn!]! = []
    where: HelperKidsHelperKidPointBoolExp
}

"Ordering options when selecting data from \"helper_kids.helper_kid_point\"."
input HelperKidsHelperKidPointOrderBy {
    helperKid: HelperKidsHelperKidOrderBy
    helperKidId: OrderBy
    lastHelpDatetime: OrderBy
    point: OrderBy
}

"primary key columns input for table: helper_kids.helper_kid_point"
input HelperKidsHelperKidPointPkColumnsInput {
    "お手伝いキッズID"
    helperKidId: uuid!
}

"input type for updating data in table \"helper_kids.helper_kid_point\""
input HelperKidsHelperKidPointSetInput {
    "お手伝いキッズID"
    helperKidId: uuid
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp
    "ポイント"
    point: Int
}

"Streaming cursor of the table \"helper_kids_helper_kid_point\""
input HelperKidsHelperKidPointStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelperKidPointStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelperKidPointStreamCursorValueInput {
    "お手伝いキッズID"
    helperKidId: uuid
    "最後のお手伝い日時"
    lastHelpDatetime: timestamp
    "ポイント"
    point: Int
}

input HelperKidsHelperKidPointUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HelperKidsHelperKidPointIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelperKidPointSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelperKidPointBoolExp!
}

"input type for updating data in table \"helper_kids.helper_kid\""
input HelperKidsHelperKidSetInput {
    "グループID"
    groupId: uuid
    "ID"
    helperKidId: uuid
    "氏名"
    name: String
    "名前 接尾辞"
    nameSuffix: String
}

"Streaming cursor of the table \"helper_kids_helper_kid\""
input HelperKidsHelperKidStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HelperKidsHelperKidStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HelperKidsHelperKidStreamCursorValueInput {
    "グループID"
    groupId: uuid
    "ID"
    helperKidId: uuid
    "氏名"
    name: String
    "名前 接尾辞"
    nameSuffix: String
}

input HelperKidsHelperKidUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: HelperKidsHelperKidSetInput
    "filter the rows which have to be updated"
    where: HelperKidsHelperKidBoolExp!
}

input ImportFileHistoryAggregateBoolExp {
    count: importFileHistoryAggregateBoolExpCount
}

"order by aggregate values of table \"import_file_history\""
input ImportFileHistoryAggregateOrderBy {
    count: OrderBy
    max: ImportFileHistoryMaxOrderBy
    min: ImportFileHistoryMinOrderBy
}

"input type for inserting array relation for remote table \"import_file_history\""
input ImportFileHistoryArrRelInsertInput {
    data: [ImportFileHistoryInsertInput!]!
    "upsert condition"
    onConflict: ImportFileHistoryOnConflict
}

"Boolean expression to filter rows from the table \"import_file_history\". All fields are combined with a logical 'AND'."
input ImportFileHistoryBoolExp {
    _and: [ImportFileHistoryBoolExp!]
    _not: ImportFileHistoryBoolExp
    _or: [ImportFileHistoryBoolExp!]
    credit_card_summary: CreditCardSummaryBoolExp
    fileName: StringComparisonExp
    fileType: StringComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
    importDatetime: TimestampComparisonExp
    importUserId: UuidComparisonExp
    user: UserBoolExp
}

"input type for inserting data into table \"import_file_history\""
input ImportFileHistoryInsertInput {
    credit_card_summary: CreditCardSummaryObjRelInsertInput
    fileName: String
    fileType: String
    group: GroupObjRelInsertInput
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
    user: UserObjRelInsertInput
}

"order by max() on columns of table \"import_file_history\""
input ImportFileHistoryMaxOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"order by min() on columns of table \"import_file_history\""
input ImportFileHistoryMinOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"input type for inserting object relation for remote table \"import_file_history\""
input ImportFileHistoryObjRelInsertInput {
    data: ImportFileHistoryInsertInput!
    "upsert condition"
    onConflict: ImportFileHistoryOnConflict
}

"on_conflict condition type for table \"import_file_history\""
input ImportFileHistoryOnConflict {
    constraint: ImportFileHistoryConstraint!
    updateColumns: [ImportFileHistoryUpdateColumn!]! = []
    where: ImportFileHistoryBoolExp
}

"Ordering options when selecting data from \"import_file_history\"."
input ImportFileHistoryOrderBy {
    credit_card_summary: CreditCardSummaryOrderBy
    fileName: OrderBy
    fileType: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
    user: UserOrderBy
}

"primary key columns input for table: import_file_history"
input ImportFileHistoryPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"import_file_history\""
input ImportFileHistorySetInput {
    fileName: String
    fileType: String
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
}

"Streaming cursor of the table \"import_file_history\""
input ImportFileHistoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: ImportFileHistoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input ImportFileHistoryStreamCursorValueInput {
    fileName: String
    fileType: String
    groupId: uuid
    id: uuid
    importDatetime: timestamp
    importUserId: uuid
}

input ImportFileHistoryUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: ImportFileHistorySetInput
    "filter the rows which have to be updated"
    where: ImportFileHistoryBoolExp!
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input IntComparisonExp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _isNull: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"iocome_type\". All fields are combined with logical 'AND'."
input IocomeTypeComparisonExp {
    _eq: iocome_type
    _gt: iocome_type
    _gte: iocome_type
    _in: [iocome_type!]
    _isNull: Boolean
    _lt: iocome_type
    _lte: iocome_type
    _neq: iocome_type
    _nin: [iocome_type!]
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input NumericComparisonExp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _isNull: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input StringComparisonExp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _isNull: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

input SummaryCategoryByGroupAggregateBoolExp {
    count: summaryCategoryByGroupAggregateBoolExpCount
}

"order by aggregate values of table \"summary_category_by_group\""
input SummaryCategoryByGroupAggregateOrderBy {
    avg: SummaryCategoryByGroupAvgOrderBy
    count: OrderBy
    max: SummaryCategoryByGroupMaxOrderBy
    min: SummaryCategoryByGroupMinOrderBy
    stddev: SummaryCategoryByGroupStddevOrderBy
    stddevPop: SummaryCategoryByGroupStddevPopOrderBy
    stddevSamp: SummaryCategoryByGroupStddevSampOrderBy
    sum: SummaryCategoryByGroupSumOrderBy
    varPop: SummaryCategoryByGroupVarPopOrderBy
    varSamp: SummaryCategoryByGroupVarSampOrderBy
    variance: SummaryCategoryByGroupVarianceOrderBy
}

"input type for inserting array relation for remote table \"summary_category_by_group\""
input SummaryCategoryByGroupArrRelInsertInput {
    data: [SummaryCategoryByGroupInsertInput!]!
    "upsert condition"
    onConflict: SummaryCategoryByGroupOnConflict
}

"order by avg() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"summary_category_by_group\". All fields are combined with a logical 'AND'."
input SummaryCategoryByGroupBoolExp {
    _and: [SummaryCategoryByGroupBoolExp!]
    _not: SummaryCategoryByGroupBoolExp
    _or: [SummaryCategoryByGroupBoolExp!]
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    displayOrder: IntComparisonExp
    group: GroupBoolExp
    groupId: UuidComparisonExp
    id: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"summary_category_by_group\""
input SummaryCategoryByGroupIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"summary_category_by_group\""
input SummaryCategoryByGroupInsertInput {
    category: CategoryObjRelInsertInput
    categoryId: uuid
    displayOrder: Int
    group: GroupObjRelInsertInput
    groupId: uuid
    id: uuid
}

"order by max() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupMaxOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"order by min() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupMinOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"on_conflict condition type for table \"summary_category_by_group\""
input SummaryCategoryByGroupOnConflict {
    constraint: SummaryCategoryByGroupConstraint!
    updateColumns: [SummaryCategoryByGroupUpdateColumn!]! = []
    where: SummaryCategoryByGroupBoolExp
}

"Ordering options when selecting data from \"summary_category_by_group\"."
input SummaryCategoryByGroupOrderBy {
    category: CategoryOrderBy
    categoryId: OrderBy
    displayOrder: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
}

"primary key columns input for table: summary_category_by_group"
input SummaryCategoryByGroupPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"summary_category_by_group\""
input SummaryCategoryByGroupSetInput {
    categoryId: uuid
    displayOrder: Int
    groupId: uuid
    id: uuid
}

"order by stddev() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"summary_category_by_group\""
input SummaryCategoryByGroupStreamCursorInput {
    "Stream column input with initial value"
    initialValue: SummaryCategoryByGroupStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input SummaryCategoryByGroupStreamCursorValueInput {
    categoryId: uuid
    displayOrder: Int
    groupId: uuid
    id: uuid
}

"order by sum() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupSumOrderBy {
    displayOrder: OrderBy
}

input SummaryCategoryByGroupUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: SummaryCategoryByGroupIncInput
    "sets the columns of the filtered rows to the given values"
    _set: SummaryCategoryByGroupSetInput
    "filter the rows which have to be updated"
    where: SummaryCategoryByGroupBoolExp!
}

"order by varPop() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"summary_category_by_group\""
input SummaryCategoryByGroupVarianceOrderBy {
    displayOrder: OrderBy
}

input SummaryCategoryByUserAggregateBoolExp {
    count: summaryCategoryByUserAggregateBoolExpCount
}

"order by aggregate values of table \"summary_category_by_user\""
input SummaryCategoryByUserAggregateOrderBy {
    avg: SummaryCategoryByUserAvgOrderBy
    count: OrderBy
    max: SummaryCategoryByUserMaxOrderBy
    min: SummaryCategoryByUserMinOrderBy
    stddev: SummaryCategoryByUserStddevOrderBy
    stddevPop: SummaryCategoryByUserStddevPopOrderBy
    stddevSamp: SummaryCategoryByUserStddevSampOrderBy
    sum: SummaryCategoryByUserSumOrderBy
    varPop: SummaryCategoryByUserVarPopOrderBy
    varSamp: SummaryCategoryByUserVarSampOrderBy
    variance: SummaryCategoryByUserVarianceOrderBy
}

"input type for inserting array relation for remote table \"summary_category_by_user\""
input SummaryCategoryByUserArrRelInsertInput {
    data: [SummaryCategoryByUserInsertInput!]!
    "upsert condition"
    onConflict: SummaryCategoryByUserOnConflict
}

"order by avg() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"summary_category_by_user\". All fields are combined with a logical 'AND'."
input SummaryCategoryByUserBoolExp {
    _and: [SummaryCategoryByUserBoolExp!]
    _not: SummaryCategoryByUserBoolExp
    _or: [SummaryCategoryByUserBoolExp!]
    category: CategoryBoolExp
    categoryId: UuidComparisonExp
    displayOrder: IntComparisonExp
    id: UuidComparisonExp
    user: UserBoolExp
    userId: UuidComparisonExp
}

"input type for incrementing numeric columns in table \"summary_category_by_user\""
input SummaryCategoryByUserIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"summary_category_by_user\""
input SummaryCategoryByUserInsertInput {
    category: CategoryObjRelInsertInput
    categoryId: uuid
    displayOrder: Int
    id: uuid
    user: UserObjRelInsertInput
    userId: uuid
}

"order by max() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserMaxOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    id: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserMinOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    id: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"summary_category_by_user\""
input SummaryCategoryByUserOnConflict {
    constraint: SummaryCategoryByUserConstraint!
    updateColumns: [SummaryCategoryByUserUpdateColumn!]! = []
    where: SummaryCategoryByUserBoolExp
}

"Ordering options when selecting data from \"summary_category_by_user\"."
input SummaryCategoryByUserOrderBy {
    category: CategoryOrderBy
    categoryId: OrderBy
    displayOrder: OrderBy
    id: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: summary_category_by_user"
input SummaryCategoryByUserPkColumnsInput {
    id: uuid!
}

"input type for updating data in table \"summary_category_by_user\""
input SummaryCategoryByUserSetInput {
    categoryId: uuid
    displayOrder: Int
    id: uuid
    userId: uuid
}

"order by stddev() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"summary_category_by_user\""
input SummaryCategoryByUserStreamCursorInput {
    "Stream column input with initial value"
    initialValue: SummaryCategoryByUserStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input SummaryCategoryByUserStreamCursorValueInput {
    categoryId: uuid
    displayOrder: Int
    id: uuid
    userId: uuid
}

"order by sum() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserSumOrderBy {
    displayOrder: OrderBy
}

input SummaryCategoryByUserUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: SummaryCategoryByUserIncInput
    "sets the columns of the filtered rows to the given values"
    _set: SummaryCategoryByUserSetInput
    "filter the rows which have to be updated"
    where: SummaryCategoryByUserBoolExp!
}

"order by varPop() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"summary_category_by_user\""
input SummaryCategoryByUserVarianceOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input TimestampComparisonExp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _isNull: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to filter rows from the table \"total_by_account_view\". All fields are combined with a logical 'AND'."
input TotalByAccountViewBoolExp {
    _and: [TotalByAccountViewBoolExp!]
    _not: TotalByAccountViewBoolExp
    _or: [TotalByAccountViewBoolExp!]
    accountId: UuidComparisonExp
    accountName: StringComparisonExp
    date: DateComparisonExp
    displayOrder: IntComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"total_by_account_view\"."
input TotalByAccountViewOrderBy {
    accountId: OrderBy
    accountName: OrderBy
    date: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"total_by_account_view\""
input TotalByAccountViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TotalByAccountViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TotalByAccountViewStreamCursorValueInput {
    accountId: uuid
    accountName: String
    date: date
    displayOrder: Int
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"Boolean expression to filter rows from the table \"total_by_category_view\". All fields are combined with a logical 'AND'."
input TotalByCategoryViewBoolExp {
    _and: [TotalByCategoryViewBoolExp!]
    _not: TotalByCategoryViewBoolExp
    _or: [TotalByCategoryViewBoolExp!]
    categoryId: UuidComparisonExp
    categoryName: StringComparisonExp
    date: DateComparisonExp
    genreId: UuidComparisonExp
    genreName: StringComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"total_by_category_view\"."
input TotalByCategoryViewOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    date: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"total_by_category_view\""
input TotalByCategoryViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TotalByCategoryViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TotalByCategoryViewStreamCursorValueInput {
    categoryId: uuid
    categoryName: String
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

"Boolean expression to filter rows from the table \"total_by_genre_view\". All fields are combined with a logical 'AND'."
input TotalByGenreViewBoolExp {
    _and: [TotalByGenreViewBoolExp!]
    _not: TotalByGenreViewBoolExp
    _or: [TotalByGenreViewBoolExp!]
    date: DateComparisonExp
    genreId: UuidComparisonExp
    genreName: StringComparisonExp
    groupId: UuidComparisonExp
    iocomeType: IocomeTypeComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"total_by_genre_view\"."
input TotalByGenreViewOrderBy {
    date: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"total_by_genre_view\""
input TotalByGenreViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TotalByGenreViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TotalByGenreViewStreamCursorValueInput {
    date: date
    genreId: uuid
    genreName: String
    groupId: uuid
    iocomeType: iocome_type
    total: numeric
}

input TransferCategoryAggregateBoolExp {
    count: transferCategoryAggregateBoolExpCount
}

"order by aggregate values of table \"transfer_category\""
input TransferCategoryAggregateOrderBy {
    count: OrderBy
    max: TransferCategoryMaxOrderBy
    min: TransferCategoryMinOrderBy
}

"input type for inserting array relation for remote table \"transfer_category\""
input TransferCategoryArrRelInsertInput {
    data: [TransferCategoryInsertInput!]!
    "upsert condition"
    onConflict: TransferCategoryOnConflict
}

"Boolean expression to filter rows from the table \"transfer_category\". All fields are combined with a logical 'AND'."
input TransferCategoryBoolExp {
    _and: [TransferCategoryBoolExp!]
    _not: TransferCategoryBoolExp
    _or: [TransferCategoryBoolExp!]
    groupId: UuidComparisonExp
    incomeCategoryId: UuidComparisonExp
    outcomeCategoryId: UuidComparisonExp
}

"input type for inserting data into table \"transfer_category\""
input TransferCategoryInsertInput {
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

"order by max() on columns of table \"transfer_category\""
input TransferCategoryMaxOrderBy {
    "グループID"
    groupId: OrderBy
    "収入カテゴリID"
    incomeCategoryId: OrderBy
    "支出カテゴリID"
    outcomeCategoryId: OrderBy
}

"order by min() on columns of table \"transfer_category\""
input TransferCategoryMinOrderBy {
    "グループID"
    groupId: OrderBy
    "収入カテゴリID"
    incomeCategoryId: OrderBy
    "支出カテゴリID"
    outcomeCategoryId: OrderBy
}

"on_conflict condition type for table \"transfer_category\""
input TransferCategoryOnConflict {
    constraint: TransferCategoryConstraint!
    updateColumns: [TransferCategoryUpdateColumn!]! = []
    where: TransferCategoryBoolExp
}

"Ordering options when selecting data from \"transfer_category\"."
input TransferCategoryOrderBy {
    groupId: OrderBy
    incomeCategoryId: OrderBy
    outcomeCategoryId: OrderBy
}

"primary key columns input for table: transfer_category"
input TransferCategoryPkColumnsInput {
    "グループID"
    groupId: uuid!
}

"input type for updating data in table \"transfer_category\""
input TransferCategorySetInput {
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

"Streaming cursor of the table \"transfer_category\""
input TransferCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: TransferCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input TransferCategoryStreamCursorValueInput {
    "グループID"
    groupId: uuid
    "収入カテゴリID"
    incomeCategoryId: uuid
    "支出カテゴリID"
    outcomeCategoryId: uuid
}

input TransferCategoryUpdates {
    "sets the columns of the filtered rows to the given values"
    _set: TransferCategorySetInput
    "filter the rows which have to be updated"
    where: TransferCategoryBoolExp!
}

"Boolean expression to filter rows from the table \"user\". All fields are combined with a logical 'AND'."
input UserBoolExp {
    _and: [UserBoolExp!]
    _not: UserBoolExp
    _or: [UserBoolExp!]
    affiliations: AffiliationBoolExp
    affiliationsAggregate: AffiliationAggregateBoolExp
    credit_card_details: CreditCardDetailBoolExp
    credit_card_detailsAggregate: CreditCardDetailAggregateBoolExp
    daily_details: DailyDetailBoolExp
    daily_detailsAggregate: DailyDetailAggregateBoolExp
    displayOrder: IntComparisonExp
    email: StringComparisonExp
    import_file_histories: ImportFileHistoryBoolExp
    import_file_historiesAggregate: ImportFileHistoryAggregateBoolExp
    summary_category_by_users: SummaryCategoryByUserBoolExp
    summary_category_by_usersAggregate: SummaryCategoryByUserAggregateBoolExp
    userId: UuidComparisonExp
    userName: StringComparisonExp
}

"input type for incrementing numeric columns in table \"user\""
input UserIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"user\""
input UserInsertInput {
    affiliations: AffiliationArrRelInsertInput
    credit_card_details: CreditCardDetailArrRelInsertInput
    daily_details: DailyDetailArrRelInsertInput
    displayOrder: Int
    email: String
    import_file_histories: ImportFileHistoryArrRelInsertInput
    summary_category_by_users: SummaryCategoryByUserArrRelInsertInput
    userId: uuid
    userName: String
}

"input type for inserting object relation for remote table \"user\""
input UserObjRelInsertInput {
    data: UserInsertInput!
    "upsert condition"
    onConflict: UserOnConflict
}

"on_conflict condition type for table \"user\""
input UserOnConflict {
    constraint: UserConstraint!
    updateColumns: [UserUpdateColumn!]! = []
    where: UserBoolExp
}

"Ordering options when selecting data from \"user\"."
input UserOrderBy {
    affiliationsAggregate: AffiliationAggregateOrderBy
    credit_card_detailsAggregate: CreditCardDetailAggregateOrderBy
    daily_detailsAggregate: DailyDetailAggregateOrderBy
    displayOrder: OrderBy
    email: OrderBy
    import_file_historiesAggregate: ImportFileHistoryAggregateOrderBy
    summary_category_by_usersAggregate: SummaryCategoryByUserAggregateOrderBy
    userId: OrderBy
    userName: OrderBy
}

"primary key columns input for table: user"
input UserPkColumnsInput {
    userId: uuid!
}

"input type for updating data in table \"user\""
input UserSetInput {
    displayOrder: Int
    email: String
    userId: uuid
    userName: String
}

"Streaming cursor of the table \"user\""
input UserStreamCursorInput {
    "Stream column input with initial value"
    initialValue: UserStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input UserStreamCursorValueInput {
    displayOrder: Int
    email: String
    userId: uuid
    userName: String
}

input UserUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: UserIncInput
    "sets the columns of the filtered rows to the given values"
    _set: UserSetInput
    "filter the rows which have to be updated"
    where: UserBoolExp!
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input UuidComparisonExp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _isNull: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}

input accountAggregateBoolExpBool_and {
    arguments: AccountSelectColumnAccountAggregateBoolExpBool_andArgumentsColumns!
    distinct: Boolean
    filter: AccountBoolExp
    predicate: BooleanComparisonExp!
}

input accountAggregateBoolExpBool_or {
    arguments: AccountSelectColumnAccountAggregateBoolExpBool_orArgumentsColumns!
    distinct: Boolean
    filter: AccountBoolExp
    predicate: BooleanComparisonExp!
}

input accountAggregateBoolExpCount {
    arguments: [AccountSelectColumn!]
    distinct: Boolean
    filter: AccountBoolExp
    predicate: IntComparisonExp!
}

input accountTotalArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input affiliationAggregateBoolExpCount {
    arguments: [AffiliationSelectColumn!]
    distinct: Boolean
    filter: AffiliationBoolExp
    predicate: IntComparisonExp!
}

input categoryAggregateBoolExpBool_and {
    arguments: CategorySelectColumnCategoryAggregateBoolExpBool_andArgumentsColumns!
    distinct: Boolean
    filter: CategoryBoolExp
    predicate: BooleanComparisonExp!
}

input categoryAggregateBoolExpBool_or {
    arguments: CategorySelectColumnCategoryAggregateBoolExpBool_orArgumentsColumns!
    distinct: Boolean
    filter: CategoryBoolExp
    predicate: BooleanComparisonExp!
}

input categoryAggregateBoolExpCount {
    arguments: [CategorySelectColumn!]
    distinct: Boolean
    filter: CategoryBoolExp
    predicate: IntComparisonExp!
}

input categoryTotalByMonthArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input creditCardDetailAggregateBoolExpCount {
    arguments: [CreditCardDetailSelectColumn!]
    distinct: Boolean
    filter: CreditCardDetailBoolExp
    predicate: IntComparisonExp!
}

input creditCardSummaryAggregateBoolExpCount {
    arguments: [CreditCardSummarySelectColumn!]
    distinct: Boolean
    filter: CreditCardSummaryBoolExp
    predicate: IntComparisonExp!
}

input dailyDetailAggregateBoolExpCount {
    arguments: [DailyDetailSelectColumn!]
    distinct: Boolean
    filter: DailyDetailBoolExp
    predicate: IntComparisonExp!
}

input dailyDetailByDateArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input genreAggregateBoolExpBool_and {
    arguments: GenreSelectColumnGenreAggregateBoolExpBool_andArgumentsColumns!
    distinct: Boolean
    filter: GenreBoolExp
    predicate: BooleanComparisonExp!
}

input genreAggregateBoolExpBool_or {
    arguments: GenreSelectColumnGenreAggregateBoolExpBool_orArgumentsColumns!
    distinct: Boolean
    filter: GenreBoolExp
    predicate: BooleanComparisonExp!
}

input genreAggregateBoolExpCount {
    arguments: [GenreSelectColumn!]
    distinct: Boolean
    filter: GenreBoolExp
    predicate: IntComparisonExp!
}

input genreTotalByMonthArgs {
    from_date: date
    group_id: uuid
    to_date: date
}

input groupApplicationAggregateBoolExpCount {
    arguments: [GroupApplicationSelectColumn!]
    distinct: Boolean
    filter: GroupApplicationBoolExp
    predicate: IntComparisonExp!
}

input helperKidsHelpPointEarnedAchievementAggregateBoolExpCount {
    arguments: [HelperKidsHelpPointEarnedAchievementSelectColumn!]
    distinct: Boolean
    filter: HelperKidsHelpPointEarnedAchievementBoolExp
    predicate: IntComparisonExp!
}

input helperKidsHelpPointEarnedDetailAggregateBoolExpCount {
    arguments: [HelperKidsHelpPointEarnedDetailSelectColumn!]
    distinct: Boolean
    filter: HelperKidsHelpPointEarnedDetailBoolExp
    predicate: IntComparisonExp!
}

input helperKidsHelpPointExchangedAchievementAggregateBoolExpCount {
    arguments: [HelperKidsHelpPointExchangedAchievementSelectColumn!]
    distinct: Boolean
    filter: HelperKidsHelpPointExchangedAchievementBoolExp
    predicate: IntComparisonExp!
}

input helperKidsHelperKidParentAggregateBoolExpCount {
    arguments: [HelperKidsHelperKidParentSelectColumn!]
    distinct: Boolean
    filter: HelperKidsHelperKidParentBoolExp
    predicate: IntComparisonExp!
}

input importFileHistoryAggregateBoolExpCount {
    arguments: [ImportFileHistorySelectColumn!]
    distinct: Boolean
    filter: ImportFileHistoryBoolExp
    predicate: IntComparisonExp!
}

input summaryCategoryByGroupAggregateBoolExpCount {
    arguments: [SummaryCategoryByGroupSelectColumn!]
    distinct: Boolean
    filter: SummaryCategoryByGroupBoolExp
    predicate: IntComparisonExp!
}

input summaryCategoryByUserAggregateBoolExpCount {
    arguments: [SummaryCategoryByUserSelectColumn!]
    distinct: Boolean
    filter: SummaryCategoryByUserBoolExp
    predicate: IntComparisonExp!
}

input transferCategoryAggregateBoolExpCount {
    arguments: [TransferCategorySelectColumn!]
    distinct: Boolean
    filter: TransferCategoryBoolExp
    predicate: IntComparisonExp!
}
